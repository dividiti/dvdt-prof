[
  {
    "timestamp": {
      "start": "2018-02-09T10:36:48.553314", 
      "end": "2018-02-09T10:36:48.553428"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe741981c", 
    "queue": "0x55a2b3dc00", 
    "call": "clCreateCommandQueue", 
    "context": "0x55a2b19800", 
    "device": "0x7f98695ee0", 
    "properties": 0
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe7417578", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.557456", 
      "end": "2018-02-09T10:36:48.557477"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe741756c", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#if defined(FIXED_POINT_POSITION)\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n\n#define ADD_OP(a, b) ADD_SAT_OP_EXPAND((a), (b), DATA_TYPE_PROMOTED, 8)\n#define MUL_OP(a, b) MUL_SAT_OP_EXPAND(CONVERT((a), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), CONVERT((b), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), DATA_TYPE_PROMOTED, 8, FIXED_POINT_POSITION)\n\n// There is no need to have a larger intermediate type for qs32 because all the arguments are already promoted\nMULQ_SAT_IMPL(qs32x8, qs32x8)\n\n#else /* FIXED_POINT_POSITION */\n\n#undef CONVERT_SAT\n\n#define ADD_OP(a, b) ((a) + (b))\n#define MUL_OP(a, b) ((a) * (b))\n#define CONVERT_SAT(a, b) ((a))\n\n#endif /* FIXED_POINT_POSITION */\n\n#if defined(DATA_TYPE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if STRIDE_X == 1\n#define CONVOLUTION1x3(acc, src_row_ptr, weights_row_ptr) CONVOLUTION1x3_STRIDE1(acc, src_row_ptr, weights_row_ptr)\n#elif STRIDE_X == 2 /* STRIDE_X == 1 */\n#define CONVOLUTION1x3(acc, src_row_ptr, weights_row_ptr) CONVOLUTION1x3_STRIDE2(acc, src_row_ptr, weights_row_ptr)\n#else /* STRIDE_X not equals 1 or 2 */\n#error \"STRIDE_X larger than 2 is not supported\"\n#endif /* STRIDE_X == 2 */\n\n#define CONVOLUTION1x3_STRIDE1(acc, src_row_ptr, weights_row_ptr)                                                                                  \\\n    ({                                                                                                                                             \\\n        VEC_DATA_TYPE(DATA_TYPE, 3)                                                                                                                \\\n        weights_values0 = vload3(0, weights_row_ptr);                                                                                              \\\n        VEC_DATA_TYPE(DATA_TYPE, 8)                                                                                                                \\\n        src0 = vload8(0, src_row_ptr);                                                                                                             \\\n        VEC_DATA_TYPE(DATA_TYPE, 2)                                                                                                                \\\n        src1 = vload2(0, src_row_ptr + 8);                                                                                                         \\\n        \\\n        acc = ADD_OP(acc, MUL_OP(src0, (VEC_DATA_TYPE(DATA_TYPE, 8))weights_values0.s0));                                                          \\\n        acc = ADD_OP(acc, MUL_OP((VEC_DATA_TYPE(DATA_TYPE, 8))(src0.s1234, src0.s567, src1.s0), (VEC_DATA_TYPE(DATA_TYPE, 8))weights_values0.s1)); \\\n        acc = ADD_OP(acc, MUL_OP((VEC_DATA_TYPE(DATA_TYPE, 8))(src0.s234, src0.s567, src1.s01), (VEC_DATA_TYPE(DATA_TYPE, 8))weights_values0.s2)); \\\n    })\n\n#define CONVOLUTION1x3_STRIDE2(acc, src_row_ptr, weights_row_ptr)                                                                               \\\n    ({                                                                                                                                          \\\n        VEC_DATA_TYPE(DATA_TYPE, 3)                                                                                                             \\\n        weights_values0 = vload3(0, weights_row_ptr);                                                                                           \\\n        VEC_DATA_TYPE(DATA_TYPE, 16)                                                                                                            \\\n        src0           = vload16(0, src_row_ptr);                                                                                               \\\n        DATA_TYPE src1 = *(src_row_ptr + 16);                                                                                                   \\\n        \\\n        acc = ADD_OP(acc, MUL_OP(src0.even, (VEC_DATA_TYPE(DATA_TYPE, 8))weights_values0.s0));                                                  \\\n        acc = ADD_OP(acc, MUL_OP((VEC_DATA_TYPE(DATA_TYPE, 8))(src0.s1357, src0.s9BDF), (VEC_DATA_TYPE(DATA_TYPE, 8))weights_values0.s1));      \\\n        acc = ADD_OP(acc, MUL_OP((VEC_DATA_TYPE(DATA_TYPE, 8))(src0.s2468, src0.sACE, src1), (VEC_DATA_TYPE(DATA_TYPE, 8))weights_values0.s2)); \\\n    })\n\n/** This kernel performs a direct convolution to convolve the low three dimensions.\n *\n * @note This OpenCL kernel works with stride_x = 1 and 2\n * @note The data type must be passed at compile time using -DDATA_TYPE: e.g. -DDATA_TYPE=float\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note If biases are used then -DHAS_BIAS has to be passed at compile time\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution3x3(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    Image    src     = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D weights = CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(weights);\n    Tensor3D dst     = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)\n    pixels0 = 0;\n\n    __global uchar *weights_addr = (__global uchar *)tensor3D_offset(&weights, 0, 0, 0);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n\n    const int kernel_index = get_global_id(2);\n    weights_addr += kernel_index * weights_stride_w;\n\n    for(volatile int d = 0; d < WEIGHTS_DEPTH; ++d)\n    {\n        CONVOLUTION1x3(pixels0, (__global DATA_TYPE *)(src_addr + 0 * src_stride_y), (__global DATA_TYPE *)(weights_addr + 0 * weights_stride_y));\n        CONVOLUTION1x3(pixels0, (__global DATA_TYPE *)(src_addr + 1 * src_stride_y), (__global DATA_TYPE *)(weights_addr + 1 * weights_stride_y));\n        CONVOLUTION1x3(pixels0, (__global DATA_TYPE *)(src_addr + 2 * src_stride_y), (__global DATA_TYPE *)(weights_addr + 2 * weights_stride_y));\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    pixels0 = ADD_OP(pixels0, (VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)) * ((__global DATA_TYPE *)(vector_offset(&biases, kernel_index))));\n#endif /* defined(HAS_BIAS) */\n\n    vstore8(CONVERT_SAT(pixels0, VEC_DATA_TYPE(DATA_TYPE, 8)), 0, (__global DATA_TYPE *)dst.ptr);\n}\n#endif //defined(DATA_TYPE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x3_BIFROST(acc, src0, src1, weights_row0) \\\n    ({                                                        \\\n        acc.s0 = mad(src0.s0, weights_row0.s0, acc.s0);       \\\n        acc.s1 = mad(src0.s1, weights_row0.s0, acc.s1);       \\\n        acc.s2 = mad(src0.s2, weights_row0.s0, acc.s2);       \\\n        acc.s3 = mad(src0.s3, weights_row0.s0, acc.s3);       \\\n        acc.s0 = mad(src0.s1, weights_row0.s1, acc.s0);       \\\n        acc.s1 = mad(src0.s2, weights_row0.s1, acc.s1);       \\\n        acc.s2 = mad(src0.s3, weights_row0.s1, acc.s2);       \\\n        acc.s3 = mad(src1.s0, weights_row0.s1, acc.s3);       \\\n        acc.s0 = mad(src0.s2, weights_row0.s2, acc.s0);       \\\n        acc.s1 = mad(src0.s3, weights_row0.s2, acc.s1);       \\\n        acc.s2 = mad(src1.s0, weights_row0.s2, acc.s2);       \\\n        acc.s3 = mad(src1.s1, weights_row0.s2, acc.s3);       \\\n    })\n\n/** An optimized direct convolution 3x3 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution3x3_f32_bifrost(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 pixels0 = 0;\n    float4 pixels1 = 0;\n    float4 pixels2 = 0;\n\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n\n    // Note: Since each work-item computes 4x3 elements, we need to load 5 rows from the input tensor\n\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float3 weights_row0 = vload3(0, (__global float *)(weights_addr + 0 * weights_stride_y));\n        float3 weights_row1 = vload3(0, (__global float *)(weights_addr + 1 * weights_stride_y));\n        float3 weights_row2 = vload3(0, (__global float *)(weights_addr + 2 * weights_stride_y));\n        float4 src0;\n        float2 src1;\n\n        // Load values from row0 of input tensor\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload2(0, (__global float *)(src_addr + 0 * src_stride_y) + 4);\n\n        CONVOLUTION1x3_BIFROST(pixels0, src0, src1, weights_row0);\n\n        // Load values from row1 of input tensor\n        src0 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        src1 = vload2(0, (__global float *)(src_addr + 1 * src_stride_y) + 4);\n\n        // Accumulate\n        CONVOLUTION1x3_BIFROST(pixels0, src0, src1, weights_row1);\n        CONVOLUTION1x3_BIFROST(pixels1, src0, src1, weights_row0);\n\n        // Load values from row2 of input tensor\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        src1 = vload2(0, (__global float *)(src_addr + 2 * src_stride_y) + 4);\n\n        // Accumulate\n        CONVOLUTION1x3_BIFROST(pixels0, src0, src1, weights_row2);\n        CONVOLUTION1x3_BIFROST(pixels1, src0, src1, weights_row1);\n        CONVOLUTION1x3_BIFROST(pixels2, src0, src1, weights_row0);\n\n        // Load values from row3 of input tensor\n        src0 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        src1 = vload2(0, (__global float *)(src_addr + 3 * src_stride_y) + 4);\n\n        // Accumulate\n        CONVOLUTION1x3_BIFROST(pixels1, src0, src1, weights_row2);\n        CONVOLUTION1x3_BIFROST(pixels2, src0, src1, weights_row1);\n\n        // Row4\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        src1 = vload2(0, (__global float *)(src_addr + 4 * src_stride_y) + 4);\n\n        // Accumulate\n        CONVOLUTION1x3_BIFROST(pixels2, src0, src1, weights_row2);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    pixels0 += (float4)bias;\n    pixels1 += (float4)bias;\n    pixels2 += (float4)bias;\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(pixels0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(pixels1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(pixels2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n"
    }, 
    "program": "0x55a2b64200", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe7417570"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:48.557497", 
      "end": "2018-02-09T10:36:48.594205"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b64200", 
    "call": "clBuildProgram", 
    "options": " -DDATA_SIZE=32 -DDATA_TYPE=float -DDATA_TYPE_PROMOTED=float -DSTRIDE_X=2 -DWEIGHTS_DEPTH=3 -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a2b57c00", 
    "name": "direct_convolution3x3", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.594317", 
      "end": "2018-02-09T10:36:48.644186"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64200", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74175ac"
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe74176d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.646487", 
      "end": "2018-02-09T10:36:48.646507"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe74176cc", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#if defined(FIXED_POINT_POSITION)\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n#endif /* FIXED_POINT_POSITION */\n\n/** Fill N pixel of the padding edge of a single channel image by replicating the closest valid pixel.\n *\n * @attention  The DATA_TYPE needs to be passed at the compile time.\n * e.g. -DDATA_TYPE=int\n *\n * @attention  The border size for top, bottom, left, right needs to be passed at the compile time.\n * e.g. --DBORDER_SIZE_TOP=0 -DBORDER_SIZE_BOTTOM=2 -DBORDER_SIZE_LEFT=0 -DBORDER_SIZE_RIGHT=2\n *\n * @param[in,out] buf_ptr                           Pointer to the source image. Supported data types: U8, U16, S16, U32, S32, F32\n * @param[in]     buf_stride_x                      Stride of the source image in X dimension (in bytes)\n * @param[in]     buf_step_x                        buf_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]     buf_stride_y                      Stride of the source image in Y dimension (in bytes)\n * @param[in]     buf_step_y                        buf_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]     buf_stride_z                      Stride between images if batching images (in bytes)\n * @param[in]     buf_step_z                        buf_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]     buf_offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in]     width                             Width of the valid region of the image\n * @param[in]     height                            Height of the valid region of the image\n * @param[in]     start_pos                         XY coordinate indicating the start point of the valid region\n */\n__kernel void fill_image_borders_replicate(\n    TENSOR3D_DECLARATION(buf),\n    uint width,\n    uint height,\n    int2 start_pos)\n{\n    Image buf = CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(buf);\n\n    // Update pointer to point to the starting point of the valid region\n    buf.ptr += start_pos.y * buf.stride_y + start_pos.x * buf.stride_x;\n\n    const int total_width = BORDER_SIZE_LEFT + width + BORDER_SIZE_RIGHT;\n    const int gid0        = get_global_id(0);\n    const int gidH        = gid0 - total_width;\n    const int gidW        = gid0 - BORDER_SIZE_LEFT;\n\n    if(gidH >= 0)\n    {\n        // Handle left border\n        DATA_TYPE left_val = *(__global DATA_TYPE *)offset(&buf, 0, gidH);\n        for(int i = -BORDER_SIZE_LEFT; i < 0; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, i, gidH) = left_val;\n        }\n        // Handle right border\n        DATA_TYPE right_val = *(__global DATA_TYPE *)offset(&buf, width - 1, gidH);\n        for(int i = 0; i < BORDER_SIZE_RIGHT; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, width + i, gidH) = right_val;\n        }\n    }\n    else\n    {\n        // Get value for corners\n        int val_idx = gidW;\n        if(gidW < 0 || gidW > (width - 1))\n        {\n            val_idx = gidW < 0 ? 0 : width - 1;\n        }\n\n        // Handle top border\n        DATA_TYPE top_val = *(__global DATA_TYPE *)offset(&buf, val_idx, 0);\n        for(int i = -BORDER_SIZE_TOP; i < 0; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, gidW, i) = top_val;\n        }\n        // Handle bottom border\n        DATA_TYPE bottom_val = *(__global DATA_TYPE *)offset(&buf, val_idx, height - 1);\n        for(int i = 0; i < BORDER_SIZE_BOTTOM; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, gidW, height + i) = bottom_val;\n        }\n    }\n}\n\n/** Fill N pixels of the padding edge of a single channel image with a constant value.\n *\n * @attention  The DATA_TYPE needs to be passed at the compile time.\n * e.g. -DDATA_TYPE=int\n *\n * @attention  The border size for top, bottom, left, right needs to be passed at the compile time.\n * e.g. --DBORDER_SIZE_TOP=0 -DBORDER_SIZE_BOTTOM=2 -DBORDER_SIZE_LEFT=0 -DBORDER_SIZE_RIGHT=2\n *\n * @param[out] buf_ptr                           Pointer to the source image. Supported data types: U8, U16, S16, U32, S32, F32\n * @param[in]  buf_stride_x                      Stride of the source image in X dimension (in bytes)\n * @param[in]  buf_step_x                        buf_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  buf_stride_y                      Stride of the source image in Y dimension (in bytes)\n * @param[in]  buf_step_y                        buf_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  buf_stride_z                      Stride between images if batching images (in bytes)\n * @param[in]  buf_step_z                        buf_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  buf_offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in]  width                             Width of the valid region of the image\n * @param[in]  height                            Height of the valid region of the image\n * @param[in]  start_pos                         XY coordinate indicating the start point of the valid region\n * @param[in]  constant_value                    Constant value to use to fill the edges\n */\n__kernel void fill_image_borders_constant(\n    TENSOR3D_DECLARATION(buf),\n    uint      width,\n    uint      height,\n    int2      start_pos,\n    DATA_TYPE constant_value)\n{\n    Image buf = CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(buf);\n\n    // Update pointer to point to the starting point of the valid region\n    buf.ptr += start_pos.y * buf.stride_y + start_pos.x * buf.stride_x;\n\n    const int total_width = BORDER_SIZE_LEFT + width + BORDER_SIZE_RIGHT;\n    const int gid0        = get_global_id(0);\n    const int gidH        = gid0 - total_width;\n    const int gidW        = gid0 - BORDER_SIZE_LEFT;\n\n    if(gidH >= 0)\n    {\n        // Handle left border\n        for(int i = -BORDER_SIZE_LEFT; i < 0; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, i, gidH) = constant_value;\n        }\n        // Handle right border\n        for(int i = 0; i < BORDER_SIZE_RIGHT; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, width + i, gidH) = constant_value;\n        }\n    }\n    else\n    {\n        // Handle top border\n        for(int i = -BORDER_SIZE_TOP; i < 0; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, gidW, i) = constant_value;\n        }\n        // Handle bottom border\n        for(int i = 0; i < BORDER_SIZE_BOTTOM; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, gidW, height + i) = constant_value;\n        }\n    }\n}\n\n"
    }, 
    "program": "0x55a2b64100", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe74176d0"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:48.646523", 
      "end": "2018-02-09T10:36:48.661283"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b64100", 
    "call": "clBuildProgram", 
    "options": " -DBORDER_SIZE_BOTTOM=1 -DBORDER_SIZE_LEFT=0 -DBORDER_SIZE_RIGHT=1 -DBORDER_SIZE_TOP=0 -DDATA_TYPE=float -DSELECT_TYPE=int -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a2b57a00", 
    "name": "fill_image_borders_constant", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.661360", 
      "end": "2018-02-09T10:36:48.671092"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64100", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741770c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57a00", 
    "arg_value_ptr": "0x7fe7417974", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.671171", 
      "end": "2018-02-09T10:36:48.671181"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57a00", 
    "arg_value_ptr": "0x7fe7417978", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.671192", 
      "end": "2018-02-09T10:36:48.671197"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57a00", 
    "arg_value_ptr": "0x7fe7417988", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.671209", 
      "end": "2018-02-09T10:36:48.671214"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000000000000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57a00", 
    "arg_value_ptr": "0x7fe7417984", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.671226", 
      "end": "2018-02-09T10:36:48.671231"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 11
  }, 
  {
    "buffer": "0x55a2b2d800", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.671261", 
      "end": "2018-02-09T10:36:48.671276"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417cec", 
    "size": 3456
  }, 
  {
    "buffer": "0x55a2b2d400", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.671502", 
      "end": "2018-02-09T10:36:48.671606"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 656772
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe74178f8", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.673886", 
      "end": "2018-02-09T10:36:48.673904"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe74178ec", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2017-2018 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#if defined(FIXED_POINT_POSITION)\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n\n#define ADD_OP(a, b) ADD_SAT_OP_EXPAND((a), (b), DATA_TYPE, VEC_SIZE)\n#define SUB_OP(a, b) SUB_SAT_OP_EXPAND((a), (b), DATA_TYPE, VEC_SIZE)\n#define MUL_OP(a, b) MUL_SAT_OP_EXPAND((a), (b), DATA_TYPE, VEC_SIZE, FIXED_POINT_POSITION)\n#define INVSQRT_OP(a) INVSQRT_OP_EXPAND((a), DATA_TYPE, VEC_SIZE, FIXED_POINT_POSITION)\n#define SQCVT_SAT(a) SQCVT_SAT_OP_EXPAND((a), DATA_TYPE, FIXED_POINT_POSITION)\n\n#else /* FIXED_POINT_POSITION */\n\n#define ADD_OP(a, b) ((a) + (b))\n#define SUB_OP(a, b) ((a) - (b))\n#define MUL_OP(a, b) ((a) * (b))\n#define INVSQRT_OP(a) rsqrt((a))\n#define SQCVT_SAT(a) (a)\n\n#endif /* FIXED_POINT_POSITION */\n\n/** Apply batch normalization.\n *\n * @param[in]  input_ptr                            Pointer to the first source tensor. Supported data types: QS8/QS16/F16/F32\n * @param[in]  input_stride_x                       Stride of the first source tensor in X dimension (in bytes)\n * @param[in]  input_step_x                         input_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  input_stride_y                       Stride of the first source tensor in Y dimension (in bytes)\n * @param[in]  input_step_y                         input_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  input_stride_z                       Stride of the first source tensor in Z dimension (in bytes)\n * @param[in]  input_step_z                         input_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  input_offset_first_element_in_bytes  The offset of the first element in the first source tensor\n * @param[out] output_ptr                           Pointer to the destination tensor. Supported data types: same as @p input_ptr\n * @param[in]  output_stride_x                      Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  output_step_x                        output_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  output_stride_y                      Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  output_step_y                        output_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  output_stride_z                      Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  output_step_z                        output_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  output_offset_first_element_in_bytes The offset of the first element in the destination tensor\n * @param[in]  mean_ptr                             Pointer to the mean source tensor. Supported data types: same as @p input_ptr\n * @param[in]  mean_stride_x                        Stride of the mean source tensor in X dimension (in bytes)\n * @param[in]  mean_step_x                          mean_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  mean_offset_first_element_in_bytes   The offset of the first element in the mean source tensor\n * @param[in]  var_ptr                              Pointer to the var tensor. Supported data types: same as @p input_ptr\n * @param[in]  var_stride_x                         Stride of the var tensor in X dimension (in bytes)\n * @param[in]  var_step_x                           var_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  var_offset_first_element_in_bytes    The offset of the first element in the var source tensor\n * @param[in]  beta_ptr                             Pointer to the beta source tensor. Supported data types: same as @p input_ptr\n * @param[in]  beta_stride_x                        Stride of the beta source tensor in X dimension (in bytes)\n * @param[in]  beta_step_x                          beta_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  beta_offset_first_element_in_bytes   The offset of the first element in the beta source tensor\n * @param[in]  gamma_ptr                            Pointer to the gamma source tensor. Supported data types: same as @p input_ptr\n * @param[in]  gamma_stride_x                       Stride of the gamma source tensor in X dimension (in bytes)\n * @param[in]  gamma_step_x                         gamma_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  gamma_offset_first_element_in_bytes  The offset of the first element in the gamma source tensor\n * @param[in]  epsilon                              Epsilon parameter in the batch normalization equation\n */\n__kernel void batchnormalization_layer(TENSOR3D_DECLARATION(input),\n#ifndef IN_PLACE\n                                       TENSOR3D_DECLARATION(output),\n#endif /* not IN_PLACE */\n                                       VECTOR_DECLARATION(mean),\n                                       VECTOR_DECLARATION(var),\n                                       VECTOR_DECLARATION(beta),\n                                       VECTOR_DECLARATION(gamma),\n                                       float epsilon)\n{\n    Tensor3D in = CONVERT_TO_TENSOR3D_STRUCT(input);\n#ifdef IN_PLACE\n    Tensor3D out = in;\n#else  /* IN_PLACE */\n    Tensor3D out = CONVERT_TO_TENSOR3D_STRUCT(output);\n#endif /* IN_PLACE */\n    Vector mean  = CONVERT_TO_VECTOR_STRUCT(mean);\n    Vector var   = CONVERT_TO_VECTOR_STRUCT(var);\n    Vector beta  = CONVERT_TO_VECTOR_STRUCT(beta);\n    Vector gamma = CONVERT_TO_VECTOR_STRUCT(gamma);\n\n    VEC_DATA_TYPE(DATA_TYPE, VEC_SIZE)\n    data = 0;\n    VEC_DATA_TYPE(DATA_TYPE, VEC_SIZE)\n    denominator = 0;\n    VEC_DATA_TYPE(DATA_TYPE, VEC_SIZE)\n    numerator = 0;\n    VEC_DATA_TYPE(DATA_TYPE, VEC_SIZE)\n    x_bar = 0;\n    VEC_DATA_TYPE(DATA_TYPE, VEC_SIZE)\n    gamma_vec = 0;\n    VEC_DATA_TYPE(DATA_TYPE, VEC_SIZE)\n    beta_vec = 0;\n\n    const int current_slice = get_global_id(2);\n\n    data        = VLOAD(VEC_SIZE)(0, (__global DATA_TYPE *)in.ptr);\n    denominator = *((__global DATA_TYPE *)(var.ptr + current_slice * var.stride_x));\n    denominator = INVSQRT_OP(ADD_OP(denominator, ((VEC_DATA_TYPE(DATA_TYPE, VEC_SIZE))SQCVT_SAT(epsilon))));\n\n    // Calculate x bar and store results\n    numerator = *((__global DATA_TYPE *)(mean.ptr + current_slice * mean.stride_x));\n    numerator = SUB_OP(data, numerator);\n    x_bar     = MUL_OP(numerator, denominator);\n\n    gamma_vec = *((__global DATA_TYPE *)(gamma.ptr + current_slice * gamma.stride_x));\n    beta_vec  = *((__global DATA_TYPE *)(beta.ptr + current_slice * beta.stride_x));\n\n    VSTORE(VEC_SIZE)\n    (ADD_OP(MUL_OP(gamma_vec, x_bar), beta_vec), 0, (__global DATA_TYPE *)out.ptr);\n}\n\n"
    }, 
    "program": "0x55a2b64000", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe74178f0"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:48.673922", 
      "end": "2018-02-09T10:36:48.684710"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b64000", 
    "call": "clBuildProgram", 
    "options": "  -DDATA_TYPE=float -DVEC_SIZE=4 -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a2b57800", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.684791", 
      "end": "2018-02-09T10:36:48.700389"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741792c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x55a2fe9590", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.700455", 
      "end": "2018-02-09T10:36:48.700464"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a2b2d000", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.700502", 
      "end": "2018-02-09T10:36:48.700520"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417cdc", 
    "size": 128
  }, 
  {
    "buffer": "0x55a2b2cc00", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.701010", 
      "end": "2018-02-09T10:36:48.701020"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417cdc", 
    "size": 128
  }, 
  {
    "buffer": "0x55a2b2c800", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.701375", 
      "end": "2018-02-09T10:36:48.701385"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417cdc", 
    "size": 128
  }, 
  {
    "buffer": "0x55a2b2c400", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.702136", 
      "end": "2018-02-09T10:36:48.702146"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417cdc", 
    "size": 128
  }, 
  {
    "buffer": "0x55a2b2c000", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.702473", 
      "end": "2018-02-09T10:36:48.702706"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 1605632
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe7417198", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.705011", 
      "end": "2018-02-09T10:36:48.705030"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe741718c", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#define TYPE VEC_DATA_TYPE(DATA_TYPE, VEC_SIZE)\n\n#if defined(FIXED_POINT_POSITION)\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n\n#define CONST_ONE (1 << FIXED_POINT_POSITION)\n#define ABS_OP(a) ABS_SAT_OP_EXPAND((a), DATA_TYPE, VEC_SIZE)\n#define ADD_OP(a, b) ADD_SAT_OP_EXPAND((a), (b), DATA_TYPE, VEC_SIZE)\n#define SUB_OP(a, b) SUB_SAT_OP_EXPAND((a), (b), DATA_TYPE, VEC_SIZE)\n#define MUL_OP(a, b) MUL_SAT_OP_EXPAND((a), (b), DATA_TYPE, VEC_SIZE, FIXED_POINT_POSITION)\n#define MLA_OP(a, b, c) MLA_SAT_OP_EXPAND((a), (b), (c), DATA_TYPE, VEC_SIZE, FIXED_POINT_POSITION)\n#define DIV_OP(a, b) DIV_SAT_OP_VEC_EXPAND((a), (b), DATA_TYPE, VEC_SIZE, FIXED_POINT_POSITION)\n#define EXP_OP(a) EXP_OP_EXPAND((a), DATA_TYPE, VEC_SIZE, FIXED_POINT_POSITION)\n#define LOG_OP(a) LOG_OP_EXPAND((a), DATA_TYPE, VEC_SIZE, FIXED_POINT_POSITION)\n#define SQRT_OP(a) DIV_OP(CONST_ONE, INVSQRT_OP_EXPAND((a), DATA_TYPE, VEC_SIZE, FIXED_POINT_POSITION))\n#define TANH_OP(a) TANH_OP_EXPAND((a), DATA_TYPE, VEC_SIZE, FIXED_POINT_POSITION)\n\n#else /* FIXED_POINT_POSITION */\n\n#define CONST_ONE 1.f\n#define ABS_OP(a) fabs((a))\n#define ADD_OP(a, b) ((a) + (b))\n#define SUB_OP(a, b) ((a) - (b))\n#define MUL_OP(a, b) ((a) * (b))\n#define MLA_OP(a, b, c) ((b) * (c) + (a))\n#define DIV_OP(a, b) ((a) / (b))\n#define EXP_OP(a) exp((a))\n#define LOG_OP(a) log((a))\n#define SQRT_OP(a) sqrt((a))\n#define TANH_OP(a) tanh((a))\n\n#endif /* FIXED_POINT_POSITION */\n\n// Logistic Activation\ninline TYPE logistic_op(TYPE x)\n{\n    return DIV_OP((TYPE)CONST_ONE, ADD_OP((TYPE)CONST_ONE, EXP_OP(-x)));\n}\n// Hyperbolic Tangent Activation\ninline TYPE tanh_op(TYPE x)\n{\n    return MUL_OP((TYPE)A_VAL, TANH_OP(MUL_OP((TYPE)B_VAL, x)));\n}\n// RELU Tangent Activation\ninline TYPE relu_op(TYPE x)\n{\n    return max(0, x);\n}\n// Bounded RELU Activation\ninline TYPE brelu_op(TYPE x)\n{\n    return min((TYPE)A_VAL, max(0, x));\n}\n// Lower Upper Bounded RELU Activation\ninline TYPE lu_brelu_op(TYPE x)\n{\n    return min(max(x, (TYPE)B_VAL), (TYPE)A_VAL);\n}\n// Leaky RELU Activation\ninline TYPE lrelu_op(TYPE x)\n{\n    return select(MUL_OP((TYPE)A_VAL, x), x, x > (TYPE)0);\n}\n// Soft RELU Activation\ninline TYPE srelu_op(TYPE x)\n{\n    return LOG_OP(ADD_OP((TYPE)CONST_ONE, EXP_OP(x)));\n}\n// Absolute Activation\ninline TYPE abs_op(TYPE x)\n{\n    return ABS_OP(x);\n}\n// Square Activation\ninline TYPE square_op(TYPE x)\n{\n    return MUL_OP(x, x);\n}\n// Square-root Activation\ninline TYPE sqrt_op(TYPE x)\n{\n    return SQRT_OP(x);\n}\n// Linear Activation\ninline TYPE linear_op(TYPE x)\n{\n    return MLA_OP((TYPE)B_VAL, (TYPE)A_VAL, x);\n}\n\n#define ACTIVATION_OP2(op, x) op##_op(x)\n#define ACTIVATION_OP(op, x) ACTIVATION_OP2(op, x)\n\n/** This performs an activation function floating point inputs.\n *\n * @note In order to perform the activation function \"in-place\", the pre-processor -DIN_PLACE must be passed at compile time\n *\n * @note Datatype should be given as a preprocessor argument using -DDATA_TYPE=type. e.g. -DDATA_TYPE=short\n * @note Vector size should be given as a preprocessor argument using -DVEC_SIZE=size. e.g. -DVEC_SIZE=16\n * @note Activation function should be given as a preprocessor argument using -DACT=name. e.g. -DACT=TANH\n * @note A, B variables required by some activation functions are set using -DA_VAL= and -DB_VAL= respectively.\n * @note In case of fixed point calculations the fixed point position is passed using -DFIXED_POINT_POSITION=position. e.g. -DFIXED_POINT_POSITION=3.\n *\n * @param[in]  input_ptr                            Pointer to the source image. Supported data types: QS8/QS16/F16/F32\n * @param[in]  input_stride_x                       Stride of the source image in X dimension (in bytes)\n * @param[in]  input_step_x                         input_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  input_stride_y                       Stride of the source image in Y dimension (in bytes)\n * @param[in]  input_step_y                         input_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  input_stride_z                       Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  input_step_z                         input_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  input_offset_first_element_in_bytes  The offset of the first element in the source image\n * @param[out] output_ptr                           Pointer to the destination image. Supported data types: same as @p input_ptr\n * @param[in]  output_stride_x                      Stride of the destination image in X dimension (in bytes)\n * @param[in]  output_step_x                        output_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  output_stride_y                      Stride of the destination image in Y dimension (in bytes)\n * @param[in]  output_step_y                        output_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  output_stride_z                      Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  output_step_z                        output_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  output_offset_first_element_in_bytes The offset of the first element in the destination image\n */\n__kernel void activation_layer(\n    TENSOR3D_DECLARATION(input)\n#ifndef IN_PLACE\n    ,\n    TENSOR3D_DECLARATION(output)\n#endif /* not IN_PLACE */\n)\n{\n    // Get pixels pointer\n    Tensor3D input = CONVERT_TO_TENSOR3D_STRUCT(input);\n#ifdef IN_PLACE\n    Tensor3D output = input;\n#else  /* IN_PLACE */\n    Tensor3D output = CONVERT_TO_TENSOR3D_STRUCT(output);\n#endif /* IN_PLACE */\n\n    // Load data\n    TYPE data = VLOAD(VEC_SIZE)(0, (__global DATA_TYPE *)input.ptr);\n\n    // Perform activation\n    data = ACTIVATION_OP(ACT, data);\n\n    // Store result\n    VSTORE(VEC_SIZE)\n    (data, 0, (__global DATA_TYPE *)output.ptr);\n}\n\n"
    }, 
    "program": "0x55a2b63f00", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe7417190"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:48.705048", 
      "end": "2018-02-09T10:36:48.717509"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63f00", 
    "call": "clBuildProgram", 
    "options": "  -DACT=brelu -DA_VAL=6 -DB_VAL=0 -DDATA_TYPE=float -DVEC_SIZE=4 -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a2b57600", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.717596", 
      "end": "2018-02-09T10:36:48.727324"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74171cc"
  }, 
  {
    "buffer": "0x55a2b2bc00", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.727432", 
      "end": "2018-02-09T10:36:48.727692"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 1605632
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe7417348", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.729411", 
      "end": "2018-02-09T10:36:48.729429"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe741733c", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#if defined(CONV_STRIDE_X)\n\n#if CONV_STRIDE_X == 1\n#define convolution1x3 convolution1x3_stride_1\n#elif CONV_STRIDE_X == 2\n#define convolution1x3 convolution1x3_stride_2\n#elif CONV_STRIDE_X == 3\n#define convolution1x3 convolution1x3_stride_3\n#else /* CONV_STRIDE_X */\n#error \"Stride not supported\"\n#endif /* CONV_STRIDE_X */\n\n/** Compute a 1D horizontal convolution of size 3 and stride 1 for floating point type.\n *\n * @param[in] left_pixel   Pointer to the left pixel.\n * @param[in] left_coeff   Weight of the left pixel\n * @param[in] middle_coeff Weight of the middle pixel\n * @param[in] right_coeff  Weight of the right pixel\n *\n * @return a float2 containing 2 convoluted values.\n */\ninline float2 convolution1x3_stride_1(__global const uchar *left_pixel,\n                                      const float           left_coeff,\n                                      const float           middle_coeff,\n                                      const float           right_coeff)\n{\n    float4 temp = vload4(0, (__global float *)left_pixel);\n\n    float2 left   = CONVERT(temp.s01, float2);\n    float2 middle = CONVERT(temp.s12, float2);\n    float2 right  = CONVERT(temp.s23, float2);\n\n    return left * (float2)left_coeff + middle * (float2)middle_coeff + right * (float2)right_coeff;\n}\n\n/** Compute a 1D horizontal convolution of size 3 and stride 2 for floating point type.\n *\n * @param[in] left_pixel   Pointer to the left pixel.\n * @param[in] left_coeff   Weight of the left pixel\n * @param[in] middle_coeff Weight of the middle pixel\n * @param[in] right_coeff  Weight of the right pixel\n *\n * @return a float2 containing 2 convoluted values.\n */\ninline float2 convolution1x3_stride_2(__global const uchar *left_pixel,\n                                      const float           left_coeff,\n                                      const float           middle_coeff,\n                                      const float           right_coeff)\n{\n    float4 temp0 = vload4(0, (__global float *)left_pixel);\n    float  temp1 = *((__global float *)(left_pixel + 4 * sizeof(float)));\n\n    float2 left   = CONVERT(temp0.s02, float2);\n    float2 middle = CONVERT(temp0.s13, float2);\n    float2 right  = CONVERT((float2)(temp0.s2, temp1), float2);\n\n    return left * (float2)left_coeff + middle * (float2)middle_coeff + right * (float2)right_coeff;\n}\n\n/** Compute a 1D horizontal convolution of size 3 and stride 3 for floating point type.\n *\n * @param[in] left_pixel   Pointer to the left pixel.\n * @param[in] left_coeff   Weight of the left pixel\n * @param[in] middle_coeff Weight of the middle pixel\n * @param[in] right_coeff  Weight of the right pixel\n *\n * @return a float2 containing 2 convoluted values.\n */\ninline float2 convolution1x3_stride_3(__global const uchar *left_pixel,\n                                      const float           left_coeff,\n                                      const float           middle_coeff,\n                                      const float           right_coeff)\n{\n    float4 temp0 = vload4(0, (__global float *)left_pixel);\n    float2 temp1 = vload2(0, (__global float *)(left_pixel + 4 * sizeof(float)));\n\n    float2 left   = CONVERT(temp0.s03, float2);\n    float2 middle = CONVERT((float2)(temp0.s1, temp1.s0), float2);\n    float2 right  = CONVERT((float2)(temp0.s2, temp1.s1), float2);\n\n    return left * (float2)left_coeff + middle * (float2)middle_coeff + right * (float2)right_coeff;\n}\n\n/** Apply a 3x3 convolution matrix to a single channel F32 input image and return the result.\n *\n * Convolution matrix layout:\n *\n * [ mat0, mat1, mat2 ]\\n\n * [ mat3, mat4, mat5 ]\\n\n * [ mat6, mat7, mat8 ]\\n\n *\n * @param[in] src  A pointer to source Image structure\n * @param[in] mat0 Coefficient from the convolution matrix\n * @param[in] mat1 Coefficient from the convolution matrix\n * @param[in] mat2 Coefficient from the convolution matrix\n * @param[in] mat3 Coefficient from the convolution matrix\n * @param[in] mat4 Coefficient from the convolution matrix\n * @param[in] mat5 Coefficient from the convolution matrix\n * @param[in] mat6 Coefficient from the convolution matrix\n * @param[in] mat0 Coefficient from the convolution matrix\n * @param[in] mat7 Coefficient from the convolution matrix\n * @param[in] mat8 Coefficient from the convolution matrix\n *\n * @return a float2 containing 2 convoluted values.\n */\ninline float2 convolution3x3(\n    Image      *src,\n    const float mat0, const float mat1, const float mat2,\n    const float mat3, const float mat4, const float mat5,\n    const float mat6, const float mat7, const float mat8)\n{\n    float2 pixels;\n\n    pixels = convolution1x3(offset(src, 0, 0), mat0, mat1, mat2);\n    pixels += convolution1x3(offset(src, 0, 1), mat3, mat4, mat5);\n    pixels += convolution1x3(offset(src, 0, 2), mat6, mat7, mat8);\n\n    return pixels;\n}\n\n/** This function computes the horizontal integral of the image.\n *\n * @param[in] src_ptr                               Pointer to the source image. Supported data types: U8\n * @param[in] src_stride_x                          Stride of the source image in X dimension (in bytes)\n * @param[in] src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] src_stride_y                          Stride of the source image in Y dimension (in bytes)\n * @param[in] src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] src_offset_first_element_in_bytes     The offset of the first element in the source image\n * @param[in] src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in] src_step_z                            src_stride_z * number of elements along Y processed per workitem(in bytes)\n * @param[in] dst_ptr                               Pointer to the destination tensor. Supported data types: F16/F32\n * @param[in] dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in] dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in] dst_step_y                            dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in] dst_step_z                            dst_stride_z * number of elements along Y processed per workitem(in bytes)\n * @param[in] dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in] weights_ptr                           Pointer to the weights tensor. Supported data types: F16/F32\n * @param[in] weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in] weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in] weights_step_y                        weights_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in] weights_step_z                        weights_stride_z * number of elements along Y processed per workitem(in bytes)\n * @param[in] weights_offset_first_element_in_bytes The offset of the first element in the biases vector\n * @param[in] biases_ptr                            (Optional) Pointer to the biases vector. Supported data types: F16/F32\n * @param[in] biases_stride_x                       (Optional) Stride of the biases vector in X dimension (in bytes)\n * @param[in] biases_step_x                         (Optional) biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] biases_offset_first_element_in_bytes  (Optional) The offset of the first element in the biases vector\n */\n\n__kernel void depthwise_convolution_3x3(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights)\n#if defined(HAS_BIAS)\n    ,\n    VECTOR_DECLARATION(biases)\n#endif //defined(HAS_BIAS)\n)\n{\n    Image    src     = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(src);\n    Image    dst     = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(dst);\n    Tensor3D weights = CONVERT_TO_TENSOR3D_STRUCT(weights);\n#if defined(HAS_BIAS)\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n#endif //defined(HAS_BIAS)\n\n    uchar3 offset          = (uchar3)(0, 1, 2) * (uchar3)weights_stride_y;\n    float3 weights_values0 = vload3(0, (__global float *)(weights.ptr + offset.s0));\n    float3 weights_values1 = vload3(0, (__global float *)(weights.ptr + offset.s1));\n    float3 weights_values2 = vload3(0, (__global float *)(weights.ptr + offset.s2));\n\n    float2 pixels = convolution3x3(&src, weights_values0.s0, weights_values0.s1, weights_values0.s2,\n                                   weights_values1.s0, weights_values1.s1, weights_values1.s2,\n                                   weights_values2.s0, weights_values2.s1, weights_values2.s2);\n#if defined(HAS_BIAS)\n    pixels += (float2)(*((__global float *)(biases.ptr + get_global_id(2) * biases_stride_x)));\n#endif //defined(HAS_BIAS)\n\n    vstore2(pixels, 0, (__global float *)dst.ptr);\n}\n\n#endif //defined(CONV_STRIDE_X)\n\n#if defined(SRC_WIDTH) && defined(DATA_TYPE)\n/** This kernel reshapes each of the tensor's low three dimensions to single rows.\n *\n * @note Datatype and source width should be given as a preprocessor argument using -DDATA_TYPE=type and -DSRC_WIDTH=width. e.g. -DSRC_WIDTH=128\n *\n * @param[in]  src_ptr                              Pointer to the source tensor. Supported data types: F16/F32\n * @param[in]  src_stride_x                         Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                           src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                         Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                           src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                         Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                           src_stride_z * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes    The offset of the first element in the source tensor\n * @param[out] dst_ptr                              Pointer to the destination tensor. Same as @p src_ptr\n * @param[in]  dst_stride_x                         Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                           dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                         Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                           dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes    The offset of the first element in the destination tensor\n * @param[in]  biases_ptr                           (Optional) Pointer to the biases vector. Supported data types: F16/F32\n * @param[in]  biases_stride_x                      (Optional) Stride of the biases vector in X dimension (in bytes)\n * @param[in]  biases_step_x                        (Optional) biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes (Optional) The offset of the first element in the biases vector\n */\n__kernel void depthwise_weights_reshape(\n    TENSOR3D_DECLARATION(src),\n    IMAGE_DECLARATION(dst)\n#ifdef HAS_BIAS\n    ,\n    VECTOR_DECLARATION(biases)\n#endif /* HAS_BIAS */\n)\n{\n    Tensor3D src = CONVERT_TO_TENSOR3D_STRUCT(src);\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n#endif /* HAS_BIAS */\n\n    __global DATA_TYPE *input_ptr = (__global DATA_TYPE *)src.ptr;\n    __global uchar *output_ptr    = dst_ptr + dst_offset_first_element_in_bytes + get_global_id(1) * SRC_WIDTH * dst_stride_x + get_global_id(2) * dst_stride_y;\n\n    for(int i = 0; i < SRC_WIDTH; ++i, ++input_ptr)\n    {\n        *((__global DATA_TYPE *)(output_ptr + i * dst_stride_x)) = *input_ptr;\n    }\n\n#if defined(HAS_BIAS)\n    if(get_global_id(1) == 0)\n    {\n        *((__global DATA_TYPE *)(output_ptr + SRC_WIDTH * get_global_size(1) * dst_stride_x)) = *((__global float *)(biases.ptr + get_global_id(2) * biases_stride_x));\n    }\n#endif // defined(HAS_BIAS)\n}\n#endif //defined(SRC_WIDTH) && defined(DATA_TYPE)\n\n#if defined(STRIDE_X) && defined(STRIDE_Y) && defined(PAD_LEFT) && defined(PAD_TOP) && defined(PAD_RIGHT) && defined(PAD_BOTTOM) && defined(KERNEL_WIDTH) && defined(KERNEL_HEIGHT) && defined(SRC_WIDTH) && defined(SRC_HEIGHT) && defined(DATA_TYPE)\n/** This kernel performs a reshaping of the input tensor to a tensor used to perform depthwise convolution using vector to matrix multiplication.\n *\n * @note The data type must be passed at compile time using -DDATA_TYPE: e.g. -DDATA_TYPE=float\n * @note The convolution information must be passed at compile time using -DSTRIDE_X, -DSTRIDE_Y, -DPAD_LEFT, -DPAD_TOP, -DPAD_RIGHT, -DPAD_BOTTOM, -DKERNEL_WIDHT, -DKERNEL_HEIGHT, -DSRC_WIDTH, -DSRC_HEIGHT\n *\n * @param[in]  src_ptr                           Pointer to the source tensor. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                      Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                        src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                      Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                        src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                      Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                        src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes The offset of the first element in the source tensor\n * @param[out] dst_ptr                           Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                      Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                        dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                      Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                        dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_stride_z                      Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                        dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes The offset of the first element in the destination tensor\n */\n\n__kernel void depthwise_im2col(TENSOR3D_DECLARATION(src), TENSOR3D_DECLARATION(dst))\n{\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    const int src_pixel_linear = get_global_id(1) * STRIDE_X;\n    const int full_length      = SRC_WIDTH + PAD_LEFT + PAD_RIGHT;\n    const int max_initial_x    = STRIDE_X * (((full_length - KERNEL_WIDTH) / STRIDE_X) + 1);\n\n    const int src_x = -PAD_LEFT + src_pixel_linear % max_initial_x;\n    const int src_y = -PAD_TOP + src_pixel_linear / max_initial_x * STRIDE_Y;\n    const int src_z = get_global_id(2);\n\n    __global uchar *input_ptr      = src_ptr + src_offset_first_element_in_bytes + src_z * src_stride_z;\n    __global DATA_TYPE *output_ptr = ((__global DATA_TYPE *)(dst.ptr));\n\n    for(int y = src_y; y < src_y + KERNEL_HEIGHT; ++y)\n    {\n        for(int x = src_x; x < src_x + KERNEL_WIDTH; ++x, ++output_ptr)\n        {\n            if(x < 0 || x >= SRC_WIDTH || y < 0 || y >= SRC_HEIGHT)\n            {\n                *output_ptr = 0;\n            }\n            else\n            {\n                *output_ptr = *((__global DATA_TYPE *)(input_ptr + x * src_stride_x + y * src_stride_y));\n            }\n        }\n    }\n#if defined(HAS_BIAS)\n    *output_ptr = (DATA_TYPE)(1);\n#endif // defined(HAS_BIAS)\n}\n\n#endif //defined(STRIDE_X) && defined(STRIDE_Y) && defined(PAD_LEFT) && defined(PAD_TOP) && defined(PAD_RIGHT) && defined(PAD_BOTTOM) && defined(KERNEL_WIDTH) && defined(KERNEL_HEIGHT) && defined(SRC_WIDTH) && defined(DATA_TYPE)\n\n#if defined(CONV_WIDTH) && defined(CONV_HEIGHT) && defined(DATA_TYPE)\n\n/** This kernel performs a reshaping of the output of the depthwise generic convolution.\n *\n * @note The data type must be passed at compile time using -DDATA_TYPE: e.g. -DDATA_TYPE=float\n * @note The convolution information must be passed at compile time using -DCONV_WIDTH, -DCONV_HEIGHT, e.g -DCONV_WIDTH=32, -DCONV_HEIGHT=42\n *\n * @param[in]  src_ptr                           Pointer to the source tensor. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                      Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                        src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes The offset of the first element in the source tensor\n * @param[out] dst_ptr                           Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                      Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                        dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                      Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                        dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_stride_z                      Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                        dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes The offset of the first element in the destination tensor\n */\n__kernel void depthwise_vector_to_tensor(\n    VECTOR_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst))\n{\n    Vector src = CONVERT_TO_VECTOR_STRUCT(src);\n\n    const int patch_size = CONV_WIDTH * CONV_HEIGHT;\n    const int id0        = get_global_id(0);\n    const int z          = id0 / patch_size;\n    const int index2D    = id0 - z * patch_size;\n\n    __global uchar *out_ptr          = dst_ptr + dst_offset_first_element_in_bytes + index2D % CONV_WIDTH * dst_stride_x + index2D / CONV_WIDTH * dst_stride_y + z * dst_stride_z;\n    *((__global DATA_TYPE *)out_ptr) = *((__global DATA_TYPE *)src.ptr);\n}\n\n#endif //defined(CONV_WIDTH) && defined(CONV_HEIGHT) && defined(DATA_TYPE)\n\n"
    }, 
    "program": "0x55a2b63e00", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe7417340"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:48.729445", 
      "end": "2018-02-09T10:36:48.742090"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63e00", 
    "call": "clBuildProgram", 
    "options": " -DCONV_STRIDE_X=1 -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a2b57400", 
    "name": "depthwise_convolution_3x3", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.742177", 
      "end": "2018-02-09T10:36:48.757863"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63e00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741737c"
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe7417338", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.760053", 
      "end": "2018-02-09T10:36:48.760073"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe741732c", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#if defined(FIXED_POINT_POSITION)\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n#endif /* FIXED_POINT_POSITION */\n\n/** Fill N pixel of the padding edge of a single channel image by replicating the closest valid pixel.\n *\n * @attention  The DATA_TYPE needs to be passed at the compile time.\n * e.g. -DDATA_TYPE=int\n *\n * @attention  The border size for top, bottom, left, right needs to be passed at the compile time.\n * e.g. --DBORDER_SIZE_TOP=0 -DBORDER_SIZE_BOTTOM=2 -DBORDER_SIZE_LEFT=0 -DBORDER_SIZE_RIGHT=2\n *\n * @param[in,out] buf_ptr                           Pointer to the source image. Supported data types: U8, U16, S16, U32, S32, F32\n * @param[in]     buf_stride_x                      Stride of the source image in X dimension (in bytes)\n * @param[in]     buf_step_x                        buf_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]     buf_stride_y                      Stride of the source image in Y dimension (in bytes)\n * @param[in]     buf_step_y                        buf_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]     buf_stride_z                      Stride between images if batching images (in bytes)\n * @param[in]     buf_step_z                        buf_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]     buf_offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in]     width                             Width of the valid region of the image\n * @param[in]     height                            Height of the valid region of the image\n * @param[in]     start_pos                         XY coordinate indicating the start point of the valid region\n */\n__kernel void fill_image_borders_replicate(\n    TENSOR3D_DECLARATION(buf),\n    uint width,\n    uint height,\n    int2 start_pos)\n{\n    Image buf = CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(buf);\n\n    // Update pointer to point to the starting point of the valid region\n    buf.ptr += start_pos.y * buf.stride_y + start_pos.x * buf.stride_x;\n\n    const int total_width = BORDER_SIZE_LEFT + width + BORDER_SIZE_RIGHT;\n    const int gid0        = get_global_id(0);\n    const int gidH        = gid0 - total_width;\n    const int gidW        = gid0 - BORDER_SIZE_LEFT;\n\n    if(gidH >= 0)\n    {\n        // Handle left border\n        DATA_TYPE left_val = *(__global DATA_TYPE *)offset(&buf, 0, gidH);\n        for(int i = -BORDER_SIZE_LEFT; i < 0; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, i, gidH) = left_val;\n        }\n        // Handle right border\n        DATA_TYPE right_val = *(__global DATA_TYPE *)offset(&buf, width - 1, gidH);\n        for(int i = 0; i < BORDER_SIZE_RIGHT; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, width + i, gidH) = right_val;\n        }\n    }\n    else\n    {\n        // Get value for corners\n        int val_idx = gidW;\n        if(gidW < 0 || gidW > (width - 1))\n        {\n            val_idx = gidW < 0 ? 0 : width - 1;\n        }\n\n        // Handle top border\n        DATA_TYPE top_val = *(__global DATA_TYPE *)offset(&buf, val_idx, 0);\n        for(int i = -BORDER_SIZE_TOP; i < 0; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, gidW, i) = top_val;\n        }\n        // Handle bottom border\n        DATA_TYPE bottom_val = *(__global DATA_TYPE *)offset(&buf, val_idx, height - 1);\n        for(int i = 0; i < BORDER_SIZE_BOTTOM; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, gidW, height + i) = bottom_val;\n        }\n    }\n}\n\n/** Fill N pixels of the padding edge of a single channel image with a constant value.\n *\n * @attention  The DATA_TYPE needs to be passed at the compile time.\n * e.g. -DDATA_TYPE=int\n *\n * @attention  The border size for top, bottom, left, right needs to be passed at the compile time.\n * e.g. --DBORDER_SIZE_TOP=0 -DBORDER_SIZE_BOTTOM=2 -DBORDER_SIZE_LEFT=0 -DBORDER_SIZE_RIGHT=2\n *\n * @param[out] buf_ptr                           Pointer to the source image. Supported data types: U8, U16, S16, U32, S32, F32\n * @param[in]  buf_stride_x                      Stride of the source image in X dimension (in bytes)\n * @param[in]  buf_step_x                        buf_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  buf_stride_y                      Stride of the source image in Y dimension (in bytes)\n * @param[in]  buf_step_y                        buf_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  buf_stride_z                      Stride between images if batching images (in bytes)\n * @param[in]  buf_step_z                        buf_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  buf_offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in]  width                             Width of the valid region of the image\n * @param[in]  height                            Height of the valid region of the image\n * @param[in]  start_pos                         XY coordinate indicating the start point of the valid region\n * @param[in]  constant_value                    Constant value to use to fill the edges\n */\n__kernel void fill_image_borders_constant(\n    TENSOR3D_DECLARATION(buf),\n    uint      width,\n    uint      height,\n    int2      start_pos,\n    DATA_TYPE constant_value)\n{\n    Image buf = CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(buf);\n\n    // Update pointer to point to the starting point of the valid region\n    buf.ptr += start_pos.y * buf.stride_y + start_pos.x * buf.stride_x;\n\n    const int total_width = BORDER_SIZE_LEFT + width + BORDER_SIZE_RIGHT;\n    const int gid0        = get_global_id(0);\n    const int gidH        = gid0 - total_width;\n    const int gidW        = gid0 - BORDER_SIZE_LEFT;\n\n    if(gidH >= 0)\n    {\n        // Handle left border\n        for(int i = -BORDER_SIZE_LEFT; i < 0; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, i, gidH) = constant_value;\n        }\n        // Handle right border\n        for(int i = 0; i < BORDER_SIZE_RIGHT; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, width + i, gidH) = constant_value;\n        }\n    }\n    else\n    {\n        // Handle top border\n        for(int i = -BORDER_SIZE_TOP; i < 0; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, gidW, i) = constant_value;\n        }\n        // Handle bottom border\n        for(int i = 0; i < BORDER_SIZE_BOTTOM; ++i)\n        {\n            *(__global DATA_TYPE *)offset(&buf, gidW, height + i) = constant_value;\n        }\n    }\n}\n\n"
    }, 
    "program": "0x55a2b63d00", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe7417330"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:48.760089", 
      "end": "2018-02-09T10:36:48.777104"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63d00", 
    "call": "clBuildProgram", 
    "options": " -DBORDER_SIZE_BOTTOM=1 -DBORDER_SIZE_LEFT=1 -DBORDER_SIZE_RIGHT=1 -DBORDER_SIZE_TOP=1 -DDATA_TYPE=float -DSELECT_TYPE=int -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a2b57200", 
    "name": "fill_image_borders_constant", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.777190", 
      "end": "2018-02-09T10:36:48.788642"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63d00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741736c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57200", 
    "arg_value_ptr": "0x7fe74175d4", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.788714", 
      "end": "2018-02-09T10:36:48.788723"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57200", 
    "arg_value_ptr": "0x7fe74175d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.788735", 
      "end": "2018-02-09T10:36:48.788740"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57200", 
    "arg_value_ptr": "0x7fe74175e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.788752", 
      "end": "2018-02-09T10:36:48.788758"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000000000000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57200", 
    "arg_value_ptr": "0x7fe74175e4", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.788769", 
      "end": "2018-02-09T10:36:48.788774"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 11
  }, 
  {
    "buffer": "0x55a2b2b800", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.788800", 
      "end": "2018-02-09T10:36:48.788818"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741790c", 
    "size": 1152
  }, 
  {
    "kernel": "0x55a2b57000", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.789304", 
      "end": "2018-02-09T10:36:48.789535"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x55a3030e10", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.789556", 
      "end": "2018-02-09T10:36:48.789561"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a2b2b400", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.789583", 
      "end": "2018-02-09T10:36:48.789594"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 128
  }, 
  {
    "buffer": "0x55a2b2b000", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.789936", 
      "end": "2018-02-09T10:36:48.789949"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 128
  }, 
  {
    "buffer": "0x55a2b2ac00", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.790270", 
      "end": "2018-02-09T10:36:48.790280"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 128
  }, 
  {
    "buffer": "0x55a2b2a800", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.790607", 
      "end": "2018-02-09T10:36:48.790618"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 128
  }, 
  {
    "buffer": "0x55a2b2a400", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.790945", 
      "end": "2018-02-09T10:36:48.791177"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 1605632
  }, 
  {
    "kernel": "0x55a2b56e00", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.791248", 
      "end": "2018-02-09T10:36:48.791395"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e0c"
  }, 
  {
    "buffer": "0x55a2b2a000", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.791425", 
      "end": "2018-02-09T10:36:48.791609"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 1605632
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe74171b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.795591", 
      "end": "2018-02-09T10:36:48.795617"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe74171ac", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#if defined(FIXED_POINT_POSITION)\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n\n#define ADD_OP(a, b) ADD_SAT_OP_EXPAND((a), (b), DATA_TYPE_PROMOTED, 8)\n#define MUL_OP(a, b) MUL_SAT_OP_EXPAND(CONVERT((a), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), CONVERT((b), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), DATA_TYPE_PROMOTED, 8, FIXED_POINT_POSITION)\n\n// There is no need to have a larger intermediate type for qs32 because all the arguments are already promoted\nMULQ_SAT_IMPL(qs32x8, qs32x8)\n\n#else /* FIXED_POINT_POSITION */\n#undef CONVERT_SAT\n\n#define ADD_OP(a, b) ((a) + (b))\n#define MUL_OP(a, b) ((a) * (b))\n#define CONVERT_SAT(a, b) ((a))\n\n#endif /* FIXED_POINT_POSITION */\n\n#if defined(DATA_TYPE) && defined(DATA_SIZE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if STRIDE_X == 3\n#define INPUT_PIXEL_STR(data_size) extract_input_stride3_##data_size\n#define INPUT_PIXEL(data_size) INPUT_PIXEL_STR(data_size)\n#elif STRIDE_X == 2\n#define INPUT_PIXEL(data_size) extract_input_stride2\n#elif STRIDE_X == 1\n#define INPUT_PIXEL(data_size) extract_input_stride1\n#else /* STRIDE_X not equals 1, 2 or 3 */\n#error \"Only support strides 1, 2 and 3\"\n#endif /* STRIDE_X == 3 */\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 1.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride1(__global const DATA_TYPE *input_pixel)\n{\n    return vload8(0, input_pixel);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 2.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride2(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp = vload16(0, input_pixel);\n    return temp.s02468ace;\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 32-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_32(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp1 = vload4(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp2 = vload4(0, input_pixel + 6);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp3 = vload4(0, input_pixel + 12);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp4 = vload4(0, input_pixel + 18);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s03, temp2.s03, temp3.s03, temp4.s03);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 16-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_16(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp1 = vload8(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp2 = vload8(0, input_pixel + 8);\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp3 = vload8(0, input_pixel + 16);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s036, temp2.s147, temp3.s25);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 8-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_8(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp1 = vload16(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp2 = vload16(0, input_pixel + 12);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s0369, temp2.s0369);\n}\n\n/** This kernel performs a direct convolution to convolve the low three dimensions.\n *\n * @note The data type must be passed at compile time using -DDATA_TYPE: e.g. -DDATA_TYPE=float\n * @note The data size must be passed at compile time using -DDATA_SIZE e.g. -DDATA_SIZE=32\n * @note The convolution stride x must be passed at compile time using -DSTRIDE_X e.g. -DSTRIDE_X=1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases will be added to the convolution -DHAS_BIAS has to be passed to append the final matrix with 1 in each row.\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F16/F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    Image    src     = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D weights = CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(weights);\n    Tensor3D dst     = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n#endif /* defined(HAS_BIAS) */\n\n    VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)\n    pixels = 0;\n\n    const uint z_index = get_global_id(2);\n\n    weights.ptr += z_index * weights_stride_w;\n\n    for(volatile int d = 0; d < WEIGHTS_DEPTH; ++d)\n    {\n        DATA_TYPE weight = *(__global DATA_TYPE *)weights.ptr;\n        VEC_DATA_TYPE(DATA_TYPE, 8)\n        input_pixel = INPUT_PIXEL(DATA_SIZE)((__global DATA_TYPE *)src.ptr);\n        pixels      = ADD_OP(pixels, MUL_OP((VEC_DATA_TYPE(DATA_TYPE, 8))weight, input_pixel));\n        src.ptr += src_stride_z;\n        weights.ptr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    pixels = ADD_OP(pixels, (VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)) * ((__global DATA_TYPE *)(vector_offset(&biases, z_index))));\n#endif /* defined(HAS_BIAS) */\n\n    vstore8(CONVERT_SAT(pixels, VEC_DATA_TYPE(DATA_TYPE, 8)), 0, (__global DATA_TYPE *)dst.ptr);\n}\n#endif // defined(DATA_TYPE) && defined(DATA_SIZE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n//    printf(\"get_local_size = %u %d %d- %d\\n\", get_local_size(0), get_local_size(1), get_local_size(2));\n//get_enqueued_local_size\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr); \n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n\n        CONVOLUTION1x1_BIFROST(acc0, src0, weight);\n        CONVOLUTION1x1_BIFROST(acc1, src1, weight);\n        CONVOLUTION1x1_BIFROST(acc2, src2, weight);\n        CONVOLUTION1x1_BIFROST(acc3, src3, weight);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_2(acc, src, weight_value) \\\n    ({                                                   \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);      \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);      \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);      \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);      \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_2(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n#if NUM_ELEM_ITERATION_Y == 1\n    float4 acc0 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 2 \n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 4\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 8\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n    float4 acc4 = 0.0f;\n    float4 acc5 = 0.0f;\n    float4 acc6 = 0.0f;\n    float4 acc7 = 0.0f;\n#endif /*NUM_ELEM_ITERATION_Y */\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr);\n\n        // Load values from row0 of input tensor\n#if NUM_ELEM_ITERATION_Y == 1\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 2\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 4 \n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 8 \n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        float4 src4 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        float4 src5 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        float4 src6 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        float4 src7 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n#endif /* NUM_ELEM_ITERATION_Y */\n\n#if NUM_ELEM_ITERATION_Y == 1\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n#elif NUM_ELEM_ITERATION_Y == 2\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n#elif NUM_ELEM_ITERATION_Y == 4\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n         CONVOLUTION1x1_BIFROST_2(acc2, src2, weight);\n         CONVOLUTION1x1_BIFROST_2(acc3, src3, weight);\n#elif NUM_ELEM_ITERATION_Y == 8\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n         CONVOLUTION1x1_BIFROST_2(acc2, src2, weight);\n         CONVOLUTION1x1_BIFROST_2(acc3, src3, weight);\n         CONVOLUTION1x1_BIFROST_2(acc4, src4, weight);\n         CONVOLUTION1x1_BIFROST_2(acc5, src5, weight);\n         CONVOLUTION1x1_BIFROST_2(acc6, src6, weight);\n         CONVOLUTION1x1_BIFROST_2(acc7, src7, weight);\n#endif /* NUM_ELEM_ITERATION_Y  */\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n#if NUM_ELEM_ITERATION_Y >= 1\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n#endif\n#if NUM_ELEM_ITERATION_Y >= 2\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n#endif\n\n#if NUM_ELEM_ITERATION_Y >= 4\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#endif\n\n#if NUM_ELEM_ITERATION_Y >= 8\n    acc4.s0 += bias;\n    acc4.s1 += bias;\n    acc4.s2 += bias;\n    acc4.s3 += bias;\n    acc5.s0 += bias;\n    acc5.s1 += bias;\n    acc5.s2 += bias;\n    acc5.s3 += bias;\n    acc6.s0 += bias;\n    acc6.s1 += bias;\n    acc6.s2 += bias;\n    acc6.s3 += bias;\n    acc7.s0 += bias;\n    acc7.s1 += bias;\n    acc7.s2 += bias;\n    acc7.s3 += bias;\n#endif /* NUM_ELEM_ITERATION_Y  > 8 */\n#endif /* defined(HAS_BIAS) */\n    \n#if NUM_ELEM_ITERATION_Y == 1\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 2\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 4\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 8\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n    vstore4(acc4, 0, (__global float *)(dst.ptr + 4 * dst_stride_y));\n    vstore4(acc5, 0, (__global float *)(dst.ptr + 5 * dst_stride_y));\n    vstore4(acc6, 0, (__global float *)(dst.ptr + 6 * dst_stride_y));\n    vstore4(acc7, 0, (__global float *)(dst.ptr + 7 * dst_stride_y));\n#endif\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_4(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_4(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n#if NUM_ELEM_ITERATION_Y == 8\n    float4 acc4 = 0.0f;\n    float4 acc5 = 0.0f;\n    float4 acc6 = 0.0f;\n    float4 acc7 = 0.0f;\n#endif\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr);\n#ifdef  OVERLAP\n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc0, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc1, src1, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc2, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc3, src1, weight);\n#if NUM_ELEM_ITERATION_Y == 8\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc4, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc5, src1, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc6, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc7, src1, weight);\n#endif\n\n\n#else\n   // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc0, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc1, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc2, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc3, src0, weight);\n#if NUM_ELEM_ITERATION_Y == 8\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc4, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc5, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc6, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc7, src0, weight);\n\n#endif /*NUM_ELEM_ITERATION_Y*/\n#endif /*INTERLEAVE8 */\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#if NUM_ELEM_ITERATION_Y == 8\n    acc4.s0 += bias;\n    acc4.s1 += bias;\n    acc4.s2 += bias;\n    acc4.s3 += bias;\n    acc5.s0 += bias;\n    acc5.s1 += bias;\n    acc5.s2 += bias;\n    acc5.s3 += bias;\n    acc6.s0 += bias;\n    acc6.s1 += bias;\n    acc6.s2 += bias;\n    acc6.s3 += bias;\n    acc7.s0 += bias;\n    acc7.s1 += bias;\n    acc7.s2 += bias;\n    acc7.s3 += bias;\n#endif /*NUM_ELEM_ITERATION_Y */\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n#if NUM_ELEM_ITERATION_Y == 8\n    vstore4(acc4, 0, (__global float *)(dst.ptr + 4 * dst_stride_y));\n    vstore4(acc5, 0, (__global float *)(dst.ptr + 5 * dst_stride_y));\n    vstore4(acc6, 0, (__global float *)(dst.ptr + 6 * dst_stride_y));\n    vstore4(acc7, 0, (__global float *)(dst.ptr + 7 * dst_stride_y));\n#endif /*NUM_ELEM_ITERATION_Y*/\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_1(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_1(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float acc0 = 0.0f;\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr); \n        // Load values from row0 of input tensor\n        float src0 = *((__global float *)(src_addr));\n        acc0 = mad(src0, weight, acc0);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n    acc0    += bias;\n#endif /* defined(HAS_BIAS) */\n     *((__global float *)dst.ptr) = acc0;\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n#define CONVOLUTION1x1_BIFROST_7(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_7(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n//    float4 acc2 = 0.0f;\n//    float4 acc3 = 0.0f;\n\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n//x=4 (see float4 acc), y=2 see how many src, w=4 see float4 w\n    for(ushort d = 0; d < (ushort)(WEIGHTS_DEPTH/4); ++d)\n    {\n        // Load the weights\n        float4 weight = vload4(0,(__global float *)(weights_addr)); \n\n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s0); \n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s0); \n\n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s1); \n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s1);\n    \n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s2);\n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s2);              \n\n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s3);\n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s3);\n\n//        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s0);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s1);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s2);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s3);\n      \n        src_addr += src_stride_z;\n        weights_addr +=  (4*weights_stride_z);\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n/*    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n*/\n\n\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n//    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n//    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n\n"
    }, 
    "program": "0x55a2b63c00", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe74171b0"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:48.795636", 
      "end": "2018-02-09T10:36:48.832871"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63c00", 
    "call": "clBuildProgram", 
    "options": " -DNUM_ELEM_ITERATION_Y=4 -DWEIGHTS_DEPTH=32 -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a2b56c00", 
    "name": "direct_convolution1x1_f32_bifrost_2", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.832964", 
      "end": "2018-02-09T10:36:48.865605"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63c00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74171ec"
  }, 
  {
    "buffer": "0x55a2b29c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.865725", 
      "end": "2018-02-09T10:36:48.865826"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741792c", 
    "size": 8192
  }, 
  {
    "buffer": "0x55a2b29800", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.867308", 
      "end": "2018-02-09T10:36:48.867493"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 1605632
  }, 
  {
    "kernel": "0x55a2b56a00", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.867573", 
      "end": "2018-02-09T10:36:48.867769"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x55a32b2d50", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.867789", 
      "end": "2018-02-09T10:36:48.867797"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a2b29400", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.867813", 
      "end": "2018-02-09T10:36:48.867822"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 256
  }, 
  {
    "buffer": "0x55a2b29000", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.868974", 
      "end": "2018-02-09T10:36:48.868983"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 256
  }, 
  {
    "buffer": "0x55a2b28c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.870141", 
      "end": "2018-02-09T10:36:48.870150"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 256
  }, 
  {
    "buffer": "0x55a2b28800", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.871510", 
      "end": "2018-02-09T10:36:48.871520"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 256
  }, 
  {
    "buffer": "0x55a2b28400", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.872874", 
      "end": "2018-02-09T10:36:48.873229"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 3211264
  }, 
  {
    "kernel": "0x55a2b56800", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.873297", 
      "end": "2018-02-09T10:36:48.873396"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e2c"
  }, 
  {
    "buffer": "0x55a2b28000", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.873423", 
      "end": "2018-02-09T10:36:48.873778"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b9c", 
    "size": 3211264
  }, 
  {
    "buffer": "0x55a2b27c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.873805", 
      "end": "2018-02-09T10:36:48.874000"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 1663488
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe7417348", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.875546", 
      "end": "2018-02-09T10:36:48.875561"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe741733c", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#if defined(CONV_STRIDE_X)\n\n#if CONV_STRIDE_X == 1\n#define convolution1x3 convolution1x3_stride_1\n#elif CONV_STRIDE_X == 2\n#define convolution1x3 convolution1x3_stride_2\n#elif CONV_STRIDE_X == 3\n#define convolution1x3 convolution1x3_stride_3\n#else /* CONV_STRIDE_X */\n#error \"Stride not supported\"\n#endif /* CONV_STRIDE_X */\n\n/** Compute a 1D horizontal convolution of size 3 and stride 1 for floating point type.\n *\n * @param[in] left_pixel   Pointer to the left pixel.\n * @param[in] left_coeff   Weight of the left pixel\n * @param[in] middle_coeff Weight of the middle pixel\n * @param[in] right_coeff  Weight of the right pixel\n *\n * @return a float2 containing 2 convoluted values.\n */\ninline float2 convolution1x3_stride_1(__global const uchar *left_pixel,\n                                      const float           left_coeff,\n                                      const float           middle_coeff,\n                                      const float           right_coeff)\n{\n    float4 temp = vload4(0, (__global float *)left_pixel);\n\n    float2 left   = CONVERT(temp.s01, float2);\n    float2 middle = CONVERT(temp.s12, float2);\n    float2 right  = CONVERT(temp.s23, float2);\n\n    return left * (float2)left_coeff + middle * (float2)middle_coeff + right * (float2)right_coeff;\n}\n\n/** Compute a 1D horizontal convolution of size 3 and stride 2 for floating point type.\n *\n * @param[in] left_pixel   Pointer to the left pixel.\n * @param[in] left_coeff   Weight of the left pixel\n * @param[in] middle_coeff Weight of the middle pixel\n * @param[in] right_coeff  Weight of the right pixel\n *\n * @return a float2 containing 2 convoluted values.\n */\ninline float2 convolution1x3_stride_2(__global const uchar *left_pixel,\n                                      const float           left_coeff,\n                                      const float           middle_coeff,\n                                      const float           right_coeff)\n{\n    float4 temp0 = vload4(0, (__global float *)left_pixel);\n    float  temp1 = *((__global float *)(left_pixel + 4 * sizeof(float)));\n\n    float2 left   = CONVERT(temp0.s02, float2);\n    float2 middle = CONVERT(temp0.s13, float2);\n    float2 right  = CONVERT((float2)(temp0.s2, temp1), float2);\n\n    return left * (float2)left_coeff + middle * (float2)middle_coeff + right * (float2)right_coeff;\n}\n\n/** Compute a 1D horizontal convolution of size 3 and stride 3 for floating point type.\n *\n * @param[in] left_pixel   Pointer to the left pixel.\n * @param[in] left_coeff   Weight of the left pixel\n * @param[in] middle_coeff Weight of the middle pixel\n * @param[in] right_coeff  Weight of the right pixel\n *\n * @return a float2 containing 2 convoluted values.\n */\ninline float2 convolution1x3_stride_3(__global const uchar *left_pixel,\n                                      const float           left_coeff,\n                                      const float           middle_coeff,\n                                      const float           right_coeff)\n{\n    float4 temp0 = vload4(0, (__global float *)left_pixel);\n    float2 temp1 = vload2(0, (__global float *)(left_pixel + 4 * sizeof(float)));\n\n    float2 left   = CONVERT(temp0.s03, float2);\n    float2 middle = CONVERT((float2)(temp0.s1, temp1.s0), float2);\n    float2 right  = CONVERT((float2)(temp0.s2, temp1.s1), float2);\n\n    return left * (float2)left_coeff + middle * (float2)middle_coeff + right * (float2)right_coeff;\n}\n\n/** Apply a 3x3 convolution matrix to a single channel F32 input image and return the result.\n *\n * Convolution matrix layout:\n *\n * [ mat0, mat1, mat2 ]\\n\n * [ mat3, mat4, mat5 ]\\n\n * [ mat6, mat7, mat8 ]\\n\n *\n * @param[in] src  A pointer to source Image structure\n * @param[in] mat0 Coefficient from the convolution matrix\n * @param[in] mat1 Coefficient from the convolution matrix\n * @param[in] mat2 Coefficient from the convolution matrix\n * @param[in] mat3 Coefficient from the convolution matrix\n * @param[in] mat4 Coefficient from the convolution matrix\n * @param[in] mat5 Coefficient from the convolution matrix\n * @param[in] mat6 Coefficient from the convolution matrix\n * @param[in] mat0 Coefficient from the convolution matrix\n * @param[in] mat7 Coefficient from the convolution matrix\n * @param[in] mat8 Coefficient from the convolution matrix\n *\n * @return a float2 containing 2 convoluted values.\n */\ninline float2 convolution3x3(\n    Image      *src,\n    const float mat0, const float mat1, const float mat2,\n    const float mat3, const float mat4, const float mat5,\n    const float mat6, const float mat7, const float mat8)\n{\n    float2 pixels;\n\n    pixels = convolution1x3(offset(src, 0, 0), mat0, mat1, mat2);\n    pixels += convolution1x3(offset(src, 0, 1), mat3, mat4, mat5);\n    pixels += convolution1x3(offset(src, 0, 2), mat6, mat7, mat8);\n\n    return pixels;\n}\n\n/** This function computes the horizontal integral of the image.\n *\n * @param[in] src_ptr                               Pointer to the source image. Supported data types: U8\n * @param[in] src_stride_x                          Stride of the source image in X dimension (in bytes)\n * @param[in] src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] src_stride_y                          Stride of the source image in Y dimension (in bytes)\n * @param[in] src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] src_offset_first_element_in_bytes     The offset of the first element in the source image\n * @param[in] src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in] src_step_z                            src_stride_z * number of elements along Y processed per workitem(in bytes)\n * @param[in] dst_ptr                               Pointer to the destination tensor. Supported data types: F16/F32\n * @param[in] dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in] dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in] dst_step_y                            dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in] dst_step_z                            dst_stride_z * number of elements along Y processed per workitem(in bytes)\n * @param[in] dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in] weights_ptr                           Pointer to the weights tensor. Supported data types: F16/F32\n * @param[in] weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in] weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in] weights_step_y                        weights_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in] weights_step_z                        weights_stride_z * number of elements along Y processed per workitem(in bytes)\n * @param[in] weights_offset_first_element_in_bytes The offset of the first element in the biases vector\n * @param[in] biases_ptr                            (Optional) Pointer to the biases vector. Supported data types: F16/F32\n * @param[in] biases_stride_x                       (Optional) Stride of the biases vector in X dimension (in bytes)\n * @param[in] biases_step_x                         (Optional) biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] biases_offset_first_element_in_bytes  (Optional) The offset of the first element in the biases vector\n */\n\n__kernel void depthwise_convolution_3x3(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights)\n#if defined(HAS_BIAS)\n    ,\n    VECTOR_DECLARATION(biases)\n#endif //defined(HAS_BIAS)\n)\n{\n    Image    src     = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(src);\n    Image    dst     = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(dst);\n    Tensor3D weights = CONVERT_TO_TENSOR3D_STRUCT(weights);\n#if defined(HAS_BIAS)\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n#endif //defined(HAS_BIAS)\n\n    uchar3 offset          = (uchar3)(0, 1, 2) * (uchar3)weights_stride_y;\n    float3 weights_values0 = vload3(0, (__global float *)(weights.ptr + offset.s0));\n    float3 weights_values1 = vload3(0, (__global float *)(weights.ptr + offset.s1));\n    float3 weights_values2 = vload3(0, (__global float *)(weights.ptr + offset.s2));\n\n    float2 pixels = convolution3x3(&src, weights_values0.s0, weights_values0.s1, weights_values0.s2,\n                                   weights_values1.s0, weights_values1.s1, weights_values1.s2,\n                                   weights_values2.s0, weights_values2.s1, weights_values2.s2);\n#if defined(HAS_BIAS)\n    pixels += (float2)(*((__global float *)(biases.ptr + get_global_id(2) * biases_stride_x)));\n#endif //defined(HAS_BIAS)\n\n    vstore2(pixels, 0, (__global float *)dst.ptr);\n}\n\n#endif //defined(CONV_STRIDE_X)\n\n#if defined(SRC_WIDTH) && defined(DATA_TYPE)\n/** This kernel reshapes each of the tensor's low three dimensions to single rows.\n *\n * @note Datatype and source width should be given as a preprocessor argument using -DDATA_TYPE=type and -DSRC_WIDTH=width. e.g. -DSRC_WIDTH=128\n *\n * @param[in]  src_ptr                              Pointer to the source tensor. Supported data types: F16/F32\n * @param[in]  src_stride_x                         Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                           src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                         Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                           src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                         Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                           src_stride_z * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes    The offset of the first element in the source tensor\n * @param[out] dst_ptr                              Pointer to the destination tensor. Same as @p src_ptr\n * @param[in]  dst_stride_x                         Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                           dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                         Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                           dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes    The offset of the first element in the destination tensor\n * @param[in]  biases_ptr                           (Optional) Pointer to the biases vector. Supported data types: F16/F32\n * @param[in]  biases_stride_x                      (Optional) Stride of the biases vector in X dimension (in bytes)\n * @param[in]  biases_step_x                        (Optional) biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes (Optional) The offset of the first element in the biases vector\n */\n__kernel void depthwise_weights_reshape(\n    TENSOR3D_DECLARATION(src),\n    IMAGE_DECLARATION(dst)\n#ifdef HAS_BIAS\n    ,\n    VECTOR_DECLARATION(biases)\n#endif /* HAS_BIAS */\n)\n{\n    Tensor3D src = CONVERT_TO_TENSOR3D_STRUCT(src);\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n#endif /* HAS_BIAS */\n\n    __global DATA_TYPE *input_ptr = (__global DATA_TYPE *)src.ptr;\n    __global uchar *output_ptr    = dst_ptr + dst_offset_first_element_in_bytes + get_global_id(1) * SRC_WIDTH * dst_stride_x + get_global_id(2) * dst_stride_y;\n\n    for(int i = 0; i < SRC_WIDTH; ++i, ++input_ptr)\n    {\n        *((__global DATA_TYPE *)(output_ptr + i * dst_stride_x)) = *input_ptr;\n    }\n\n#if defined(HAS_BIAS)\n    if(get_global_id(1) == 0)\n    {\n        *((__global DATA_TYPE *)(output_ptr + SRC_WIDTH * get_global_size(1) * dst_stride_x)) = *((__global float *)(biases.ptr + get_global_id(2) * biases_stride_x));\n    }\n#endif // defined(HAS_BIAS)\n}\n#endif //defined(SRC_WIDTH) && defined(DATA_TYPE)\n\n#if defined(STRIDE_X) && defined(STRIDE_Y) && defined(PAD_LEFT) && defined(PAD_TOP) && defined(PAD_RIGHT) && defined(PAD_BOTTOM) && defined(KERNEL_WIDTH) && defined(KERNEL_HEIGHT) && defined(SRC_WIDTH) && defined(SRC_HEIGHT) && defined(DATA_TYPE)\n/** This kernel performs a reshaping of the input tensor to a tensor used to perform depthwise convolution using vector to matrix multiplication.\n *\n * @note The data type must be passed at compile time using -DDATA_TYPE: e.g. -DDATA_TYPE=float\n * @note The convolution information must be passed at compile time using -DSTRIDE_X, -DSTRIDE_Y, -DPAD_LEFT, -DPAD_TOP, -DPAD_RIGHT, -DPAD_BOTTOM, -DKERNEL_WIDHT, -DKERNEL_HEIGHT, -DSRC_WIDTH, -DSRC_HEIGHT\n *\n * @param[in]  src_ptr                           Pointer to the source tensor. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                      Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                        src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                      Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                        src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                      Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                        src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes The offset of the first element in the source tensor\n * @param[out] dst_ptr                           Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                      Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                        dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                      Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                        dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_stride_z                      Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                        dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes The offset of the first element in the destination tensor\n */\n\n__kernel void depthwise_im2col(TENSOR3D_DECLARATION(src), TENSOR3D_DECLARATION(dst))\n{\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    const int src_pixel_linear = get_global_id(1) * STRIDE_X;\n    const int full_length      = SRC_WIDTH + PAD_LEFT + PAD_RIGHT;\n    const int max_initial_x    = STRIDE_X * (((full_length - KERNEL_WIDTH) / STRIDE_X) + 1);\n\n    const int src_x = -PAD_LEFT + src_pixel_linear % max_initial_x;\n    const int src_y = -PAD_TOP + src_pixel_linear / max_initial_x * STRIDE_Y;\n    const int src_z = get_global_id(2);\n\n    __global uchar *input_ptr      = src_ptr + src_offset_first_element_in_bytes + src_z * src_stride_z;\n    __global DATA_TYPE *output_ptr = ((__global DATA_TYPE *)(dst.ptr));\n\n    for(int y = src_y; y < src_y + KERNEL_HEIGHT; ++y)\n    {\n        for(int x = src_x; x < src_x + KERNEL_WIDTH; ++x, ++output_ptr)\n        {\n            if(x < 0 || x >= SRC_WIDTH || y < 0 || y >= SRC_HEIGHT)\n            {\n                *output_ptr = 0;\n            }\n            else\n            {\n                *output_ptr = *((__global DATA_TYPE *)(input_ptr + x * src_stride_x + y * src_stride_y));\n            }\n        }\n    }\n#if defined(HAS_BIAS)\n    *output_ptr = (DATA_TYPE)(1);\n#endif // defined(HAS_BIAS)\n}\n\n#endif //defined(STRIDE_X) && defined(STRIDE_Y) && defined(PAD_LEFT) && defined(PAD_TOP) && defined(PAD_RIGHT) && defined(PAD_BOTTOM) && defined(KERNEL_WIDTH) && defined(KERNEL_HEIGHT) && defined(SRC_WIDTH) && defined(DATA_TYPE)\n\n#if defined(CONV_WIDTH) && defined(CONV_HEIGHT) && defined(DATA_TYPE)\n\n/** This kernel performs a reshaping of the output of the depthwise generic convolution.\n *\n * @note The data type must be passed at compile time using -DDATA_TYPE: e.g. -DDATA_TYPE=float\n * @note The convolution information must be passed at compile time using -DCONV_WIDTH, -DCONV_HEIGHT, e.g -DCONV_WIDTH=32, -DCONV_HEIGHT=42\n *\n * @param[in]  src_ptr                           Pointer to the source tensor. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                      Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                        src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes The offset of the first element in the source tensor\n * @param[out] dst_ptr                           Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                      Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                        dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                      Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                        dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_stride_z                      Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                        dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes The offset of the first element in the destination tensor\n */\n__kernel void depthwise_vector_to_tensor(\n    VECTOR_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst))\n{\n    Vector src = CONVERT_TO_VECTOR_STRUCT(src);\n\n    const int patch_size = CONV_WIDTH * CONV_HEIGHT;\n    const int id0        = get_global_id(0);\n    const int z          = id0 / patch_size;\n    const int index2D    = id0 - z * patch_size;\n\n    __global uchar *out_ptr          = dst_ptr + dst_offset_first_element_in_bytes + index2D % CONV_WIDTH * dst_stride_x + index2D / CONV_WIDTH * dst_stride_y + z * dst_stride_z;\n    *((__global DATA_TYPE *)out_ptr) = *((__global DATA_TYPE *)src.ptr);\n}\n\n#endif //defined(CONV_WIDTH) && defined(CONV_HEIGHT) && defined(DATA_TYPE)\n\n"
    }, 
    "program": "0x55a2b63b00", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe7417340"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:48.875579", 
      "end": "2018-02-09T10:36:48.888427"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63b00", 
    "call": "clBuildProgram", 
    "options": " -DCONV_STRIDE_X=2 -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a2b56600", 
    "name": "depthwise_convolution_3x3", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.888521", 
      "end": "2018-02-09T10:36:48.905404"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63b00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741737c"
  }, 
  {
    "kernel": "0x55a2b56400", 
    "name": "fill_image_borders_constant", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.905545", 
      "end": "2018-02-09T10:36:48.905627"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64100", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741736c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56400", 
    "arg_value_ptr": "0x7fe74175d4", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.905647", 
      "end": "2018-02-09T10:36:48.905654"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56400", 
    "arg_value_ptr": "0x7fe74175d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.905666", 
      "end": "2018-02-09T10:36:48.905672"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56400", 
    "arg_value_ptr": "0x7fe74175e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.905684", 
      "end": "2018-02-09T10:36:48.905689"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000000000000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56400", 
    "arg_value_ptr": "0x7fe74175e4", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.905701", 
      "end": "2018-02-09T10:36:48.905705"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 11
  }, 
  {
    "buffer": "0x55a2b27800", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.905729", 
      "end": "2018-02-09T10:36:48.905746"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741790c", 
    "size": 2304
  }, 
  {
    "kernel": "0x55a2b56200", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.906473", 
      "end": "2018-02-09T10:36:48.906668"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x55a3211630", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.906688", 
      "end": "2018-02-09T10:36:48.906696"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a2b27400", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.906713", 
      "end": "2018-02-09T10:36:48.906723"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 256
  }, 
  {
    "buffer": "0x55a2b27000", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.907265", 
      "end": "2018-02-09T10:36:48.907274"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 256
  }, 
  {
    "buffer": "0x55a2b26c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.908648", 
      "end": "2018-02-09T10:36:48.908660"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 256
  }, 
  {
    "buffer": "0x55a2b26800", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.908778", 
      "end": "2018-02-09T10:36:48.908789"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 256
  }, 
  {
    "buffer": "0x55a2b26400", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.908898", 
      "end": "2018-02-09T10:36:48.909022"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 802816
  }, 
  {
    "kernel": "0x55a2b56000", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.909136", 
      "end": "2018-02-09T10:36:48.909292"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e0c"
  }, 
  {
    "buffer": "0x55a2b26000", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.909326", 
      "end": "2018-02-09T10:36:48.909429"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 802816
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe74171b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.913389", 
      "end": "2018-02-09T10:36:48.913438"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe74171ac", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#if defined(FIXED_POINT_POSITION)\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n\n#define ADD_OP(a, b) ADD_SAT_OP_EXPAND((a), (b), DATA_TYPE_PROMOTED, 8)\n#define MUL_OP(a, b) MUL_SAT_OP_EXPAND(CONVERT((a), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), CONVERT((b), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), DATA_TYPE_PROMOTED, 8, FIXED_POINT_POSITION)\n\n// There is no need to have a larger intermediate type for qs32 because all the arguments are already promoted\nMULQ_SAT_IMPL(qs32x8, qs32x8)\n\n#else /* FIXED_POINT_POSITION */\n#undef CONVERT_SAT\n\n#define ADD_OP(a, b) ((a) + (b))\n#define MUL_OP(a, b) ((a) * (b))\n#define CONVERT_SAT(a, b) ((a))\n\n#endif /* FIXED_POINT_POSITION */\n\n#if defined(DATA_TYPE) && defined(DATA_SIZE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if STRIDE_X == 3\n#define INPUT_PIXEL_STR(data_size) extract_input_stride3_##data_size\n#define INPUT_PIXEL(data_size) INPUT_PIXEL_STR(data_size)\n#elif STRIDE_X == 2\n#define INPUT_PIXEL(data_size) extract_input_stride2\n#elif STRIDE_X == 1\n#define INPUT_PIXEL(data_size) extract_input_stride1\n#else /* STRIDE_X not equals 1, 2 or 3 */\n#error \"Only support strides 1, 2 and 3\"\n#endif /* STRIDE_X == 3 */\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 1.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride1(__global const DATA_TYPE *input_pixel)\n{\n    return vload8(0, input_pixel);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 2.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride2(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp = vload16(0, input_pixel);\n    return temp.s02468ace;\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 32-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_32(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp1 = vload4(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp2 = vload4(0, input_pixel + 6);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp3 = vload4(0, input_pixel + 12);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp4 = vload4(0, input_pixel + 18);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s03, temp2.s03, temp3.s03, temp4.s03);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 16-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_16(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp1 = vload8(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp2 = vload8(0, input_pixel + 8);\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp3 = vload8(0, input_pixel + 16);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s036, temp2.s147, temp3.s25);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 8-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_8(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp1 = vload16(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp2 = vload16(0, input_pixel + 12);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s0369, temp2.s0369);\n}\n\n/** This kernel performs a direct convolution to convolve the low three dimensions.\n *\n * @note The data type must be passed at compile time using -DDATA_TYPE: e.g. -DDATA_TYPE=float\n * @note The data size must be passed at compile time using -DDATA_SIZE e.g. -DDATA_SIZE=32\n * @note The convolution stride x must be passed at compile time using -DSTRIDE_X e.g. -DSTRIDE_X=1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases will be added to the convolution -DHAS_BIAS has to be passed to append the final matrix with 1 in each row.\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F16/F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    Image    src     = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D weights = CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(weights);\n    Tensor3D dst     = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n#endif /* defined(HAS_BIAS) */\n\n    VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)\n    pixels = 0;\n\n    const uint z_index = get_global_id(2);\n\n    weights.ptr += z_index * weights_stride_w;\n\n    for(volatile int d = 0; d < WEIGHTS_DEPTH; ++d)\n    {\n        DATA_TYPE weight = *(__global DATA_TYPE *)weights.ptr;\n        VEC_DATA_TYPE(DATA_TYPE, 8)\n        input_pixel = INPUT_PIXEL(DATA_SIZE)((__global DATA_TYPE *)src.ptr);\n        pixels      = ADD_OP(pixels, MUL_OP((VEC_DATA_TYPE(DATA_TYPE, 8))weight, input_pixel));\n        src.ptr += src_stride_z;\n        weights.ptr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    pixels = ADD_OP(pixels, (VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)) * ((__global DATA_TYPE *)(vector_offset(&biases, z_index))));\n#endif /* defined(HAS_BIAS) */\n\n    vstore8(CONVERT_SAT(pixels, VEC_DATA_TYPE(DATA_TYPE, 8)), 0, (__global DATA_TYPE *)dst.ptr);\n}\n#endif // defined(DATA_TYPE) && defined(DATA_SIZE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n//    printf(\"get_local_size = %u %d %d- %d\\n\", get_local_size(0), get_local_size(1), get_local_size(2));\n//get_enqueued_local_size\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr); \n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n\n        CONVOLUTION1x1_BIFROST(acc0, src0, weight);\n        CONVOLUTION1x1_BIFROST(acc1, src1, weight);\n        CONVOLUTION1x1_BIFROST(acc2, src2, weight);\n        CONVOLUTION1x1_BIFROST(acc3, src3, weight);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_2(acc, src, weight_value) \\\n    ({                                                   \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);      \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);      \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);      \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);      \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_2(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n#if NUM_ELEM_ITERATION_Y == 1\n    float4 acc0 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 2 \n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 4\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 8\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n    float4 acc4 = 0.0f;\n    float4 acc5 = 0.0f;\n    float4 acc6 = 0.0f;\n    float4 acc7 = 0.0f;\n#endif /*NUM_ELEM_ITERATION_Y */\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr);\n\n        // Load values from row0 of input tensor\n#if NUM_ELEM_ITERATION_Y == 1\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 2\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 4 \n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 8 \n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        float4 src4 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        float4 src5 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        float4 src6 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        float4 src7 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n#endif /* NUM_ELEM_ITERATION_Y */\n\n#if NUM_ELEM_ITERATION_Y == 1\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n#elif NUM_ELEM_ITERATION_Y == 2\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n#elif NUM_ELEM_ITERATION_Y == 4\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n         CONVOLUTION1x1_BIFROST_2(acc2, src2, weight);\n         CONVOLUTION1x1_BIFROST_2(acc3, src3, weight);\n#elif NUM_ELEM_ITERATION_Y == 8\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n         CONVOLUTION1x1_BIFROST_2(acc2, src2, weight);\n         CONVOLUTION1x1_BIFROST_2(acc3, src3, weight);\n         CONVOLUTION1x1_BIFROST_2(acc4, src4, weight);\n         CONVOLUTION1x1_BIFROST_2(acc5, src5, weight);\n         CONVOLUTION1x1_BIFROST_2(acc6, src6, weight);\n         CONVOLUTION1x1_BIFROST_2(acc7, src7, weight);\n#endif /* NUM_ELEM_ITERATION_Y  */\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n#if NUM_ELEM_ITERATION_Y >= 1\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n#endif\n#if NUM_ELEM_ITERATION_Y >= 2\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n#endif\n\n#if NUM_ELEM_ITERATION_Y >= 4\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#endif\n\n#if NUM_ELEM_ITERATION_Y >= 8\n    acc4.s0 += bias;\n    acc4.s1 += bias;\n    acc4.s2 += bias;\n    acc4.s3 += bias;\n    acc5.s0 += bias;\n    acc5.s1 += bias;\n    acc5.s2 += bias;\n    acc5.s3 += bias;\n    acc6.s0 += bias;\n    acc6.s1 += bias;\n    acc6.s2 += bias;\n    acc6.s3 += bias;\n    acc7.s0 += bias;\n    acc7.s1 += bias;\n    acc7.s2 += bias;\n    acc7.s3 += bias;\n#endif /* NUM_ELEM_ITERATION_Y  > 8 */\n#endif /* defined(HAS_BIAS) */\n    \n#if NUM_ELEM_ITERATION_Y == 1\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 2\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 4\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 8\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n    vstore4(acc4, 0, (__global float *)(dst.ptr + 4 * dst_stride_y));\n    vstore4(acc5, 0, (__global float *)(dst.ptr + 5 * dst_stride_y));\n    vstore4(acc6, 0, (__global float *)(dst.ptr + 6 * dst_stride_y));\n    vstore4(acc7, 0, (__global float *)(dst.ptr + 7 * dst_stride_y));\n#endif\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_4(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_4(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n#if NUM_ELEM_ITERATION_Y == 8\n    float4 acc4 = 0.0f;\n    float4 acc5 = 0.0f;\n    float4 acc6 = 0.0f;\n    float4 acc7 = 0.0f;\n#endif\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr);\n#ifdef  OVERLAP\n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc0, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc1, src1, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc2, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc3, src1, weight);\n#if NUM_ELEM_ITERATION_Y == 8\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc4, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc5, src1, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc6, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc7, src1, weight);\n#endif\n\n\n#else\n   // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc0, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc1, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc2, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc3, src0, weight);\n#if NUM_ELEM_ITERATION_Y == 8\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc4, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc5, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc6, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc7, src0, weight);\n\n#endif /*NUM_ELEM_ITERATION_Y*/\n#endif /*INTERLEAVE8 */\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#if NUM_ELEM_ITERATION_Y == 8\n    acc4.s0 += bias;\n    acc4.s1 += bias;\n    acc4.s2 += bias;\n    acc4.s3 += bias;\n    acc5.s0 += bias;\n    acc5.s1 += bias;\n    acc5.s2 += bias;\n    acc5.s3 += bias;\n    acc6.s0 += bias;\n    acc6.s1 += bias;\n    acc6.s2 += bias;\n    acc6.s3 += bias;\n    acc7.s0 += bias;\n    acc7.s1 += bias;\n    acc7.s2 += bias;\n    acc7.s3 += bias;\n#endif /*NUM_ELEM_ITERATION_Y */\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n#if NUM_ELEM_ITERATION_Y == 8\n    vstore4(acc4, 0, (__global float *)(dst.ptr + 4 * dst_stride_y));\n    vstore4(acc5, 0, (__global float *)(dst.ptr + 5 * dst_stride_y));\n    vstore4(acc6, 0, (__global float *)(dst.ptr + 6 * dst_stride_y));\n    vstore4(acc7, 0, (__global float *)(dst.ptr + 7 * dst_stride_y));\n#endif /*NUM_ELEM_ITERATION_Y*/\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_1(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_1(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float acc0 = 0.0f;\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr); \n        // Load values from row0 of input tensor\n        float src0 = *((__global float *)(src_addr));\n        acc0 = mad(src0, weight, acc0);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n    acc0    += bias;\n#endif /* defined(HAS_BIAS) */\n     *((__global float *)dst.ptr) = acc0;\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n#define CONVOLUTION1x1_BIFROST_7(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_7(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n//    float4 acc2 = 0.0f;\n//    float4 acc3 = 0.0f;\n\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n//x=4 (see float4 acc), y=2 see how many src, w=4 see float4 w\n    for(ushort d = 0; d < (ushort)(WEIGHTS_DEPTH/4); ++d)\n    {\n        // Load the weights\n        float4 weight = vload4(0,(__global float *)(weights_addr)); \n\n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s0); \n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s0); \n\n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s1); \n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s1);\n    \n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s2);\n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s2);              \n\n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s3);\n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s3);\n\n//        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s0);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s1);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s2);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s3);\n      \n        src_addr += src_stride_z;\n        weights_addr +=  (4*weights_stride_z);\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n/*    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n*/\n\n\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n//    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n//    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n\n"
    }, 
    "program": "0x55a2b63a00", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe74171b0"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:48.913472", 
      "end": "2018-02-09T10:36:48.949784"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63a00", 
    "call": "clBuildProgram", 
    "options": " -DNUM_ELEM_ITERATION_Y=4 -DWEIGHTS_DEPTH=64 -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a2b55e00", 
    "name": "direct_convolution1x1_f32_bifrost_2", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.949884", 
      "end": "2018-02-09T10:36:48.982725"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63a00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74171ec"
  }, 
  {
    "buffer": "0x55a2b25c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.982852", 
      "end": "2018-02-09T10:36:48.982871"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741792c", 
    "size": 32768
  }, 
  {
    "buffer": "0x55a2b25800", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.983537", 
      "end": "2018-02-09T10:36:48.983692"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 802816
  }, 
  {
    "kernel": "0x55a2b55c00", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.983778", 
      "end": "2018-02-09T10:36:48.984007"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x55a33a6680", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.984030", 
      "end": "2018-02-09T10:36:48.984039"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a2b25400", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.984057", 
      "end": "2018-02-09T10:36:48.984069"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b25000", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.984629", 
      "end": "2018-02-09T10:36:48.984640"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b24c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.985168", 
      "end": "2018-02-09T10:36:48.985179"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b24800", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.985708", 
      "end": "2018-02-09T10:36:48.985720"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b24400", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.986039", 
      "end": "2018-02-09T10:36:48.986239"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 1605632
  }, 
  {
    "kernel": "0x55a2b55a00", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.986311", 
      "end": "2018-02-09T10:36:48.986418"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e2c"
  }, 
  {
    "buffer": "0x55a2b24000", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.986449", 
      "end": "2018-02-09T10:36:48.986656"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b9c", 
    "size": 1605632
  }, 
  {
    "buffer": "0x55a2b23c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.986679", 
      "end": "2018-02-09T10:36:48.987070"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 3268864
  }, 
  {
    "kernel": "0x55a2b55800", 
    "name": "depthwise_convolution_3x3", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.987207", 
      "end": "2018-02-09T10:36:48.987367"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63e00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741737c"
  }, 
  {
    "kernel": "0x55a2b55600", 
    "name": "fill_image_borders_constant", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.987412", 
      "end": "2018-02-09T10:36:48.987515"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63d00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741736c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55600", 
    "arg_value_ptr": "0x7fe74175d4", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.987533", 
      "end": "2018-02-09T10:36:48.987540"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "38000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55600", 
    "arg_value_ptr": "0x7fe74175d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.987554", 
      "end": "2018-02-09T10:36:48.987562"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "38000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55600", 
    "arg_value_ptr": "0x7fe74175e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.987574", 
      "end": "2018-02-09T10:36:48.987580"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000000000000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55600", 
    "arg_value_ptr": "0x7fe74175e4", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.987592", 
      "end": "2018-02-09T10:36:48.987599"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 11
  }, 
  {
    "buffer": "0x55a2b23800", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.987614", 
      "end": "2018-02-09T10:36:48.987624"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741790c", 
    "size": 4608
  }, 
  {
    "kernel": "0x55a2b55400", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.987967", 
      "end": "2018-02-09T10:36:48.988163"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x55a33a4e80", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.988187", 
      "end": "2018-02-09T10:36:48.988196"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a2b23400", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.988213", 
      "end": "2018-02-09T10:36:48.988224"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b23000", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.988545", 
      "end": "2018-02-09T10:36:48.988557"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b22c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.988871", 
      "end": "2018-02-09T10:36:48.988883"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b22800", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.989203", 
      "end": "2018-02-09T10:36:48.989217"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b22400", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.989540", 
      "end": "2018-02-09T10:36:48.989749"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 1605632
  }, 
  {
    "kernel": "0x55a2b55200", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.989800", 
      "end": "2018-02-09T10:36:48.989942"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e0c"
  }, 
  {
    "buffer": "0x55a2b22000", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.989972", 
      "end": "2018-02-09T10:36:48.990164"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 1605632
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe74171b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:48.994134", 
      "end": "2018-02-09T10:36:48.994159"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe74171ac", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#if defined(FIXED_POINT_POSITION)\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n\n#define ADD_OP(a, b) ADD_SAT_OP_EXPAND((a), (b), DATA_TYPE_PROMOTED, 8)\n#define MUL_OP(a, b) MUL_SAT_OP_EXPAND(CONVERT((a), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), CONVERT((b), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), DATA_TYPE_PROMOTED, 8, FIXED_POINT_POSITION)\n\n// There is no need to have a larger intermediate type for qs32 because all the arguments are already promoted\nMULQ_SAT_IMPL(qs32x8, qs32x8)\n\n#else /* FIXED_POINT_POSITION */\n#undef CONVERT_SAT\n\n#define ADD_OP(a, b) ((a) + (b))\n#define MUL_OP(a, b) ((a) * (b))\n#define CONVERT_SAT(a, b) ((a))\n\n#endif /* FIXED_POINT_POSITION */\n\n#if defined(DATA_TYPE) && defined(DATA_SIZE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if STRIDE_X == 3\n#define INPUT_PIXEL_STR(data_size) extract_input_stride3_##data_size\n#define INPUT_PIXEL(data_size) INPUT_PIXEL_STR(data_size)\n#elif STRIDE_X == 2\n#define INPUT_PIXEL(data_size) extract_input_stride2\n#elif STRIDE_X == 1\n#define INPUT_PIXEL(data_size) extract_input_stride1\n#else /* STRIDE_X not equals 1, 2 or 3 */\n#error \"Only support strides 1, 2 and 3\"\n#endif /* STRIDE_X == 3 */\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 1.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride1(__global const DATA_TYPE *input_pixel)\n{\n    return vload8(0, input_pixel);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 2.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride2(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp = vload16(0, input_pixel);\n    return temp.s02468ace;\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 32-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_32(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp1 = vload4(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp2 = vload4(0, input_pixel + 6);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp3 = vload4(0, input_pixel + 12);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp4 = vload4(0, input_pixel + 18);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s03, temp2.s03, temp3.s03, temp4.s03);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 16-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_16(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp1 = vload8(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp2 = vload8(0, input_pixel + 8);\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp3 = vload8(0, input_pixel + 16);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s036, temp2.s147, temp3.s25);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 8-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_8(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp1 = vload16(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp2 = vload16(0, input_pixel + 12);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s0369, temp2.s0369);\n}\n\n/** This kernel performs a direct convolution to convolve the low three dimensions.\n *\n * @note The data type must be passed at compile time using -DDATA_TYPE: e.g. -DDATA_TYPE=float\n * @note The data size must be passed at compile time using -DDATA_SIZE e.g. -DDATA_SIZE=32\n * @note The convolution stride x must be passed at compile time using -DSTRIDE_X e.g. -DSTRIDE_X=1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases will be added to the convolution -DHAS_BIAS has to be passed to append the final matrix with 1 in each row.\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F16/F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    Image    src     = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D weights = CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(weights);\n    Tensor3D dst     = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n#endif /* defined(HAS_BIAS) */\n\n    VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)\n    pixels = 0;\n\n    const uint z_index = get_global_id(2);\n\n    weights.ptr += z_index * weights_stride_w;\n\n    for(volatile int d = 0; d < WEIGHTS_DEPTH; ++d)\n    {\n        DATA_TYPE weight = *(__global DATA_TYPE *)weights.ptr;\n        VEC_DATA_TYPE(DATA_TYPE, 8)\n        input_pixel = INPUT_PIXEL(DATA_SIZE)((__global DATA_TYPE *)src.ptr);\n        pixels      = ADD_OP(pixels, MUL_OP((VEC_DATA_TYPE(DATA_TYPE, 8))weight, input_pixel));\n        src.ptr += src_stride_z;\n        weights.ptr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    pixels = ADD_OP(pixels, (VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)) * ((__global DATA_TYPE *)(vector_offset(&biases, z_index))));\n#endif /* defined(HAS_BIAS) */\n\n    vstore8(CONVERT_SAT(pixels, VEC_DATA_TYPE(DATA_TYPE, 8)), 0, (__global DATA_TYPE *)dst.ptr);\n}\n#endif // defined(DATA_TYPE) && defined(DATA_SIZE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n//    printf(\"get_local_size = %u %d %d- %d\\n\", get_local_size(0), get_local_size(1), get_local_size(2));\n//get_enqueued_local_size\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr); \n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n\n        CONVOLUTION1x1_BIFROST(acc0, src0, weight);\n        CONVOLUTION1x1_BIFROST(acc1, src1, weight);\n        CONVOLUTION1x1_BIFROST(acc2, src2, weight);\n        CONVOLUTION1x1_BIFROST(acc3, src3, weight);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_2(acc, src, weight_value) \\\n    ({                                                   \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);      \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);      \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);      \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);      \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_2(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n#if NUM_ELEM_ITERATION_Y == 1\n    float4 acc0 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 2 \n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 4\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 8\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n    float4 acc4 = 0.0f;\n    float4 acc5 = 0.0f;\n    float4 acc6 = 0.0f;\n    float4 acc7 = 0.0f;\n#endif /*NUM_ELEM_ITERATION_Y */\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr);\n\n        // Load values from row0 of input tensor\n#if NUM_ELEM_ITERATION_Y == 1\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 2\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 4 \n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 8 \n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        float4 src4 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        float4 src5 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        float4 src6 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        float4 src7 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n#endif /* NUM_ELEM_ITERATION_Y */\n\n#if NUM_ELEM_ITERATION_Y == 1\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n#elif NUM_ELEM_ITERATION_Y == 2\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n#elif NUM_ELEM_ITERATION_Y == 4\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n         CONVOLUTION1x1_BIFROST_2(acc2, src2, weight);\n         CONVOLUTION1x1_BIFROST_2(acc3, src3, weight);\n#elif NUM_ELEM_ITERATION_Y == 8\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n         CONVOLUTION1x1_BIFROST_2(acc2, src2, weight);\n         CONVOLUTION1x1_BIFROST_2(acc3, src3, weight);\n         CONVOLUTION1x1_BIFROST_2(acc4, src4, weight);\n         CONVOLUTION1x1_BIFROST_2(acc5, src5, weight);\n         CONVOLUTION1x1_BIFROST_2(acc6, src6, weight);\n         CONVOLUTION1x1_BIFROST_2(acc7, src7, weight);\n#endif /* NUM_ELEM_ITERATION_Y  */\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n#if NUM_ELEM_ITERATION_Y >= 1\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n#endif\n#if NUM_ELEM_ITERATION_Y >= 2\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n#endif\n\n#if NUM_ELEM_ITERATION_Y >= 4\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#endif\n\n#if NUM_ELEM_ITERATION_Y >= 8\n    acc4.s0 += bias;\n    acc4.s1 += bias;\n    acc4.s2 += bias;\n    acc4.s3 += bias;\n    acc5.s0 += bias;\n    acc5.s1 += bias;\n    acc5.s2 += bias;\n    acc5.s3 += bias;\n    acc6.s0 += bias;\n    acc6.s1 += bias;\n    acc6.s2 += bias;\n    acc6.s3 += bias;\n    acc7.s0 += bias;\n    acc7.s1 += bias;\n    acc7.s2 += bias;\n    acc7.s3 += bias;\n#endif /* NUM_ELEM_ITERATION_Y  > 8 */\n#endif /* defined(HAS_BIAS) */\n    \n#if NUM_ELEM_ITERATION_Y == 1\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 2\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 4\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 8\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n    vstore4(acc4, 0, (__global float *)(dst.ptr + 4 * dst_stride_y));\n    vstore4(acc5, 0, (__global float *)(dst.ptr + 5 * dst_stride_y));\n    vstore4(acc6, 0, (__global float *)(dst.ptr + 6 * dst_stride_y));\n    vstore4(acc7, 0, (__global float *)(dst.ptr + 7 * dst_stride_y));\n#endif\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_4(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_4(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n#if NUM_ELEM_ITERATION_Y == 8\n    float4 acc4 = 0.0f;\n    float4 acc5 = 0.0f;\n    float4 acc6 = 0.0f;\n    float4 acc7 = 0.0f;\n#endif\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr);\n#ifdef  OVERLAP\n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc0, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc1, src1, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc2, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc3, src1, weight);\n#if NUM_ELEM_ITERATION_Y == 8\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc4, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc5, src1, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc6, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc7, src1, weight);\n#endif\n\n\n#else\n   // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc0, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc1, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc2, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc3, src0, weight);\n#if NUM_ELEM_ITERATION_Y == 8\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc4, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc5, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc6, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc7, src0, weight);\n\n#endif /*NUM_ELEM_ITERATION_Y*/\n#endif /*INTERLEAVE8 */\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#if NUM_ELEM_ITERATION_Y == 8\n    acc4.s0 += bias;\n    acc4.s1 += bias;\n    acc4.s2 += bias;\n    acc4.s3 += bias;\n    acc5.s0 += bias;\n    acc5.s1 += bias;\n    acc5.s2 += bias;\n    acc5.s3 += bias;\n    acc6.s0 += bias;\n    acc6.s1 += bias;\n    acc6.s2 += bias;\n    acc6.s3 += bias;\n    acc7.s0 += bias;\n    acc7.s1 += bias;\n    acc7.s2 += bias;\n    acc7.s3 += bias;\n#endif /*NUM_ELEM_ITERATION_Y */\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n#if NUM_ELEM_ITERATION_Y == 8\n    vstore4(acc4, 0, (__global float *)(dst.ptr + 4 * dst_stride_y));\n    vstore4(acc5, 0, (__global float *)(dst.ptr + 5 * dst_stride_y));\n    vstore4(acc6, 0, (__global float *)(dst.ptr + 6 * dst_stride_y));\n    vstore4(acc7, 0, (__global float *)(dst.ptr + 7 * dst_stride_y));\n#endif /*NUM_ELEM_ITERATION_Y*/\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_1(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_1(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float acc0 = 0.0f;\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr); \n        // Load values from row0 of input tensor\n        float src0 = *((__global float *)(src_addr));\n        acc0 = mad(src0, weight, acc0);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n    acc0    += bias;\n#endif /* defined(HAS_BIAS) */\n     *((__global float *)dst.ptr) = acc0;\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n#define CONVOLUTION1x1_BIFROST_7(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_7(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n//    float4 acc2 = 0.0f;\n//    float4 acc3 = 0.0f;\n\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n//x=4 (see float4 acc), y=2 see how many src, w=4 see float4 w\n    for(ushort d = 0; d < (ushort)(WEIGHTS_DEPTH/4); ++d)\n    {\n        // Load the weights\n        float4 weight = vload4(0,(__global float *)(weights_addr)); \n\n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s0); \n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s0); \n\n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s1); \n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s1);\n    \n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s2);\n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s2);              \n\n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s3);\n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s3);\n\n//        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s0);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s1);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s2);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s3);\n      \n        src_addr += src_stride_z;\n        weights_addr +=  (4*weights_stride_z);\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n/*    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n*/\n\n\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n//    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n//    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n\n"
    }, 
    "program": "0x55a2b63900", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe74171b0"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:48.994181", 
      "end": "2018-02-09T10:36:49.032864"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63900", 
    "call": "clBuildProgram", 
    "options": " -DNUM_ELEM_ITERATION_Y=4 -DWEIGHTS_DEPTH=128 -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a2b55000", 
    "name": "direct_convolution1x1_f32_bifrost_2", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.032970", 
      "end": "2018-02-09T10:36:49.065822"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63900", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74171ec"
  }, 
  {
    "buffer": "0x55a2b21c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.065961", 
      "end": "2018-02-09T10:36:49.065981"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741792c", 
    "size": 65536
  }, 
  {
    "buffer": "0x55a2b21800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.066480", 
      "end": "2018-02-09T10:36:49.066709"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 1605632
  }, 
  {
    "kernel": "0x55a2b54e00", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.066793", 
      "end": "2018-02-09T10:36:49.067000"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x55a30b6710", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.067023", 
      "end": "2018-02-09T10:36:49.067033"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a2b21400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.067050", 
      "end": "2018-02-09T10:36:49.067061"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b21000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.067405", 
      "end": "2018-02-09T10:36:49.067414"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b20c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.067757", 
      "end": "2018-02-09T10:36:49.067767"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b20800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.068312", 
      "end": "2018-02-09T10:36:49.068324"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b20400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.068856", 
      "end": "2018-02-09T10:36:49.069030"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 1605632
  }, 
  {
    "kernel": "0x55a2b54c00", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.069128", 
      "end": "2018-02-09T10:36:49.069227"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e2c"
  }, 
  {
    "buffer": "0x55a2b20000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.069255", 
      "end": "2018-02-09T10:36:49.069426"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b9c", 
    "size": 1605632
  }, 
  {
    "buffer": "0x55a2b1fc00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.069446", 
      "end": "2018-02-09T10:36:49.069637"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 1722368
  }, 
  {
    "kernel": "0x55a2b54a00", 
    "name": "depthwise_convolution_3x3", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.069765", 
      "end": "2018-02-09T10:36:49.069915"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63b00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741737c"
  }, 
  {
    "kernel": "0x55a2b54800", 
    "name": "fill_image_borders_constant", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.069956", 
      "end": "2018-02-09T10:36:49.070036"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64100", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741736c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54800", 
    "arg_value_ptr": "0x7fe74175d4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.070055", 
      "end": "2018-02-09T10:36:49.070061"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "38000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54800", 
    "arg_value_ptr": "0x7fe74175d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.070074", 
      "end": "2018-02-09T10:36:49.070080"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "38000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54800", 
    "arg_value_ptr": "0x7fe74175e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.070094", 
      "end": "2018-02-09T10:36:49.070098"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000000000000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54800", 
    "arg_value_ptr": "0x7fe74175e4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.070111", 
      "end": "2018-02-09T10:36:49.070117"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 11
  }, 
  {
    "buffer": "0x55a2b1f800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.070132", 
      "end": "2018-02-09T10:36:49.070140"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741790c", 
    "size": 4608
  }, 
  {
    "kernel": "0x55a2b54600", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.071510", 
      "end": "2018-02-09T10:36:49.071700"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x55a3468150", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.071719", 
      "end": "2018-02-09T10:36:49.071725"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a2b1f400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.071741", 
      "end": "2018-02-09T10:36:49.071750"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b1f000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.072895", 
      "end": "2018-02-09T10:36:49.072905"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b1ec00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.074051", 
      "end": "2018-02-09T10:36:49.074061"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b1e800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.075012", 
      "end": "2018-02-09T10:36:49.075022"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 512
  }, 
  {
    "buffer": "0x55a2b1e400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.075348", 
      "end": "2018-02-09T10:36:49.075415"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 401408
  }, 
  {
    "kernel": "0x55a2b54400", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.075464", 
      "end": "2018-02-09T10:36:49.075598"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e0c"
  }, 
  {
    "buffer": "0x55a3318800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.075625", 
      "end": "2018-02-09T10:36:49.075696"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 401408
  }, 
  {
    "kernel": "0x55a2b54200", 
    "name": "direct_convolution1x1_f32_bifrost_2", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.075758", 
      "end": "2018-02-09T10:36:49.075903"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63900", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74171ec"
  }, 
  {
    "buffer": "0x55a3318400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.075934", 
      "end": "2018-02-09T10:36:49.075944"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741792c", 
    "size": 131072
  }, 
  {
    "buffer": "0x55a3318000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.076299", 
      "end": "2018-02-09T10:36:49.076366"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 401408
  }, 
  {
    "kernel": "0x55a2b54000", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.076405", 
      "end": "2018-02-09T10:36:49.076620"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x55a33a2350", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.076643", 
      "end": "2018-02-09T10:36:49.076651"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a3317c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.076669", 
      "end": "2018-02-09T10:36:49.076680"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3317800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.076808", 
      "end": "2018-02-09T10:36:49.076818"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3317400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.076920", 
      "end": "2018-02-09T10:36:49.076930"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3317000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.077034", 
      "end": "2018-02-09T10:36:49.077046"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3316c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.077205", 
      "end": "2018-02-09T10:36:49.077316"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 802816
  }, 
  {
    "kernel": "0x55a2b53e00", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.077368", 
      "end": "2018-02-09T10:36:49.077484"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e2c"
  }, 
  {
    "buffer": "0x55a3316800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.077509", 
      "end": "2018-02-09T10:36:49.077630"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b9c", 
    "size": 802816
  }, 
  {
    "buffer": "0x55a3316400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.077651", 
      "end": "2018-02-09T10:36:49.077853"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 1663488
  }, 
  {
    "kernel": "0x55a2b53c00", 
    "name": "depthwise_convolution_3x3", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.077943", 
      "end": "2018-02-09T10:36:49.078097"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63e00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741737c"
  }, 
  {
    "kernel": "0x55a2b53a00", 
    "name": "fill_image_borders_constant", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.078137", 
      "end": "2018-02-09T10:36:49.078229"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63d00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741736c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53a00", 
    "arg_value_ptr": "0x7fe74175d4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.078247", 
      "end": "2018-02-09T10:36:49.078255"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "1c000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53a00", 
    "arg_value_ptr": "0x7fe74175d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.078270", 
      "end": "2018-02-09T10:36:49.078276"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "1c000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53a00", 
    "arg_value_ptr": "0x7fe74175e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.078289", 
      "end": "2018-02-09T10:36:49.078294"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000000000000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53a00", 
    "arg_value_ptr": "0x7fe74175e4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.078308", 
      "end": "2018-02-09T10:36:49.078313"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 11
  }, 
  {
    "buffer": "0x55a3316000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.078329", 
      "end": "2018-02-09T10:36:49.078341"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741790c", 
    "size": 9216
  }, 
  {
    "kernel": "0x55a2b53800", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.078495", 
      "end": "2018-02-09T10:36:49.078705"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x55a3455880", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.078728", 
      "end": "2018-02-09T10:36:49.078734"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a3315c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.078754", 
      "end": "2018-02-09T10:36:49.078764"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3315800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.078892", 
      "end": "2018-02-09T10:36:49.078903"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3315400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.079015", 
      "end": "2018-02-09T10:36:49.079025"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3315000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.079137", 
      "end": "2018-02-09T10:36:49.079148"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3314c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.079265", 
      "end": "2018-02-09T10:36:49.079378"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 802816
  }, 
  {
    "kernel": "0x55a2b53600", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.079426", 
      "end": "2018-02-09T10:36:49.079547"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e0c"
  }, 
  {
    "buffer": "0x55a3314800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.079576", 
      "end": "2018-02-09T10:36:49.079683"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 802816
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe74171b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.083548", 
      "end": "2018-02-09T10:36:49.083572"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe74171ac", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#if defined(FIXED_POINT_POSITION)\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n\n#define ADD_OP(a, b) ADD_SAT_OP_EXPAND((a), (b), DATA_TYPE_PROMOTED, 8)\n#define MUL_OP(a, b) MUL_SAT_OP_EXPAND(CONVERT((a), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), CONVERT((b), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), DATA_TYPE_PROMOTED, 8, FIXED_POINT_POSITION)\n\n// There is no need to have a larger intermediate type for qs32 because all the arguments are already promoted\nMULQ_SAT_IMPL(qs32x8, qs32x8)\n\n#else /* FIXED_POINT_POSITION */\n#undef CONVERT_SAT\n\n#define ADD_OP(a, b) ((a) + (b))\n#define MUL_OP(a, b) ((a) * (b))\n#define CONVERT_SAT(a, b) ((a))\n\n#endif /* FIXED_POINT_POSITION */\n\n#if defined(DATA_TYPE) && defined(DATA_SIZE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if STRIDE_X == 3\n#define INPUT_PIXEL_STR(data_size) extract_input_stride3_##data_size\n#define INPUT_PIXEL(data_size) INPUT_PIXEL_STR(data_size)\n#elif STRIDE_X == 2\n#define INPUT_PIXEL(data_size) extract_input_stride2\n#elif STRIDE_X == 1\n#define INPUT_PIXEL(data_size) extract_input_stride1\n#else /* STRIDE_X not equals 1, 2 or 3 */\n#error \"Only support strides 1, 2 and 3\"\n#endif /* STRIDE_X == 3 */\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 1.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride1(__global const DATA_TYPE *input_pixel)\n{\n    return vload8(0, input_pixel);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 2.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride2(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp = vload16(0, input_pixel);\n    return temp.s02468ace;\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 32-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_32(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp1 = vload4(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp2 = vload4(0, input_pixel + 6);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp3 = vload4(0, input_pixel + 12);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp4 = vload4(0, input_pixel + 18);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s03, temp2.s03, temp3.s03, temp4.s03);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 16-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_16(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp1 = vload8(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp2 = vload8(0, input_pixel + 8);\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp3 = vload8(0, input_pixel + 16);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s036, temp2.s147, temp3.s25);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 8-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_8(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp1 = vload16(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp2 = vload16(0, input_pixel + 12);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s0369, temp2.s0369);\n}\n\n/** This kernel performs a direct convolution to convolve the low three dimensions.\n *\n * @note The data type must be passed at compile time using -DDATA_TYPE: e.g. -DDATA_TYPE=float\n * @note The data size must be passed at compile time using -DDATA_SIZE e.g. -DDATA_SIZE=32\n * @note The convolution stride x must be passed at compile time using -DSTRIDE_X e.g. -DSTRIDE_X=1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases will be added to the convolution -DHAS_BIAS has to be passed to append the final matrix with 1 in each row.\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F16/F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    Image    src     = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D weights = CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(weights);\n    Tensor3D dst     = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n#endif /* defined(HAS_BIAS) */\n\n    VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)\n    pixels = 0;\n\n    const uint z_index = get_global_id(2);\n\n    weights.ptr += z_index * weights_stride_w;\n\n    for(volatile int d = 0; d < WEIGHTS_DEPTH; ++d)\n    {\n        DATA_TYPE weight = *(__global DATA_TYPE *)weights.ptr;\n        VEC_DATA_TYPE(DATA_TYPE, 8)\n        input_pixel = INPUT_PIXEL(DATA_SIZE)((__global DATA_TYPE *)src.ptr);\n        pixels      = ADD_OP(pixels, MUL_OP((VEC_DATA_TYPE(DATA_TYPE, 8))weight, input_pixel));\n        src.ptr += src_stride_z;\n        weights.ptr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    pixels = ADD_OP(pixels, (VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)) * ((__global DATA_TYPE *)(vector_offset(&biases, z_index))));\n#endif /* defined(HAS_BIAS) */\n\n    vstore8(CONVERT_SAT(pixels, VEC_DATA_TYPE(DATA_TYPE, 8)), 0, (__global DATA_TYPE *)dst.ptr);\n}\n#endif // defined(DATA_TYPE) && defined(DATA_SIZE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n//    printf(\"get_local_size = %u %d %d- %d\\n\", get_local_size(0), get_local_size(1), get_local_size(2));\n//get_enqueued_local_size\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr); \n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n\n        CONVOLUTION1x1_BIFROST(acc0, src0, weight);\n        CONVOLUTION1x1_BIFROST(acc1, src1, weight);\n        CONVOLUTION1x1_BIFROST(acc2, src2, weight);\n        CONVOLUTION1x1_BIFROST(acc3, src3, weight);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_2(acc, src, weight_value) \\\n    ({                                                   \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);      \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);      \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);      \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);      \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_2(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n#if NUM_ELEM_ITERATION_Y == 1\n    float4 acc0 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 2 \n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 4\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 8\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n    float4 acc4 = 0.0f;\n    float4 acc5 = 0.0f;\n    float4 acc6 = 0.0f;\n    float4 acc7 = 0.0f;\n#endif /*NUM_ELEM_ITERATION_Y */\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr);\n\n        // Load values from row0 of input tensor\n#if NUM_ELEM_ITERATION_Y == 1\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 2\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 4 \n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 8 \n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        float4 src4 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        float4 src5 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        float4 src6 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        float4 src7 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n#endif /* NUM_ELEM_ITERATION_Y */\n\n#if NUM_ELEM_ITERATION_Y == 1\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n#elif NUM_ELEM_ITERATION_Y == 2\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n#elif NUM_ELEM_ITERATION_Y == 4\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n         CONVOLUTION1x1_BIFROST_2(acc2, src2, weight);\n         CONVOLUTION1x1_BIFROST_2(acc3, src3, weight);\n#elif NUM_ELEM_ITERATION_Y == 8\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n         CONVOLUTION1x1_BIFROST_2(acc2, src2, weight);\n         CONVOLUTION1x1_BIFROST_2(acc3, src3, weight);\n         CONVOLUTION1x1_BIFROST_2(acc4, src4, weight);\n         CONVOLUTION1x1_BIFROST_2(acc5, src5, weight);\n         CONVOLUTION1x1_BIFROST_2(acc6, src6, weight);\n         CONVOLUTION1x1_BIFROST_2(acc7, src7, weight);\n#endif /* NUM_ELEM_ITERATION_Y  */\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n#if NUM_ELEM_ITERATION_Y >= 1\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n#endif\n#if NUM_ELEM_ITERATION_Y >= 2\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n#endif\n\n#if NUM_ELEM_ITERATION_Y >= 4\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#endif\n\n#if NUM_ELEM_ITERATION_Y >= 8\n    acc4.s0 += bias;\n    acc4.s1 += bias;\n    acc4.s2 += bias;\n    acc4.s3 += bias;\n    acc5.s0 += bias;\n    acc5.s1 += bias;\n    acc5.s2 += bias;\n    acc5.s3 += bias;\n    acc6.s0 += bias;\n    acc6.s1 += bias;\n    acc6.s2 += bias;\n    acc6.s3 += bias;\n    acc7.s0 += bias;\n    acc7.s1 += bias;\n    acc7.s2 += bias;\n    acc7.s3 += bias;\n#endif /* NUM_ELEM_ITERATION_Y  > 8 */\n#endif /* defined(HAS_BIAS) */\n    \n#if NUM_ELEM_ITERATION_Y == 1\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 2\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 4\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 8\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n    vstore4(acc4, 0, (__global float *)(dst.ptr + 4 * dst_stride_y));\n    vstore4(acc5, 0, (__global float *)(dst.ptr + 5 * dst_stride_y));\n    vstore4(acc6, 0, (__global float *)(dst.ptr + 6 * dst_stride_y));\n    vstore4(acc7, 0, (__global float *)(dst.ptr + 7 * dst_stride_y));\n#endif\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_4(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_4(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n#if NUM_ELEM_ITERATION_Y == 8\n    float4 acc4 = 0.0f;\n    float4 acc5 = 0.0f;\n    float4 acc6 = 0.0f;\n    float4 acc7 = 0.0f;\n#endif\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr);\n#ifdef  OVERLAP\n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc0, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc1, src1, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc2, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc3, src1, weight);\n#if NUM_ELEM_ITERATION_Y == 8\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc4, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc5, src1, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc6, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc7, src1, weight);\n#endif\n\n\n#else\n   // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc0, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc1, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc2, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc3, src0, weight);\n#if NUM_ELEM_ITERATION_Y == 8\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc4, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc5, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc6, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc7, src0, weight);\n\n#endif /*NUM_ELEM_ITERATION_Y*/\n#endif /*INTERLEAVE8 */\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#if NUM_ELEM_ITERATION_Y == 8\n    acc4.s0 += bias;\n    acc4.s1 += bias;\n    acc4.s2 += bias;\n    acc4.s3 += bias;\n    acc5.s0 += bias;\n    acc5.s1 += bias;\n    acc5.s2 += bias;\n    acc5.s3 += bias;\n    acc6.s0 += bias;\n    acc6.s1 += bias;\n    acc6.s2 += bias;\n    acc6.s3 += bias;\n    acc7.s0 += bias;\n    acc7.s1 += bias;\n    acc7.s2 += bias;\n    acc7.s3 += bias;\n#endif /*NUM_ELEM_ITERATION_Y */\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n#if NUM_ELEM_ITERATION_Y == 8\n    vstore4(acc4, 0, (__global float *)(dst.ptr + 4 * dst_stride_y));\n    vstore4(acc5, 0, (__global float *)(dst.ptr + 5 * dst_stride_y));\n    vstore4(acc6, 0, (__global float *)(dst.ptr + 6 * dst_stride_y));\n    vstore4(acc7, 0, (__global float *)(dst.ptr + 7 * dst_stride_y));\n#endif /*NUM_ELEM_ITERATION_Y*/\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_1(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_1(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float acc0 = 0.0f;\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr); \n        // Load values from row0 of input tensor\n        float src0 = *((__global float *)(src_addr));\n        acc0 = mad(src0, weight, acc0);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n    acc0    += bias;\n#endif /* defined(HAS_BIAS) */\n     *((__global float *)dst.ptr) = acc0;\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n#define CONVOLUTION1x1_BIFROST_7(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_7(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n//    float4 acc2 = 0.0f;\n//    float4 acc3 = 0.0f;\n\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n//x=4 (see float4 acc), y=2 see how many src, w=4 see float4 w\n    for(ushort d = 0; d < (ushort)(WEIGHTS_DEPTH/4); ++d)\n    {\n        // Load the weights\n        float4 weight = vload4(0,(__global float *)(weights_addr)); \n\n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s0); \n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s0); \n\n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s1); \n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s1);\n    \n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s2);\n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s2);              \n\n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s3);\n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s3);\n\n//        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s0);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s1);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s2);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s3);\n      \n        src_addr += src_stride_z;\n        weights_addr +=  (4*weights_stride_z);\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n/*    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n*/\n\n\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n//    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n//    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n\n"
    }, 
    "program": "0x55a2b63800", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe74171b0"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.083592", 
      "end": "2018-02-09T10:36:49.119314"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63800", 
    "call": "clBuildProgram", 
    "options": " -DNUM_ELEM_ITERATION_Y=4 -DWEIGHTS_DEPTH=256 -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a2b53400", 
    "name": "direct_convolution1x1_f32_bifrost_2", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.119442", 
      "end": "2018-02-09T10:36:49.152066"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63800", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74171ec"
  }, 
  {
    "buffer": "0x55a3314400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.152217", 
      "end": "2018-02-09T10:36:49.152321"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741792c", 
    "size": 262144
  }, 
  {
    "buffer": "0x55a3314000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.153009", 
      "end": "2018-02-09T10:36:49.153151"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 802816
  }, 
  {
    "kernel": "0x55a2b53200", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.153238", 
      "end": "2018-02-09T10:36:49.153445"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x55a35714a0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.153467", 
      "end": "2018-02-09T10:36:49.153476"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a3313c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.153493", 
      "end": "2018-02-09T10:36:49.153503"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3313800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.153862", 
      "end": "2018-02-09T10:36:49.153872"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3313400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.154192", 
      "end": "2018-02-09T10:36:49.154202"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3313000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.154518", 
      "end": "2018-02-09T10:36:49.154528"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3312c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.154844", 
      "end": "2018-02-09T10:36:49.154970"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 802816
  }, 
  {
    "kernel": "0x55a2b53000", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.155041", 
      "end": "2018-02-09T10:36:49.155145"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e2c"
  }, 
  {
    "buffer": "0x55a3312800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.155175", 
      "end": "2018-02-09T10:36:49.155283"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b9c", 
    "size": 802816
  }, 
  {
    "buffer": "0x55a3312400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.155305", 
      "end": "2018-02-09T10:36:49.155425"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 921600
  }, 
  {
    "kernel": "0x55a2b52e00", 
    "name": "depthwise_convolution_3x3", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.155556", 
      "end": "2018-02-09T10:36:49.155715"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63b00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741737c"
  }, 
  {
    "kernel": "0x55a2b52c00", 
    "name": "fill_image_borders_constant", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.155758", 
      "end": "2018-02-09T10:36:49.155839"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64100", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741736c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52c00", 
    "arg_value_ptr": "0x7fe74175d4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.155860", 
      "end": "2018-02-09T10:36:49.155868"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "1c000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52c00", 
    "arg_value_ptr": "0x7fe74175d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.155883", 
      "end": "2018-02-09T10:36:49.155890"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "1c000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52c00", 
    "arg_value_ptr": "0x7fe74175e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.155904", 
      "end": "2018-02-09T10:36:49.155910"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000000000000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52c00", 
    "arg_value_ptr": "0x7fe74175e4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.155922", 
      "end": "2018-02-09T10:36:49.155927"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 11
  }, 
  {
    "buffer": "0x55a3312000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.155943", 
      "end": "2018-02-09T10:36:49.155991"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741790c", 
    "size": 9216
  }, 
  {
    "kernel": "0x55a2b52a00", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.156334", 
      "end": "2018-02-09T10:36:49.156533"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x55a354d670", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.156553", 
      "end": "2018-02-09T10:36:49.156560"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a3311c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.156577", 
      "end": "2018-02-09T10:36:49.156589"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3311800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.156909", 
      "end": "2018-02-09T10:36:49.156921"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3311400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.157234", 
      "end": "2018-02-09T10:36:49.157245"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3311000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.157347", 
      "end": "2018-02-09T10:36:49.157358"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 1024
  }, 
  {
    "buffer": "0x55a3310c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.157459", 
      "end": "2018-02-09T10:36:49.157470"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 229376
  }, 
  {
    "kernel": "0x55a2b52800", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.157517", 
      "end": "2018-02-09T10:36:49.157649"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e0c"
  }, 
  {
    "buffer": "0x55a3310800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.157675", 
      "end": "2018-02-09T10:36:49.157727"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 229376
  }, 
  {
    "kernel": "0x55a2b52600", 
    "name": "direct_convolution1x1_f32_bifrost_2", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.157789", 
      "end": "2018-02-09T10:36:49.157947"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63800", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74171ec"
  }, 
  {
    "buffer": "0x55a3310400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.157980", 
      "end": "2018-02-09T10:36:49.158060"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741792c", 
    "size": 524288
  }, 
  {
    "buffer": "0x55a3310000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.158245", 
      "end": "2018-02-09T10:36:49.158297"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 262144
  }, 
  {
    "kernel": "0x55a2b52400", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.158336", 
      "end": "2018-02-09T10:36:49.158540"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x55a355a310", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.158562", 
      "end": "2018-02-09T10:36:49.158570"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a330fc00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.158588", 
      "end": "2018-02-09T10:36:49.158596"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a330f800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.159008", 
      "end": "2018-02-09T10:36:49.159018"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a330f400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.159341", 
      "end": "2018-02-09T10:36:49.159350"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a330f000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.159673", 
      "end": "2018-02-09T10:36:49.159684"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a330ec00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.160009", 
      "end": "2018-02-09T10:36:49.160095"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 524288
  }, 
  {
    "kernel": "0x55a2b52200", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.160140", 
      "end": "2018-02-09T10:36:49.160248"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e2c"
  }, 
  {
    "buffer": "0x55a330e800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.160275", 
      "end": "2018-02-09T10:36:49.160345"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b9c", 
    "size": 458752
  }, 
  {
    "buffer": "0x55a330e400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.160364", 
      "end": "2018-02-09T10:36:49.160467"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 861184
  }, 
  {
    "kernel": "0x55a2b52000", 
    "name": "depthwise_convolution_3x3", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.160559", 
      "end": "2018-02-09T10:36:49.160711"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63e00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741737c"
  }, 
  {
    "kernel": "0x55a2b51e00", 
    "name": "fill_image_borders_constant", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.160750", 
      "end": "2018-02-09T10:36:49.160838"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63d00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741736c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51e00", 
    "arg_value_ptr": "0x7fe74175d4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.160858", 
      "end": "2018-02-09T10:36:49.160866"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0e000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51e00", 
    "arg_value_ptr": "0x7fe74175d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.160880", 
      "end": "2018-02-09T10:36:49.160886"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0e000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51e00", 
    "arg_value_ptr": "0x7fe74175e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.160902", 
      "end": "2018-02-09T10:36:49.160907"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000000000000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51e00", 
    "arg_value_ptr": "0x7fe74175e4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.160921", 
      "end": "2018-02-09T10:36:49.160926"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 11
  }, 
  {
    "buffer": "0x55a330e000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.160943", 
      "end": "2018-02-09T10:36:49.160954"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741790c", 
    "size": 18432
  }, 
  {
    "kernel": "0x55a2b51c00", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.161316", 
      "end": "2018-02-09T10:36:49.161520"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x55a33fc1a0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.161545", 
      "end": "2018-02-09T10:36:49.161552"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a330dc00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.161572", 
      "end": "2018-02-09T10:36:49.161581"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a330d800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.161912", 
      "end": "2018-02-09T10:36:49.161923"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a330d400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.162030", 
      "end": "2018-02-09T10:36:49.162041"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a330d000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.162146", 
      "end": "2018-02-09T10:36:49.162158"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a330cc00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.162261", 
      "end": "2018-02-09T10:36:49.162335"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a2b51a00", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.162386", 
      "end": "2018-02-09T10:36:49.162521"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e0c"
  }, 
  {
    "buffer": "0x55a330c800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.162552", 
      "end": "2018-02-09T10:36:49.162639"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe74171b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.166499", 
      "end": "2018-02-09T10:36:49.166527"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe74171ac", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#if defined(FIXED_POINT_POSITION)\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n\n#define ADD_OP(a, b) ADD_SAT_OP_EXPAND((a), (b), DATA_TYPE_PROMOTED, 8)\n#define MUL_OP(a, b) MUL_SAT_OP_EXPAND(CONVERT((a), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), CONVERT((b), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), DATA_TYPE_PROMOTED, 8, FIXED_POINT_POSITION)\n\n// There is no need to have a larger intermediate type for qs32 because all the arguments are already promoted\nMULQ_SAT_IMPL(qs32x8, qs32x8)\n\n#else /* FIXED_POINT_POSITION */\n#undef CONVERT_SAT\n\n#define ADD_OP(a, b) ((a) + (b))\n#define MUL_OP(a, b) ((a) * (b))\n#define CONVERT_SAT(a, b) ((a))\n\n#endif /* FIXED_POINT_POSITION */\n\n#if defined(DATA_TYPE) && defined(DATA_SIZE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if STRIDE_X == 3\n#define INPUT_PIXEL_STR(data_size) extract_input_stride3_##data_size\n#define INPUT_PIXEL(data_size) INPUT_PIXEL_STR(data_size)\n#elif STRIDE_X == 2\n#define INPUT_PIXEL(data_size) extract_input_stride2\n#elif STRIDE_X == 1\n#define INPUT_PIXEL(data_size) extract_input_stride1\n#else /* STRIDE_X not equals 1, 2 or 3 */\n#error \"Only support strides 1, 2 and 3\"\n#endif /* STRIDE_X == 3 */\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 1.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride1(__global const DATA_TYPE *input_pixel)\n{\n    return vload8(0, input_pixel);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 2.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride2(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp = vload16(0, input_pixel);\n    return temp.s02468ace;\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 32-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_32(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp1 = vload4(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp2 = vload4(0, input_pixel + 6);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp3 = vload4(0, input_pixel + 12);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp4 = vload4(0, input_pixel + 18);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s03, temp2.s03, temp3.s03, temp4.s03);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 16-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_16(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp1 = vload8(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp2 = vload8(0, input_pixel + 8);\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp3 = vload8(0, input_pixel + 16);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s036, temp2.s147, temp3.s25);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 8-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_8(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp1 = vload16(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp2 = vload16(0, input_pixel + 12);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s0369, temp2.s0369);\n}\n\n/** This kernel performs a direct convolution to convolve the low three dimensions.\n *\n * @note The data type must be passed at compile time using -DDATA_TYPE: e.g. -DDATA_TYPE=float\n * @note The data size must be passed at compile time using -DDATA_SIZE e.g. -DDATA_SIZE=32\n * @note The convolution stride x must be passed at compile time using -DSTRIDE_X e.g. -DSTRIDE_X=1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases will be added to the convolution -DHAS_BIAS has to be passed to append the final matrix with 1 in each row.\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F16/F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    Image    src     = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D weights = CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(weights);\n    Tensor3D dst     = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n#endif /* defined(HAS_BIAS) */\n\n    VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)\n    pixels = 0;\n\n    const uint z_index = get_global_id(2);\n\n    weights.ptr += z_index * weights_stride_w;\n\n    for(volatile int d = 0; d < WEIGHTS_DEPTH; ++d)\n    {\n        DATA_TYPE weight = *(__global DATA_TYPE *)weights.ptr;\n        VEC_DATA_TYPE(DATA_TYPE, 8)\n        input_pixel = INPUT_PIXEL(DATA_SIZE)((__global DATA_TYPE *)src.ptr);\n        pixels      = ADD_OP(pixels, MUL_OP((VEC_DATA_TYPE(DATA_TYPE, 8))weight, input_pixel));\n        src.ptr += src_stride_z;\n        weights.ptr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    pixels = ADD_OP(pixels, (VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)) * ((__global DATA_TYPE *)(vector_offset(&biases, z_index))));\n#endif /* defined(HAS_BIAS) */\n\n    vstore8(CONVERT_SAT(pixels, VEC_DATA_TYPE(DATA_TYPE, 8)), 0, (__global DATA_TYPE *)dst.ptr);\n}\n#endif // defined(DATA_TYPE) && defined(DATA_SIZE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n//    printf(\"get_local_size = %u %d %d- %d\\n\", get_local_size(0), get_local_size(1), get_local_size(2));\n//get_enqueued_local_size\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr); \n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n\n        CONVOLUTION1x1_BIFROST(acc0, src0, weight);\n        CONVOLUTION1x1_BIFROST(acc1, src1, weight);\n        CONVOLUTION1x1_BIFROST(acc2, src2, weight);\n        CONVOLUTION1x1_BIFROST(acc3, src3, weight);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_2(acc, src, weight_value) \\\n    ({                                                   \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);      \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);      \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);      \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);      \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_2(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n#if NUM_ELEM_ITERATION_Y == 1\n    float4 acc0 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 2 \n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 4\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 8\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n    float4 acc4 = 0.0f;\n    float4 acc5 = 0.0f;\n    float4 acc6 = 0.0f;\n    float4 acc7 = 0.0f;\n#endif /*NUM_ELEM_ITERATION_Y */\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr);\n\n        // Load values from row0 of input tensor\n#if NUM_ELEM_ITERATION_Y == 1\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 2\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 4 \n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 8 \n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        float4 src4 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        float4 src5 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        float4 src6 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        float4 src7 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n#endif /* NUM_ELEM_ITERATION_Y */\n\n#if NUM_ELEM_ITERATION_Y == 1\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n#elif NUM_ELEM_ITERATION_Y == 2\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n#elif NUM_ELEM_ITERATION_Y == 4\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n         CONVOLUTION1x1_BIFROST_2(acc2, src2, weight);\n         CONVOLUTION1x1_BIFROST_2(acc3, src3, weight);\n#elif NUM_ELEM_ITERATION_Y == 8\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n         CONVOLUTION1x1_BIFROST_2(acc2, src2, weight);\n         CONVOLUTION1x1_BIFROST_2(acc3, src3, weight);\n         CONVOLUTION1x1_BIFROST_2(acc4, src4, weight);\n         CONVOLUTION1x1_BIFROST_2(acc5, src5, weight);\n         CONVOLUTION1x1_BIFROST_2(acc6, src6, weight);\n         CONVOLUTION1x1_BIFROST_2(acc7, src7, weight);\n#endif /* NUM_ELEM_ITERATION_Y  */\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n#if NUM_ELEM_ITERATION_Y >= 1\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n#endif\n#if NUM_ELEM_ITERATION_Y >= 2\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n#endif\n\n#if NUM_ELEM_ITERATION_Y >= 4\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#endif\n\n#if NUM_ELEM_ITERATION_Y >= 8\n    acc4.s0 += bias;\n    acc4.s1 += bias;\n    acc4.s2 += bias;\n    acc4.s3 += bias;\n    acc5.s0 += bias;\n    acc5.s1 += bias;\n    acc5.s2 += bias;\n    acc5.s3 += bias;\n    acc6.s0 += bias;\n    acc6.s1 += bias;\n    acc6.s2 += bias;\n    acc6.s3 += bias;\n    acc7.s0 += bias;\n    acc7.s1 += bias;\n    acc7.s2 += bias;\n    acc7.s3 += bias;\n#endif /* NUM_ELEM_ITERATION_Y  > 8 */\n#endif /* defined(HAS_BIAS) */\n    \n#if NUM_ELEM_ITERATION_Y == 1\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 2\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 4\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 8\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n    vstore4(acc4, 0, (__global float *)(dst.ptr + 4 * dst_stride_y));\n    vstore4(acc5, 0, (__global float *)(dst.ptr + 5 * dst_stride_y));\n    vstore4(acc6, 0, (__global float *)(dst.ptr + 6 * dst_stride_y));\n    vstore4(acc7, 0, (__global float *)(dst.ptr + 7 * dst_stride_y));\n#endif\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_4(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_4(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n#if NUM_ELEM_ITERATION_Y == 8\n    float4 acc4 = 0.0f;\n    float4 acc5 = 0.0f;\n    float4 acc6 = 0.0f;\n    float4 acc7 = 0.0f;\n#endif\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr);\n#ifdef  OVERLAP\n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc0, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc1, src1, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc2, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc3, src1, weight);\n#if NUM_ELEM_ITERATION_Y == 8\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc4, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc5, src1, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc6, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc7, src1, weight);\n#endif\n\n\n#else\n   // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc0, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc1, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc2, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc3, src0, weight);\n#if NUM_ELEM_ITERATION_Y == 8\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc4, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc5, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc6, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc7, src0, weight);\n\n#endif /*NUM_ELEM_ITERATION_Y*/\n#endif /*INTERLEAVE8 */\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#if NUM_ELEM_ITERATION_Y == 8\n    acc4.s0 += bias;\n    acc4.s1 += bias;\n    acc4.s2 += bias;\n    acc4.s3 += bias;\n    acc5.s0 += bias;\n    acc5.s1 += bias;\n    acc5.s2 += bias;\n    acc5.s3 += bias;\n    acc6.s0 += bias;\n    acc6.s1 += bias;\n    acc6.s2 += bias;\n    acc6.s3 += bias;\n    acc7.s0 += bias;\n    acc7.s1 += bias;\n    acc7.s2 += bias;\n    acc7.s3 += bias;\n#endif /*NUM_ELEM_ITERATION_Y */\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n#if NUM_ELEM_ITERATION_Y == 8\n    vstore4(acc4, 0, (__global float *)(dst.ptr + 4 * dst_stride_y));\n    vstore4(acc5, 0, (__global float *)(dst.ptr + 5 * dst_stride_y));\n    vstore4(acc6, 0, (__global float *)(dst.ptr + 6 * dst_stride_y));\n    vstore4(acc7, 0, (__global float *)(dst.ptr + 7 * dst_stride_y));\n#endif /*NUM_ELEM_ITERATION_Y*/\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_1(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_1(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float acc0 = 0.0f;\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr); \n        // Load values from row0 of input tensor\n        float src0 = *((__global float *)(src_addr));\n        acc0 = mad(src0, weight, acc0);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n    acc0    += bias;\n#endif /* defined(HAS_BIAS) */\n     *((__global float *)dst.ptr) = acc0;\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n#define CONVOLUTION1x1_BIFROST_7(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_7(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n//    float4 acc2 = 0.0f;\n//    float4 acc3 = 0.0f;\n\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n//x=4 (see float4 acc), y=2 see how many src, w=4 see float4 w\n    for(ushort d = 0; d < (ushort)(WEIGHTS_DEPTH/4); ++d)\n    {\n        // Load the weights\n        float4 weight = vload4(0,(__global float *)(weights_addr)); \n\n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s0); \n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s0); \n\n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s1); \n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s1);\n    \n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s2);\n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s2);              \n\n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s3);\n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s3);\n\n//        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s0);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s1);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s2);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s3);\n      \n        src_addr += src_stride_z;\n        weights_addr +=  (4*weights_stride_z);\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n/*    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n*/\n\n\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n//    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n//    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n\n"
    }, 
    "program": "0x55a2b63700", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe74171b0"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.166552", 
      "end": "2018-02-09T10:36:49.203730"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63700", 
    "call": "clBuildProgram", 
    "options": " -DNUM_ELEM_ITERATION_Y=2 -DWEIGHTS_DEPTH=512 -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a2b51800", 
    "name": "direct_convolution1x1_f32_bifrost_7", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.203860", 
      "end": "2018-02-09T10:36:49.250147"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63700", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74171ec"
  }, 
  {
    "buffer": "0x55a330c400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.250308", 
      "end": "2018-02-09T10:36:49.250487"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741792c", 
    "size": 1048576
  }, 
  {
    "buffer": "0x55a330c000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.250898", 
      "end": "2018-02-09T10:36:49.250978"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a2b51600", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.251067", 
      "end": "2018-02-09T10:36:49.251299"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x55a3470610", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.251326", 
      "end": "2018-02-09T10:36:49.251336"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a330bc00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.251358", 
      "end": "2018-02-09T10:36:49.251369"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a330b800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.251633", 
      "end": "2018-02-09T10:36:49.251645"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a330b400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.251757", 
      "end": "2018-02-09T10:36:49.251767"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a330b000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.251868", 
      "end": "2018-02-09T10:36:49.251879"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a330ac00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.251979", 
      "end": "2018-02-09T10:36:49.252068"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a2b51400", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.252143", 
      "end": "2018-02-09T10:36:49.252258"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e2c"
  }, 
  {
    "buffer": "0x55a330a800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.252290", 
      "end": "2018-02-09T10:36:49.252368"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b9c", 
    "size": 458752
  }, 
  {
    "buffer": "0x55a330a400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.252392", 
      "end": "2018-02-09T10:36:49.252477"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 557056
  }, 
  {
    "kernel": "0x55a2b51200", 
    "name": "depthwise_convolution_3x3", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.252614", 
      "end": "2018-02-09T10:36:49.252763"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63e00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741737c"
  }, 
  {
    "kernel": "0x55a2b51000", 
    "name": "fill_image_borders_constant", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.252808", 
      "end": "2018-02-09T10:36:49.252918"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63d00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741736c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51000", 
    "arg_value_ptr": "0x7fe74175d4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.252942", 
      "end": "2018-02-09T10:36:49.252951"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0e000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51000", 
    "arg_value_ptr": "0x7fe74175d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.252966", 
      "end": "2018-02-09T10:36:49.252972"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0e000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51000", 
    "arg_value_ptr": "0x7fe74175e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.252990", 
      "end": "2018-02-09T10:36:49.252997"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000000000000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51000", 
    "arg_value_ptr": "0x7fe74175e4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.253012", 
      "end": "2018-02-09T10:36:49.253017"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 11
  }, 
  {
    "buffer": "0x55a330a000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.253035", 
      "end": "2018-02-09T10:36:49.253046"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741790c", 
    "size": 18432
  }, 
  {
    "kernel": "0x55a2b50e00", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.253257", 
      "end": "2018-02-09T10:36:49.253476"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x55a36a4910", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.253501", 
      "end": "2018-02-09T10:36:49.253509"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a3309c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.253529", 
      "end": "2018-02-09T10:36:49.253539"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3309800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.253651", 
      "end": "2018-02-09T10:36:49.253663"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3309400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.253772", 
      "end": "2018-02-09T10:36:49.253782"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3309000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.253887", 
      "end": "2018-02-09T10:36:49.253898"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3657400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.254003", 
      "end": "2018-02-09T10:36:49.254081"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a2b50c00", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.254130", 
      "end": "2018-02-09T10:36:49.254264"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e0c"
  }, 
  {
    "buffer": "0x55a3657000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.254294", 
      "end": "2018-02-09T10:36:49.254384"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a2b50a00", 
    "name": "direct_convolution1x1_f32_bifrost_7", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.254457", 
      "end": "2018-02-09T10:36:49.254603"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63700", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74171ec"
  }, 
  {
    "buffer": "0x55a3656c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.254638", 
      "end": "2018-02-09T10:36:49.254776"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741792c", 
    "size": 1048576
  }, 
  {
    "buffer": "0x55a3656800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.255068", 
      "end": "2018-02-09T10:36:49.255158"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a2b50800", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.255207", 
      "end": "2018-02-09T10:36:49.255436"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x55a3685c60", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.255460", 
      "end": "2018-02-09T10:36:49.255468"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a3656400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.255489", 
      "end": "2018-02-09T10:36:49.255500"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3656000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.255762", 
      "end": "2018-02-09T10:36:49.255773"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3655c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.255881", 
      "end": "2018-02-09T10:36:49.255891"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3655800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.255997", 
      "end": "2018-02-09T10:36:49.256008"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3655400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.256111", 
      "end": "2018-02-09T10:36:49.256186"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a2b50600", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.256242", 
      "end": "2018-02-09T10:36:49.256356"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e2c"
  }, 
  {
    "buffer": "0x55a3655000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.256383", 
      "end": "2018-02-09T10:36:49.256471"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b9c", 
    "size": 458752
  }, 
  {
    "buffer": "0x55a3654c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.256495", 
      "end": "2018-02-09T10:36:49.256582"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 557056
  }, 
  {
    "kernel": "0x55a2b50400", 
    "name": "depthwise_convolution_3x3", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.256679", 
      "end": "2018-02-09T10:36:49.256829"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63e00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741737c"
  }, 
  {
    "kernel": "0x55a2b50200", 
    "name": "fill_image_borders_constant", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.256878", 
      "end": "2018-02-09T10:36:49.256967"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63d00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741736c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50200", 
    "arg_value_ptr": "0x7fe74175d4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.256991", 
      "end": "2018-02-09T10:36:49.256997"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0e000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50200", 
    "arg_value_ptr": "0x7fe74175d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.257014", 
      "end": "2018-02-09T10:36:49.257021"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0e000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50200", 
    "arg_value_ptr": "0x7fe74175e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.257038", 
      "end": "2018-02-09T10:36:49.257045"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000000000000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50200", 
    "arg_value_ptr": "0x7fe74175e4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.257091", 
      "end": "2018-02-09T10:36:49.257097"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 11
  }, 
  {
    "buffer": "0x55a3654800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.257116", 
      "end": "2018-02-09T10:36:49.257164"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741790c", 
    "size": 18432
  }, 
  {
    "kernel": "0x55a2b50000", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.257316", 
      "end": "2018-02-09T10:36:49.257528"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x55a3683030", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.257554", 
      "end": "2018-02-09T10:36:49.257561"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a3654400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.257579", 
      "end": "2018-02-09T10:36:49.257590"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3654000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.257701", 
      "end": "2018-02-09T10:36:49.257712"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3653c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.257817", 
      "end": "2018-02-09T10:36:49.257828"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3653800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.257932", 
      "end": "2018-02-09T10:36:49.257942"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3653400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.258048", 
      "end": "2018-02-09T10:36:49.258116"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a360c000", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.258166", 
      "end": "2018-02-09T10:36:49.258326"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e0c"
  }, 
  {
    "buffer": "0x55a3653000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.258361", 
      "end": "2018-02-09T10:36:49.258457"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a360be00", 
    "name": "direct_convolution1x1_f32_bifrost_7", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.258517", 
      "end": "2018-02-09T10:36:49.258690"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63700", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74171ec"
  }, 
  {
    "buffer": "0x55a3652c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.258728", 
      "end": "2018-02-09T10:36:49.258870"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741792c", 
    "size": 1048576
  }, 
  {
    "buffer": "0x55a3652800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.259173", 
      "end": "2018-02-09T10:36:49.259252"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a360bc00", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.259306", 
      "end": "2018-02-09T10:36:49.259534"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x55a32cf650", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.259569", 
      "end": "2018-02-09T10:36:49.259576"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a3652400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.259598", 
      "end": "2018-02-09T10:36:49.259607"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3652000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.259874", 
      "end": "2018-02-09T10:36:49.259885"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3651c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.259991", 
      "end": "2018-02-09T10:36:49.260002"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3651800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.260104", 
      "end": "2018-02-09T10:36:49.260116"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3651400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.260220", 
      "end": "2018-02-09T10:36:49.260304"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a360ba00", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.260362", 
      "end": "2018-02-09T10:36:49.260471"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e2c"
  }, 
  {
    "buffer": "0x55a3651000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.260502", 
      "end": "2018-02-09T10:36:49.260583"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b9c", 
    "size": 458752
  }, 
  {
    "buffer": "0x55a3650c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.260608", 
      "end": "2018-02-09T10:36:49.260697"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 557056
  }, 
  {
    "kernel": "0x55a360b800", 
    "name": "depthwise_convolution_3x3", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.260801", 
      "end": "2018-02-09T10:36:49.260967"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63e00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741737c"
  }, 
  {
    "kernel": "0x55a360b600", 
    "name": "fill_image_borders_constant", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.261016", 
      "end": "2018-02-09T10:36:49.261128"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63d00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741736c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b600", 
    "arg_value_ptr": "0x7fe74175d4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.261154", 
      "end": "2018-02-09T10:36:49.261161"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0e000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b600", 
    "arg_value_ptr": "0x7fe74175d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.261178", 
      "end": "2018-02-09T10:36:49.261185"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0e000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b600", 
    "arg_value_ptr": "0x7fe74175e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.261204", 
      "end": "2018-02-09T10:36:49.261211"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000000000000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b600", 
    "arg_value_ptr": "0x7fe74175e4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.261228", 
      "end": "2018-02-09T10:36:49.261233"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 11
  }, 
  {
    "buffer": "0x55a3650800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.261253", 
      "end": "2018-02-09T10:36:49.261264"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741790c", 
    "size": 18432
  }, 
  {
    "kernel": "0x55a360b400", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.261407", 
      "end": "2018-02-09T10:36:49.261643"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x55a301e780", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.261672", 
      "end": "2018-02-09T10:36:49.261680"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a3650400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.261703", 
      "end": "2018-02-09T10:36:49.261714"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3650000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.261832", 
      "end": "2018-02-09T10:36:49.261843"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a364fc00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.261958", 
      "end": "2018-02-09T10:36:49.261969"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a364f800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.262076", 
      "end": "2018-02-09T10:36:49.262087"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a364f400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.262194", 
      "end": "2018-02-09T10:36:49.262269"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a360b200", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.262331", 
      "end": "2018-02-09T10:36:49.262477"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e0c"
  }, 
  {
    "buffer": "0x55a364f000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.262514", 
      "end": "2018-02-09T10:36:49.262595"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a360b000", 
    "name": "direct_convolution1x1_f32_bifrost_7", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.262656", 
      "end": "2018-02-09T10:36:49.262821"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63700", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74171ec"
  }, 
  {
    "buffer": "0x55a364ec00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.262857", 
      "end": "2018-02-09T10:36:49.262992"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741792c", 
    "size": 1048576
  }, 
  {
    "buffer": "0x55a364e800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.263291", 
      "end": "2018-02-09T10:36:49.263375"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a360ae00", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.263426", 
      "end": "2018-02-09T10:36:49.263678"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x55a3147e40", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.263708", 
      "end": "2018-02-09T10:36:49.263717"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a364e400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.263743", 
      "end": "2018-02-09T10:36:49.263752"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a364e000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.264021", 
      "end": "2018-02-09T10:36:49.264033"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a364dc00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.264139", 
      "end": "2018-02-09T10:36:49.264150"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a364d800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.264253", 
      "end": "2018-02-09T10:36:49.264264"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a364d400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.264368", 
      "end": "2018-02-09T10:36:49.264448"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a360ac00", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.264503", 
      "end": "2018-02-09T10:36:49.264648"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e2c"
  }, 
  {
    "buffer": "0x55a364d000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.264681", 
      "end": "2018-02-09T10:36:49.264871"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b9c", 
    "size": 458752
  }, 
  {
    "buffer": "0x55a364cc00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.264900", 
      "end": "2018-02-09T10:36:49.265180"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 557056
  }, 
  {
    "kernel": "0x55a360aa00", 
    "name": "depthwise_convolution_3x3", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.265307", 
      "end": "2018-02-09T10:36:49.265495"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63e00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741737c"
  }, 
  {
    "kernel": "0x55a360a800", 
    "name": "fill_image_borders_constant", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.265543", 
      "end": "2018-02-09T10:36:49.265637"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63d00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741736c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a800", 
    "arg_value_ptr": "0x7fe74175d4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.265663", 
      "end": "2018-02-09T10:36:49.265671"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0e000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a800", 
    "arg_value_ptr": "0x7fe74175d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.265689", 
      "end": "2018-02-09T10:36:49.265695"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0e000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a800", 
    "arg_value_ptr": "0x7fe74175e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.265713", 
      "end": "2018-02-09T10:36:49.265718"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000000000000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a800", 
    "arg_value_ptr": "0x7fe74175e4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.265734", 
      "end": "2018-02-09T10:36:49.265740"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 11
  }, 
  {
    "buffer": "0x55a364c800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.265761", 
      "end": "2018-02-09T10:36:49.265771"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741790c", 
    "size": 18432
  }, 
  {
    "kernel": "0x55a360a600", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.265930", 
      "end": "2018-02-09T10:36:49.266175"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x55a36468e0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.266204", 
      "end": "2018-02-09T10:36:49.266212"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a364c400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.266235", 
      "end": "2018-02-09T10:36:49.266246"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a364c000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.266364", 
      "end": "2018-02-09T10:36:49.266374"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a364bc00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.266480", 
      "end": "2018-02-09T10:36:49.266491"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a364b800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.266604", 
      "end": "2018-02-09T10:36:49.266615"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a364b400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.266720", 
      "end": "2018-02-09T10:36:49.266944"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a360a400", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.267012", 
      "end": "2018-02-09T10:36:49.267194"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e0c"
  }, 
  {
    "buffer": "0x55a364b000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.267229", 
      "end": "2018-02-09T10:36:49.267452"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a360a200", 
    "name": "direct_convolution1x1_f32_bifrost_7", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.267535", 
      "end": "2018-02-09T10:36:49.267704"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63700", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74171ec"
  }, 
  {
    "buffer": "0x55a364ac00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.267741", 
      "end": "2018-02-09T10:36:49.268203"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741792c", 
    "size": 1048576
  }, 
  {
    "buffer": "0x55a364a800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.268540", 
      "end": "2018-02-09T10:36:49.268742"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a360a000", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.268811", 
      "end": "2018-02-09T10:36:49.269094"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x55a3765130", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.269133", 
      "end": "2018-02-09T10:36:49.269141"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a364a400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.269165", 
      "end": "2018-02-09T10:36:49.269175"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a364a000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.269460", 
      "end": "2018-02-09T10:36:49.269475"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3649c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.269590", 
      "end": "2018-02-09T10:36:49.269599"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3649800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.269978", 
      "end": "2018-02-09T10:36:49.269990"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3649400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.270118", 
      "end": "2018-02-09T10:36:49.270328"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 458752
  }, 
  {
    "kernel": "0x55a3609e00", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.270407", 
      "end": "2018-02-09T10:36:49.270561"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e2c"
  }, 
  {
    "buffer": "0x55a3649000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.270600", 
      "end": "2018-02-09T10:36:49.270822"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b9c", 
    "size": 458752
  }, 
  {
    "buffer": "0x55a3648c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.270858", 
      "end": "2018-02-09T10:36:49.271099"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 557056
  }, 
  {
    "kernel": "0x55a3609c00", 
    "name": "depthwise_convolution_3x3", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.271247", 
      "end": "2018-02-09T10:36:49.271448"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63b00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741737c"
  }, 
  {
    "kernel": "0x55a3609a00", 
    "name": "fill_image_borders_constant", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.271506", 
      "end": "2018-02-09T10:36:49.271604"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64100", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741736c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609a00", 
    "arg_value_ptr": "0x7fe74175d4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.271630", 
      "end": "2018-02-09T10:36:49.271638"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0e000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609a00", 
    "arg_value_ptr": "0x7fe74175d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.271670", 
      "end": "2018-02-09T10:36:49.271677"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0e000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609a00", 
    "arg_value_ptr": "0x7fe74175e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.271697", 
      "end": "2018-02-09T10:36:49.271704"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000000000000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609a00", 
    "arg_value_ptr": "0x7fe74175e4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.271720", 
      "end": "2018-02-09T10:36:49.271727"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 11
  }, 
  {
    "buffer": "0x55a3648800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.271748", 
      "end": "2018-02-09T10:36:49.271763"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741790c", 
    "size": 18432
  }, 
  {
    "kernel": "0x55a3609800", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.272177", 
      "end": "2018-02-09T10:36:49.272415"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x55a37959d0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.272441", 
      "end": "2018-02-09T10:36:49.272450"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a3648400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.272475", 
      "end": "2018-02-09T10:36:49.272484"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3648000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.272610", 
      "end": "2018-02-09T10:36:49.272620"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a3647c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.272958", 
      "end": "2018-02-09T10:36:49.272969"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a37b6000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.273117", 
      "end": "2018-02-09T10:36:49.273153"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 2048
  }, 
  {
    "buffer": "0x55a37b5c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.273491", 
      "end": "2018-02-09T10:36:49.273500"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 114688
  }, 
  {
    "kernel": "0x55a3609600", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.273563", 
      "end": "2018-02-09T10:36:49.273736"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e0c"
  }, 
  {
    "buffer": "0x55a37b5800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.273768", 
      "end": "2018-02-09T10:36:49.273894"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 114688
  }, 
  {
    "kernel": "0x55a3609400", 
    "name": "direct_convolution1x1_f32_bifrost_7", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.273972", 
      "end": "2018-02-09T10:36:49.274158"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63700", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74171ec"
  }, 
  {
    "buffer": "0x55a37b5400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.274201", 
      "end": "2018-02-09T10:36:49.275064"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741792c", 
    "size": 2097152
  }, 
  {
    "buffer": "0x55a37b5000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.276045", 
      "end": "2018-02-09T10:36:49.276074"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 131072
  }, 
  {
    "kernel": "0x55a3609200", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.276146", 
      "end": "2018-02-09T10:36:49.276431"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x55a37d5fa0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.276469", 
      "end": "2018-02-09T10:36:49.276478"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a37b4c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.276506", 
      "end": "2018-02-09T10:36:49.276516"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 4096
  }, 
  {
    "buffer": "0x55a37b4800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.276976", 
      "end": "2018-02-09T10:36:49.276989"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 4096
  }, 
  {
    "buffer": "0x55a37b4400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.277604", 
      "end": "2018-02-09T10:36:49.277616"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 4096
  }, 
  {
    "buffer": "0x55a37b4000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.278201", 
      "end": "2018-02-09T10:36:49.278220"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 4096
  }, 
  {
    "buffer": "0x55a37b3c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.278586", 
      "end": "2018-02-09T10:36:49.278739"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 262144
  }, 
  {
    "kernel": "0x55a3609000", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.278830", 
      "end": "2018-02-09T10:36:49.278986"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e2c"
  }, 
  {
    "buffer": "0x55a37b3800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.279029", 
      "end": "2018-02-09T10:36:49.279165"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b9c", 
    "size": 229376
  }, 
  {
    "buffer": "0x55a37b3400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.279198", 
      "end": "2018-02-09T10:36:49.279431"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 522240
  }, 
  {
    "kernel": "0x55a3608e00", 
    "name": "depthwise_convolution_3x3", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.279534", 
      "end": "2018-02-09T10:36:49.279735"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63e00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741737c"
  }, 
  {
    "kernel": "0x55a3608c00", 
    "name": "fill_image_borders_constant", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.279803", 
      "end": "2018-02-09T10:36:49.279905"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63d00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741736c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608c00", 
    "arg_value_ptr": "0x7fe74175d4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.279935", 
      "end": "2018-02-09T10:36:49.279943"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "07000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608c00", 
    "arg_value_ptr": "0x7fe74175d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.279963", 
      "end": "2018-02-09T10:36:49.279969"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "07000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608c00", 
    "arg_value_ptr": "0x7fe74175e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.279999", 
      "end": "2018-02-09T10:36:49.280006"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000000000000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608c00", 
    "arg_value_ptr": "0x7fe74175e4", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.280025", 
      "end": "2018-02-09T10:36:49.280030"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 11
  }, 
  {
    "buffer": "0x55a37b3000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.280053", 
      "end": "2018-02-09T10:36:49.280067"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741790c", 
    "size": 36864
  }, 
  {
    "kernel": "0x55a3608a00", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.280507", 
      "end": "2018-02-09T10:36:49.280771"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x55a38086d0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.280801", 
      "end": "2018-02-09T10:36:49.280808"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a37b2c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.280841", 
      "end": "2018-02-09T10:36:49.280852"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 4096
  }, 
  {
    "buffer": "0x55a37b2800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.281451", 
      "end": "2018-02-09T10:36:49.281466"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 4096
  }, 
  {
    "buffer": "0x55a37b2400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.282052", 
      "end": "2018-02-09T10:36:49.282065"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 4096
  }, 
  {
    "buffer": "0x55a37b2000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.282448", 
      "end": "2018-02-09T10:36:49.282462"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 4096
  }, 
  {
    "buffer": "0x55a37b1c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.282839", 
      "end": "2018-02-09T10:36:49.282985"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 229376
  }, 
  {
    "kernel": "0x55a3608800", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.283065", 
      "end": "2018-02-09T10:36:49.283224"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e0c"
  }, 
  {
    "buffer": "0x55a37b1800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.283276", 
      "end": "2018-02-09T10:36:49.283415"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 229376
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe74171b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.287621", 
      "end": "2018-02-09T10:36:49.287651"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe74171ac", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#if defined(FIXED_POINT_POSITION)\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n\n#define ADD_OP(a, b) ADD_SAT_OP_EXPAND((a), (b), DATA_TYPE_PROMOTED, 8)\n#define MUL_OP(a, b) MUL_SAT_OP_EXPAND(CONVERT((a), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), CONVERT((b), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), DATA_TYPE_PROMOTED, 8, FIXED_POINT_POSITION)\n\n// There is no need to have a larger intermediate type for qs32 because all the arguments are already promoted\nMULQ_SAT_IMPL(qs32x8, qs32x8)\n\n#else /* FIXED_POINT_POSITION */\n#undef CONVERT_SAT\n\n#define ADD_OP(a, b) ((a) + (b))\n#define MUL_OP(a, b) ((a) * (b))\n#define CONVERT_SAT(a, b) ((a))\n\n#endif /* FIXED_POINT_POSITION */\n\n#if defined(DATA_TYPE) && defined(DATA_SIZE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if STRIDE_X == 3\n#define INPUT_PIXEL_STR(data_size) extract_input_stride3_##data_size\n#define INPUT_PIXEL(data_size) INPUT_PIXEL_STR(data_size)\n#elif STRIDE_X == 2\n#define INPUT_PIXEL(data_size) extract_input_stride2\n#elif STRIDE_X == 1\n#define INPUT_PIXEL(data_size) extract_input_stride1\n#else /* STRIDE_X not equals 1, 2 or 3 */\n#error \"Only support strides 1, 2 and 3\"\n#endif /* STRIDE_X == 3 */\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 1.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride1(__global const DATA_TYPE *input_pixel)\n{\n    return vload8(0, input_pixel);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 2.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride2(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp = vload16(0, input_pixel);\n    return temp.s02468ace;\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 32-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_32(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp1 = vload4(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp2 = vload4(0, input_pixel + 6);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp3 = vload4(0, input_pixel + 12);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp4 = vload4(0, input_pixel + 18);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s03, temp2.s03, temp3.s03, temp4.s03);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 16-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_16(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp1 = vload8(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp2 = vload8(0, input_pixel + 8);\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp3 = vload8(0, input_pixel + 16);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s036, temp2.s147, temp3.s25);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 8-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_8(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp1 = vload16(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp2 = vload16(0, input_pixel + 12);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s0369, temp2.s0369);\n}\n\n/** This kernel performs a direct convolution to convolve the low three dimensions.\n *\n * @note The data type must be passed at compile time using -DDATA_TYPE: e.g. -DDATA_TYPE=float\n * @note The data size must be passed at compile time using -DDATA_SIZE e.g. -DDATA_SIZE=32\n * @note The convolution stride x must be passed at compile time using -DSTRIDE_X e.g. -DSTRIDE_X=1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases will be added to the convolution -DHAS_BIAS has to be passed to append the final matrix with 1 in each row.\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F16/F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    Image    src     = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D weights = CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(weights);\n    Tensor3D dst     = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n#endif /* defined(HAS_BIAS) */\n\n    VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)\n    pixels = 0;\n\n    const uint z_index = get_global_id(2);\n\n    weights.ptr += z_index * weights_stride_w;\n\n    for(volatile int d = 0; d < WEIGHTS_DEPTH; ++d)\n    {\n        DATA_TYPE weight = *(__global DATA_TYPE *)weights.ptr;\n        VEC_DATA_TYPE(DATA_TYPE, 8)\n        input_pixel = INPUT_PIXEL(DATA_SIZE)((__global DATA_TYPE *)src.ptr);\n        pixels      = ADD_OP(pixels, MUL_OP((VEC_DATA_TYPE(DATA_TYPE, 8))weight, input_pixel));\n        src.ptr += src_stride_z;\n        weights.ptr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    pixels = ADD_OP(pixels, (VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)) * ((__global DATA_TYPE *)(vector_offset(&biases, z_index))));\n#endif /* defined(HAS_BIAS) */\n\n    vstore8(CONVERT_SAT(pixels, VEC_DATA_TYPE(DATA_TYPE, 8)), 0, (__global DATA_TYPE *)dst.ptr);\n}\n#endif // defined(DATA_TYPE) && defined(DATA_SIZE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n//    printf(\"get_local_size = %u %d %d- %d\\n\", get_local_size(0), get_local_size(1), get_local_size(2));\n//get_enqueued_local_size\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr); \n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n\n        CONVOLUTION1x1_BIFROST(acc0, src0, weight);\n        CONVOLUTION1x1_BIFROST(acc1, src1, weight);\n        CONVOLUTION1x1_BIFROST(acc2, src2, weight);\n        CONVOLUTION1x1_BIFROST(acc3, src3, weight);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_2(acc, src, weight_value) \\\n    ({                                                   \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);      \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);      \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);      \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);      \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_2(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n#if NUM_ELEM_ITERATION_Y == 1\n    float4 acc0 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 2 \n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 4\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 8\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n    float4 acc4 = 0.0f;\n    float4 acc5 = 0.0f;\n    float4 acc6 = 0.0f;\n    float4 acc7 = 0.0f;\n#endif /*NUM_ELEM_ITERATION_Y */\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr);\n\n        // Load values from row0 of input tensor\n#if NUM_ELEM_ITERATION_Y == 1\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 2\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 4 \n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 8 \n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        float4 src4 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        float4 src5 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        float4 src6 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        float4 src7 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n#endif /* NUM_ELEM_ITERATION_Y */\n\n#if NUM_ELEM_ITERATION_Y == 1\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n#elif NUM_ELEM_ITERATION_Y == 2\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n#elif NUM_ELEM_ITERATION_Y == 4\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n         CONVOLUTION1x1_BIFROST_2(acc2, src2, weight);\n         CONVOLUTION1x1_BIFROST_2(acc3, src3, weight);\n#elif NUM_ELEM_ITERATION_Y == 8\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n         CONVOLUTION1x1_BIFROST_2(acc2, src2, weight);\n         CONVOLUTION1x1_BIFROST_2(acc3, src3, weight);\n         CONVOLUTION1x1_BIFROST_2(acc4, src4, weight);\n         CONVOLUTION1x1_BIFROST_2(acc5, src5, weight);\n         CONVOLUTION1x1_BIFROST_2(acc6, src6, weight);\n         CONVOLUTION1x1_BIFROST_2(acc7, src7, weight);\n#endif /* NUM_ELEM_ITERATION_Y  */\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n#if NUM_ELEM_ITERATION_Y >= 1\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n#endif\n#if NUM_ELEM_ITERATION_Y >= 2\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n#endif\n\n#if NUM_ELEM_ITERATION_Y >= 4\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#endif\n\n#if NUM_ELEM_ITERATION_Y >= 8\n    acc4.s0 += bias;\n    acc4.s1 += bias;\n    acc4.s2 += bias;\n    acc4.s3 += bias;\n    acc5.s0 += bias;\n    acc5.s1 += bias;\n    acc5.s2 += bias;\n    acc5.s3 += bias;\n    acc6.s0 += bias;\n    acc6.s1 += bias;\n    acc6.s2 += bias;\n    acc6.s3 += bias;\n    acc7.s0 += bias;\n    acc7.s1 += bias;\n    acc7.s2 += bias;\n    acc7.s3 += bias;\n#endif /* NUM_ELEM_ITERATION_Y  > 8 */\n#endif /* defined(HAS_BIAS) */\n    \n#if NUM_ELEM_ITERATION_Y == 1\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 2\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 4\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 8\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n    vstore4(acc4, 0, (__global float *)(dst.ptr + 4 * dst_stride_y));\n    vstore4(acc5, 0, (__global float *)(dst.ptr + 5 * dst_stride_y));\n    vstore4(acc6, 0, (__global float *)(dst.ptr + 6 * dst_stride_y));\n    vstore4(acc7, 0, (__global float *)(dst.ptr + 7 * dst_stride_y));\n#endif\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_4(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_4(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n#if NUM_ELEM_ITERATION_Y == 8\n    float4 acc4 = 0.0f;\n    float4 acc5 = 0.0f;\n    float4 acc6 = 0.0f;\n    float4 acc7 = 0.0f;\n#endif\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr);\n#ifdef  OVERLAP\n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc0, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc1, src1, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc2, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc3, src1, weight);\n#if NUM_ELEM_ITERATION_Y == 8\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc4, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc5, src1, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc6, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc7, src1, weight);\n#endif\n\n\n#else\n   // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc0, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc1, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc2, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc3, src0, weight);\n#if NUM_ELEM_ITERATION_Y == 8\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc4, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc5, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc6, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc7, src0, weight);\n\n#endif /*NUM_ELEM_ITERATION_Y*/\n#endif /*INTERLEAVE8 */\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#if NUM_ELEM_ITERATION_Y == 8\n    acc4.s0 += bias;\n    acc4.s1 += bias;\n    acc4.s2 += bias;\n    acc4.s3 += bias;\n    acc5.s0 += bias;\n    acc5.s1 += bias;\n    acc5.s2 += bias;\n    acc5.s3 += bias;\n    acc6.s0 += bias;\n    acc6.s1 += bias;\n    acc6.s2 += bias;\n    acc6.s3 += bias;\n    acc7.s0 += bias;\n    acc7.s1 += bias;\n    acc7.s2 += bias;\n    acc7.s3 += bias;\n#endif /*NUM_ELEM_ITERATION_Y */\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n#if NUM_ELEM_ITERATION_Y == 8\n    vstore4(acc4, 0, (__global float *)(dst.ptr + 4 * dst_stride_y));\n    vstore4(acc5, 0, (__global float *)(dst.ptr + 5 * dst_stride_y));\n    vstore4(acc6, 0, (__global float *)(dst.ptr + 6 * dst_stride_y));\n    vstore4(acc7, 0, (__global float *)(dst.ptr + 7 * dst_stride_y));\n#endif /*NUM_ELEM_ITERATION_Y*/\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_1(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_1(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float acc0 = 0.0f;\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr); \n        // Load values from row0 of input tensor\n        float src0 = *((__global float *)(src_addr));\n        acc0 = mad(src0, weight, acc0);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n    acc0    += bias;\n#endif /* defined(HAS_BIAS) */\n     *((__global float *)dst.ptr) = acc0;\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n#define CONVOLUTION1x1_BIFROST_7(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_7(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n//    float4 acc2 = 0.0f;\n//    float4 acc3 = 0.0f;\n\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n//x=4 (see float4 acc), y=2 see how many src, w=4 see float4 w\n    for(ushort d = 0; d < (ushort)(WEIGHTS_DEPTH/4); ++d)\n    {\n        // Load the weights\n        float4 weight = vload4(0,(__global float *)(weights_addr)); \n\n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s0); \n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s0); \n\n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s1); \n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s1);\n    \n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s2);\n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s2);              \n\n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s3);\n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s3);\n\n//        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s0);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s1);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s2);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s3);\n      \n        src_addr += src_stride_z;\n        weights_addr +=  (4*weights_stride_z);\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n/*    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n*/\n\n\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n//    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n//    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n\n"
    }, 
    "program": "0x55a2b63600", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe74171b0"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.287686", 
      "end": "2018-02-09T10:36:49.322812"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63600", 
    "call": "clBuildProgram", 
    "options": " -DNUM_ELEM_ITERATION_Y=2 -DWEIGHTS_DEPTH=1024 -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a3608600", 
    "name": "direct_convolution1x1_f32_bifrost_7", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.322999", 
      "end": "2018-02-09T10:36:49.367650"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63600", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74171ec"
  }, 
  {
    "buffer": "0x55a37b1400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.367858", 
      "end": "2018-02-09T10:36:49.369529"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741792c", 
    "size": 4194304
  }, 
  {
    "buffer": "0x55a37b1000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.371765", 
      "end": "2018-02-09T10:36:49.371928"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 262144
  }, 
  {
    "kernel": "0x55a3608400", 
    "name": "batchnormalization_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.372040", 
      "end": "2018-02-09T10:36:49.372271"
    }, 
    "errcode": 0, 
    "program": "0x55a2b64000", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741756c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x55a39578a0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.372306", 
      "end": "2018-02-09T10:36:49.372316"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6f12833a", 
    "arg_index": 32
  }, 
  {
    "buffer": "0x55a37b0c00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.372345", 
      "end": "2018-02-09T10:36:49.372358"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 4096
  }, 
  {
    "buffer": "0x55a37b0800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.374417", 
      "end": "2018-02-09T10:36:49.374437"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 4096
  }, 
  {
    "buffer": "0x55a37b0400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.375619", 
      "end": "2018-02-09T10:36:49.375633"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 4096
  }, 
  {
    "buffer": "0x55a37b0000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.376182", 
      "end": "2018-02-09T10:36:49.376203"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe741791c", 
    "size": 4096
  }, 
  {
    "buffer": "0x55a37afc00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.376970", 
      "end": "2018-02-09T10:36:49.377131"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b7c", 
    "size": 262144
  }, 
  {
    "kernel": "0x55a3608200", 
    "name": "activation_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.377239", 
      "end": "2018-02-09T10:36:49.377371"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63f00", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7416e2c"
  }, 
  {
    "buffer": "0x55a37af800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.377418", 
      "end": "2018-02-09T10:36:49.377544"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417b9c", 
    "size": 229376
  }, 
  {
    "buffer": "0x55a37af400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.377582", 
      "end": "2018-02-09T10:36:49.377747"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 368640
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe7417938", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.381138", 
      "end": "2018-02-09T10:36:49.381165"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe741792c", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#ifdef FIXED_POINT_POSITION\n\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n\n#if defined(POOL_AVG)\n#define POOL_OP(x, y) add_sat(x, y)\n#else /* POOL_AVG */\n#define POOL_OP(x, y) (max((x), (y)))\n#endif /* POOL_AVG */\n\n#define DIV_OP1(x, y) DIV_SAT_OP_EXPAND((x), (y), DATA_TYPE, FIXED_POINT_POSITION)\n#define DIV_OP(x, y) DIV_OP1(x, y << FIXED_POINT_POSITION)\n#define SQRT_OP(x) DIV_OP1((1 << FIXED_POINT_POSITION), (INVSQRT_OP_EXPAND((x), DATA_TYPE, 1, FIXED_POINT_POSITION)))\n\n#if defined(POOL_L2)\n#define POW2_OP(x, vec_size) MUL_SAT_OP_EXPAND((x), (x), DATA_TYPE, vec_size, FIXED_POINT_POSITION)\n#else /* defined(POOL_L2) */\n#define POW2_OP(x, vec_size) (x)\n#endif /* defined(POOL_L2) */\n\n#else /* FIXED_POINT_POSITION */\n\n#if defined(POOL_AVG) || defined(POOL_L2)\n#define POOL_OP(x, y) ((x) + (y))\n#else /* defined(POOL_AVG) || defined(POOL_L2) */\n#define POOL_OP(x, y) (fmax((x), (y)))\n#endif /* defined(POOL_AVG) || defined(POOL_L2) */\n\n#if defined(POOL_L2)\n#define POW2_OP(x, vec_size) ((x) * (x))\n#else /* defined(POOL_L2) */\n#define POW2_OP(x, vec_size) (x)\n#endif /* defined(POOL_L2) */\n\n#define DIV_OP(x, y) (x * (1.f / y))\n#define SQRT_OP(x) sqrt((x))\n\n#endif /* FIXED_POINT_POSITION */\n\n#if STRIDE_X == 1\n#define POOLING3x3(res, input, output) POOLING3x3_STRIDE1(res, input, output)\n#elif STRIDE_X == 2 /* STRIDE_X == 1 */\n#define POOLING3x3(res, input, output) POOLING3x3_STRIDE2(res, input, output)\n#elif STRIDE_X == 3 /* STRIDE_X not equals 1 or 2 */\n#define POOLING3x3(res, input, output) POOLING3x3_STRIDE3(res, input, output)\n#endif /* STRIDE_X == 3 */\n\n#define POOLING3x3_STRIDE1(res, input, output)                                                                                               \\\n    ({                                                                                                                                       \\\n        VEC_DATA_TYPE(DATA_TYPE, 4)                                                                                                          \\\n        data00 = vload4(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 0, 0));                                                          \\\n        VEC_DATA_TYPE(DATA_TYPE, 2)                                                                                                          \\\n        data01 = vload2(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 0, 0) + 4);                                                      \\\n        VEC_DATA_TYPE(DATA_TYPE, 4)                                                                                                          \\\n        data10 = vload4(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 1, 0));                                                          \\\n        VEC_DATA_TYPE(DATA_TYPE, 2)                                                                                                          \\\n        data11 = vload2(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 1, 0) + 4);                                                      \\\n        VEC_DATA_TYPE(DATA_TYPE, 4)                                                                                                          \\\n        data20 = vload4(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 2, 0));                                                          \\\n        VEC_DATA_TYPE(DATA_TYPE, 2)                                                                                                          \\\n        data21 = vload2(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 2, 0) + 4);                                                      \\\n        data00 = POW2_OP(data00, 4);                                                                                                         \\\n        data01 = POW2_OP(data01, 2);                                                                                                         \\\n        data10 = POW2_OP(data10, 4);                                                                                                         \\\n        data11 = POW2_OP(data11, 2);                                                                                                         \\\n        data20 = POW2_OP(data20, 4);                                                                                                         \\\n        data21 = POW2_OP(data21, 2);                                                                                                         \\\n        \\\n        VEC_DATA_TYPE(DATA_TYPE, 8)                                                                                                          \\\n        values00 = (VEC_DATA_TYPE(DATA_TYPE, 8))(data00.s01212323);                                                                          \\\n        VEC_DATA_TYPE(DATA_TYPE, 4)                                                                                                          \\\n        values01 = (VEC_DATA_TYPE(DATA_TYPE, 4))(data01.s0, data00.s3, data01.s01);                                                          \\\n        VEC_DATA_TYPE(DATA_TYPE, 8)                                                                                                          \\\n        values10 = (VEC_DATA_TYPE(DATA_TYPE, 8))(data10.s01212323);                                                                          \\\n        VEC_DATA_TYPE(DATA_TYPE, 4)                                                                                                          \\\n        values11 = (VEC_DATA_TYPE(DATA_TYPE, 4))(data11.s0, data10.s3, data11.s01);                                                          \\\n        VEC_DATA_TYPE(DATA_TYPE, 8)                                                                                                          \\\n        values20 = (VEC_DATA_TYPE(DATA_TYPE, 8))(data20.s01212323);                                                                          \\\n        VEC_DATA_TYPE(DATA_TYPE, 4)                                                                                                          \\\n        values21 = (VEC_DATA_TYPE(DATA_TYPE, 4))(data21.s0, data20.s3, data21.s01);                                                          \\\n        \\\n        values00 = POOL_OP(values00, values10);                                                                                              \\\n        values01 = POOL_OP(values01, values11);                                                                                              \\\n        values00 = POOL_OP(values00, values20);                                                                                              \\\n        values01 = POOL_OP(values01, values21);                                                                                              \\\n        \\\n        res = POOL_OP((VEC_DATA_TYPE(DATA_TYPE, 4))(values00.s036, values01.s1), (VEC_DATA_TYPE(DATA_TYPE, 4))(values00.s147, values01.s2)); \\\n        res = POOL_OP(res, (VEC_DATA_TYPE(DATA_TYPE, 4))(values00.s25, values01.s03));                                                       \\\n    })\n\n#define POOLING3x3_STRIDE2(res, input, output)                                                                                               \\\n    ({                                                                                                                                       \\\n        VEC_DATA_TYPE(DATA_TYPE, 8)                                                                                                          \\\n        data00           = vload8(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 0, 0));                                                \\\n        DATA_TYPE data01 = *((__global DATA_TYPE *)tensor3D_offset(&input, 0, 0, 0) + 8);                                                    \\\n        VEC_DATA_TYPE(DATA_TYPE, 8)                                                                                                          \\\n        data10           = vload8(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 1, 0));                                                \\\n        DATA_TYPE data11 = *((__global DATA_TYPE *)tensor3D_offset(&input, 0, 1, 0) + 8);                                                    \\\n        VEC_DATA_TYPE(DATA_TYPE, 8)                                                                                                          \\\n        data20           = vload8(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 2, 0));                                                \\\n        DATA_TYPE data21 = *((__global DATA_TYPE *)tensor3D_offset(&input, 0, 2, 0) + 8);                                                    \\\n        data00           = POW2_OP(data00, 8);                                                                                               \\\n        data01           = POW2_OP(data01, 1);                                                                                               \\\n        data10           = POW2_OP(data10, 8);                                                                                               \\\n        data11           = POW2_OP(data11, 1);                                                                                               \\\n        data20           = POW2_OP(data20, 8);                                                                                               \\\n        data21           = POW2_OP(data21, 1);                                                                                               \\\n        \\\n        VEC_DATA_TYPE(DATA_TYPE, 8)                                                                                                          \\\n        values00 = (VEC_DATA_TYPE(DATA_TYPE, 8))(data00.s01223445);                                                                          \\\n        VEC_DATA_TYPE(DATA_TYPE, 4)                                                                                                          \\\n        values01 = (VEC_DATA_TYPE(DATA_TYPE, 4))(data00.s667, data01);                                                                       \\\n        VEC_DATA_TYPE(DATA_TYPE, 8)                                                                                                          \\\n        values10 = (VEC_DATA_TYPE(DATA_TYPE, 8))(data10.s01223445);                                                                          \\\n        VEC_DATA_TYPE(DATA_TYPE, 4)                                                                                                          \\\n        values11 = (VEC_DATA_TYPE(DATA_TYPE, 4))(data10.s667, data11);                                                                       \\\n        VEC_DATA_TYPE(DATA_TYPE, 8)                                                                                                          \\\n        values20 = (VEC_DATA_TYPE(DATA_TYPE, 8))(data20.s01223445);                                                                          \\\n        VEC_DATA_TYPE(DATA_TYPE, 4)                                                                                                          \\\n        values21 = (VEC_DATA_TYPE(DATA_TYPE, 4))(data20.s667, data21);                                                                       \\\n        \\\n        values00 = POOL_OP(values00, values10);                                                                                              \\\n        values01 = POOL_OP(values01, values11);                                                                                              \\\n        values00 = POOL_OP(values00, values20);                                                                                              \\\n        values01 = POOL_OP(values01, values21);                                                                                              \\\n        \\\n        res = POOL_OP((VEC_DATA_TYPE(DATA_TYPE, 4))(values00.s036, values01.s1), (VEC_DATA_TYPE(DATA_TYPE, 4))(values00.s147, values01.s2)); \\\n        res = POOL_OP(res, (VEC_DATA_TYPE(DATA_TYPE, 4))(values00.s25, values01.s03));                                                       \\\n    })\n\n#define POOLING3x3_STRIDE3(res, input, output)                                                                                       \\\n    ({                                                                                                                               \\\n        VEC_DATA_TYPE(DATA_TYPE, 8)                                                                                                  \\\n        data00 = vload8(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 0, 0));                                                  \\\n        VEC_DATA_TYPE(DATA_TYPE, 4)                                                                                                  \\\n        data01 = vload4(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 0, 0) + 8);                                              \\\n        VEC_DATA_TYPE(DATA_TYPE, 8)                                                                                                  \\\n        data10 = vload8(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 1, 0));                                                  \\\n        VEC_DATA_TYPE(DATA_TYPE, 4)                                                                                                  \\\n        data11 = vload4(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 1, 0) + 8);                                              \\\n        VEC_DATA_TYPE(DATA_TYPE, 8)                                                                                                  \\\n        data20 = vload8(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 2, 0));                                                  \\\n        VEC_DATA_TYPE(DATA_TYPE, 4)                                                                                                  \\\n        data21 = vload4(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 2, 0) + 8);                                              \\\n        data00 = POW2_OP(data00, 8);                                                                                                 \\\n        data01 = POW2_OP(data01, 4);                                                                                                 \\\n        data10 = POW2_OP(data10, 8);                                                                                                 \\\n        data11 = POW2_OP(data11, 4);                                                                                                 \\\n        data20 = POW2_OP(data20, 8);                                                                                                 \\\n        data21 = POW2_OP(data21, 4);                                                                                                 \\\n        \\\n        data00 = POOL_OP(data00, data10);                                                                                            \\\n        data01 = POOL_OP(data01, data11);                                                                                            \\\n        data00 = POOL_OP(data00, data20);                                                                                            \\\n        data01 = POOL_OP(data01, data21);                                                                                            \\\n        \\\n        res = POOL_OP((VEC_DATA_TYPE(DATA_TYPE, 4))(data00.s036, data01.s1), (VEC_DATA_TYPE(DATA_TYPE, 4))(data00.s147, data01.s2)); \\\n        res = POOL_OP(res, (VEC_DATA_TYPE(DATA_TYPE, 4))(data00.s25, data01.s03));                                                   \\\n    })\n\nDATA_TYPE calculate_avg_scale(const int pool_size, const int upper_bound_w, const int upper_bound_h,\n                              const int pad_x, const int pad_y, const int stride_x, const int stride_y)\n{\n    int       start_x = get_global_id(0) * stride_x - pad_x;\n    int       start_y = get_global_id(1) * stride_y - pad_y;\n    const int end_x   = min(start_x + pool_size, upper_bound_w);\n    const int end_y   = min(start_y + pool_size, upper_bound_h);\n#if defined(EXCLUDE_PADDING)\n    start_x = max(0, start_x);\n    start_y = max(0, start_y);\n#endif /* defined(EXCLUDE_PADDING) */\n    return ((end_y - start_y) * (end_x - start_x));\n}\n\n/** Performs a pooling function of pool size equal to 2.\n *\n * @note Datatype must be passed using -DDATA_TYPE e.g. -DDATA_TYPE=float. Supported data types are QS8/QS16/F16/F32;\n * @note In case of average pooling the following information must be passed at compile time:\n *       -DPOOL_AVG or -DPOOL_L2 must be provided otherwise max pooling will be performed.\n *       -DMAX_WIDTH and -DMAX_HEIGHT which are the maximum accessible indeces in x and y dimensions (width + pad)\n *       -DSTRIDE_X and -DSTRIDE_Y which are the steps of the window along the x and y directions\n *       -DPAD_X and -DPAD_Y which are the pooling paddings in x and y dimension\n *\n * @param[in]  input_ptr                            Pointer to the source image. Supported data types: QS8/QS16/F16/F32\n * @param[in]  input_stride_x                       Stride of the source image in X dimension (in bytes)\n * @param[in]  input_step_x                         input_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  input_stride_y                       Stride of the source image in Y dimension (in bytes)\n * @param[in]  input_step_y                         input_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  input_stride_z                       Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  input_step_z                         input_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  input_offset_first_element_in_bytes  The offset of the first element in the source image\n * @param[out] output_ptr                           Pointer to the destination image. Supported data types: same as @p input_ptr\n * @param[in]  output_stride_x                      Stride of the destination image in X dimension (in bytes)\n * @param[in]  output_step_x                        output_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  output_stride_y                      Stride of the destination image in Y dimension (in bytes)\n * @param[in]  output_step_y                        output_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  output_stride_z                      Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  output_step_z                        output_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  output_offset_first_element_in_bytes The offset of the first element in the destination image\n */\n__kernel void pooling_layer_2(\n    TENSOR3D_DECLARATION(input),\n    TENSOR3D_DECLARATION(output))\n{\n    // Get pixels pointer\n    Tensor3D input  = CONVERT_TO_TENSOR3D_STRUCT(input);\n    Tensor3D output = CONVERT_TO_TENSOR3D_STRUCT(output);\n\n    // Load data\n    VEC_DATA_TYPE(DATA_TYPE, 2)\n    data0 = vload2(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 0, 0));\n    VEC_DATA_TYPE(DATA_TYPE, 2)\n    data1 = vload2(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 1, 0));\n\n#if defined(POOL_L2)\n    // Raise to power of 2 for L2 Pooling\n    data0 = POW2_OP(data0, 2);\n    data1 = POW2_OP(data1, 2);\n#endif /* defined(POOL_L2) */\n\n    // Perform calculations\n    data0         = POOL_OP(data0, data1);\n    DATA_TYPE res = POOL_OP(data0.s0, data0.s1);\n\n#if defined(POOL_AVG) || defined(POOL_L2)\n    // Divide by pool region in case of average or l2 pooling\n    res = DIV_OP(res, calculate_avg_scale(2, MAX_WIDTH, MAX_HEIGHT, PAD_X, PAD_Y, STRIDE_X, STRIDE_Y));\n#endif /* defined(POOL_AVG) || defined(POOL_L2) */\n\n#if defined(POOL_L2)\n    // Take square root of the result in L2 pooling\n    res = SQRT_OP(res);\n#endif /* defined(POOL_L2) */\n\n    // Store result\n    *(__global DATA_TYPE *)output.ptr = res;\n}\n\n/** Performs a pooling function of pool size equal to 3\n *\n * @note Datatype must be passed using -DDATA_TYPE e.g. -DDATA_TYPE=float. Supported data types are QS8/QS16/F16/F32;\n * @note In case of average pooling the following information must be passed at compile time:\n *       -DPOOL_AVG or -DPOOL_L2 must be provided otherwise max pooling will be performed.\n *       -DMAX_WIDTH and -DMAX_HEIGHT which are the maximum accessible indeces in x and y dimensions (width + pad)\n *       -DSTRIDE_X and -DSTRIDE_Y which are the steps of the window along the x and y directions\n *       -DPAD_X and -DPAD_Y which are the pooling paddings in x and y dimension\n *\n * @param[in]  input_ptr                            Pointer to the source image. Supported data types: QS8/QS16/F16/F32\n * @param[in]  input_stride_x                       Stride of the source image in X dimension (in bytes)\n * @param[in]  input_step_x                         input_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  input_stride_y                       Stride of the source image in Y dimension (in bytes)\n * @param[in]  input_step_y                         input_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  input_stride_z                       Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  input_step_z                         input_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  input_offset_first_element_in_bytes  The offset of the first element in the source image\n * @param[out] output_ptr                           Pointer to the destination image. Supported data types: same as @p input_ptr\n * @param[in]  output_stride_x                      Stride of the destination image in X dimension (in bytes)\n * @param[in]  output_step_x                        output_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  output_stride_y                      Stride of the destination image in Y dimension (in bytes)\n * @param[in]  output_step_y                        output_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  output_stride_z                      Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  output_step_z                        output_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  output_offset_first_element_in_bytes The offset of the first element in the destination image\n */\n__kernel void pooling_layer_3(\n    TENSOR3D_DECLARATION(input),\n    TENSOR3D_DECLARATION(output))\n{\n    // Get pixels pointer\n    Tensor3D input  = CONVERT_TO_TENSOR3D_STRUCT(input);\n    Tensor3D output = CONVERT_TO_TENSOR3D_STRUCT(output);\n\n    // Load data\n    VEC_DATA_TYPE(DATA_TYPE, 3)\n    data0 = vload3(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 0, 0));\n    VEC_DATA_TYPE(DATA_TYPE, 3)\n    data1 = vload3(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 1, 0));\n    VEC_DATA_TYPE(DATA_TYPE, 3)\n    data2 = vload3(0, (__global DATA_TYPE *)tensor3D_offset(&input, 0, 2, 0));\n\n#if defined(POOL_L2)\n    // Raise to power of 2 for L2 Pooling\n    data0 = POW2_OP(data0, 3);\n    data1 = POW2_OP(data1, 3);\n    data2 = POW2_OP(data2, 3);\n#endif /* defined(POOL_L2) */\n\n    // Perform calculations\n    data0         = POOL_OP(data0, data1);\n    data0         = POOL_OP(data0, data2);\n    DATA_TYPE res = POOL_OP(POOL_OP(data0.s0, data0.s1), data0.s2);\n\n#if defined(POOL_AVG) || defined(POOL_L2)\n    // Divide by pool region in case of average pooling\n    res = DIV_OP(res, calculate_avg_scale(3, MAX_WIDTH, MAX_HEIGHT, PAD_X, PAD_Y, STRIDE_X, STRIDE_Y));\n#endif /* defined(POOL_AVG) || defined(POOL_L2) */\n\n#if defined(POOL_L2)\n    // Take square root of the result in L2 pooling\n    res = SQRT_OP(res);\n#endif /* defined(POOL_L2) */\n\n    // Store result\n    *(__global DATA_TYPE *)output.ptr = res;\n}\n\n#if defined(POOLING3x3) && !defined(FIXED_POINT_POSITION)\n\n#define CONVERT_OP(data_type) convert_##data_type##4\n#define CONVERT_VECTOR4(data_type) CONVERT_OP(data_type)\n\nVEC_DATA_TYPE(DATA_TYPE, 4)\ncalculate_avg_scale4(const int pool_size, const int upper_bound_w, const int upper_bound_h,\n                     const int pad_x, const int pad_y, const int stride_x, const int stride_y)\n{\n    int4       start_x = ((int4)get_global_id(0) * 4 + (int4)(0, 1, 2, 3)) * (int4)stride_x - (int4)pad_x;\n    int        start_y = get_global_id(1) * stride_y - pad_y;\n    const int4 end_x   = min(start_x + (int4)pool_size, (int4)upper_bound_w);\n    const int  end_y   = min(start_y + pool_size, upper_bound_h);\n#if defined(EXCLUDE_PADDING)\n    start_x = max((int4)0, start_x);\n    start_y = max(0, start_y);\n#endif /* defined(EXCLUDE_PADDING) */\n    return (VEC_DATA_TYPE(DATA_TYPE, 4))(1.f) / CONVERT_VECTOR4(DATA_TYPE)(((int4)(end_y - start_y)) * (end_x - start_x));\n}\n\n/** Performs an optimized pooling function of pool size equal to 3 when the stride_x is less equal than 3\n *\n * @note Datatype must be passed using -DDATA_TYPE e.g. -DDATA_TYPE=float. Supported data types are QS8/QS16/F16/F32;\n * @note In case of average pooling the following information must be passed at compile time:\n *       -DPOOL_AVG or -DPOOL_L2 must be provided otherwise max pooling will be performed.\n *       -DMAX_WIDTH and -DMAX_HEIGHT which are the maximum accessible indeces in x and y dimensions (width + pad)\n *       -DSTRIDE_X and -DSTRIDE_Y which are the steps of the window along the x and y directions\n *       -DPAD_X and -DPAD_Y which are the pooling paddings in x and y dimension\n *\n * @param[in]  input_ptr                            Pointer to the source image. Supported data types: F16/F32\n * @param[in]  input_stride_x                       Stride of the source image in X dimension (in bytes)\n * @param[in]  input_step_x                         input_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  input_stride_y                       Stride of the source image in Y dimension (in bytes)\n * @param[in]  input_step_y                         input_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  input_stride_z                       Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  input_step_z                         input_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  input_offset_first_element_in_bytes  The offset of the first element in the source image\n * @param[out] output_ptr                           Pointer to the destination image. Supported data types: same as @p input_ptr\n * @param[in]  output_stride_x                      Stride of the destination image in X dimension (in bytes)\n * @param[in]  output_step_x                        output_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  output_stride_y                      Stride of the destination image in Y dimension (in bytes)\n * @param[in]  output_step_y                        output_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  output_stride_z                      Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  output_step_z                        output_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  output_offset_first_element_in_bytes The offset of the first element in the destination image\n */\n__kernel void pooling_layer_optimized_3(\n    TENSOR3D_DECLARATION(input),\n    TENSOR3D_DECLARATION(output))\n{\n    // Get pixels pointer\n    Tensor3D input  = CONVERT_TO_TENSOR3D_STRUCT(input);\n    Tensor3D output = CONVERT_TO_TENSOR3D_STRUCT(output);\n\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    res;\n\n    // Perform pooling 3x3 for 4 output elements\n    POOLING3x3(res, input, output);\n\n#if defined(POOL_AVG) || defined(POOL_L2)\n    // Divide by pool region in case of average pooling\n    res *= calculate_avg_scale4(3, MAX_WIDTH, MAX_HEIGHT, PAD_X, PAD_Y, STRIDE_X, STRIDE_Y);\n#endif /* defined(POOL_AVG) || defined(POOL_L2) */\n\n#if defined(POOL_L2)\n    // Take square root of the result in L2 pooling\n    res = SQRT_OP(res);\n#endif /* defined(POOL_L2) */\n\n    vstore4(res, 0, (__global DATA_TYPE *)output.ptr);\n}\n#endif // defined(POOLING3x3) && !defined(FIXED_POINT_POSITION)\n\n#if defined(POOL_SIZE)\n\n// Set the initial value for the pooling operation accordingly with the data type\n#if defined(POOL_AVG) || defined(POOL_L2)\n#define INITIAL_VALUE 0\n#else /* defined(POOL_AVG) || defined(POOL_L2) */\n#ifdef FIXED_POINT_POSITION\n#define MIN_VAL_EXPAND(type) type##_MIN\n#define MIN_VAL(type) MIN_VAL_EXPAND(type)\n#define INITIAL_VALUE MIN_VAL(DATA_TYPE)\n#else // FIXED_POINT_POSITION\n#if FP16\n#define INITIAL_VALUE -HALF_MAX\n#else // FP16\n#define INITIAL_VALUE -FLT_MAX\n#endif // FP16\n#endif // FIXED_POINT_POSITION\n\n#endif // POOL_AVG\n\n/** Performs a pooling function of pool size equal to N\n *\n * @note Datatype must be passed using -DDATA_TYPE e.g. -DDATA_TYPE=float. Supported data types are QS8/QS16/F16/F32;\n * @note -DFP16 must be passed at compile time if half float data type is used\n * @note Pool size must be passed using -DPOOL_SIZE e.g. -DPOOL_SIZE=13;\n * @note In case of average pooling the following information must be passed at compile time:\n *       -DPOOL_AVG must be provided otherwise max pooling will be performed.\n *       -DMAX_WIDTH and -DMAX_HEIGHT which are the maximum accessible indeces in x and y dimensions (width + pad)\n *       -DSTRIDE_X and -DSTRIDE_Y which are the steps of the window along the x and y directions\n *       -DPAD_X and -DPAD_Y which are the pooling paddings in x and y dimension\n *\n * @param[in]  input_ptr                            Pointer to the source image. Supported data types: QS8/QS16/F16/F32\n * @param[in]  input_stride_x                       Stride of the source image in X dimension (in bytes)\n * @param[in]  input_step_x                         input_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  input_stride_y                       Stride of the source image in Y dimension (in bytes)\n * @param[in]  input_step_y                         input_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  input_stride_z                       Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  input_step_z                         input_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  input_offset_first_element_in_bytes  The offset of the first element in the source image\n * @param[out] output_ptr                           Pointer to the destination image. Supported data types: same as @p input_ptr\n * @param[in]  output_stride_x                      Stride of the destination image in X dimension (in bytes)\n * @param[in]  output_step_x                        output_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  output_stride_y                      Stride of the destination image in Y dimension (in bytes)\n * @param[in]  output_step_y                        output_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  output_stride_z                      Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  output_step_z                        output_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  output_offset_first_element_in_bytes The offset of the first element in the destination image\n */\n__kernel void pooling_layer_N(\n    TENSOR3D_DECLARATION(input),\n    TENSOR3D_DECLARATION(output))\n{\n    // Get pixels pointer\n    Tensor3D input  = CONVERT_TO_TENSOR3D_STRUCT(input);\n    Tensor3D output = CONVERT_TO_TENSOR3D_STRUCT(output);\n\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    vdata           = INITIAL_VALUE;\n    DATA_TYPE sdata = INITIAL_VALUE;\n\n    // Load data\n    for(int y = 0; y < POOL_SIZE; y++)\n    {\n        int x = 0;\n        for(; x <= ((int)POOL_SIZE - 8); x += 8)\n        {\n            VEC_DATA_TYPE(DATA_TYPE, 8)\n            data0 = vload8(0, (__global DATA_TYPE *)tensor3D_offset(&input, x, y, 0));\n#if defined(POOL_L2)\n            // Raise to power of 2 for L2 Pooling\n            data0 *= data0;\n#endif /* defined(POOL_L2) */\n            vdata = POOL_OP(vdata, data0);\n        }\n\n        // Leftover\n        for(; x < (int)POOL_SIZE; ++x)\n        {\n            DATA_TYPE data0 = *((__global DATA_TYPE *)tensor3D_offset(&input, x, y, 0));\n#if defined(POOL_L2)\n            // Raise to power of 2 for L2 Pooling\n            data0 *= data0;\n#endif /* defined(POOL_L2) */\n            sdata = POOL_OP(sdata, data0);\n        }\n    }\n\n    // Reduce result\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    reduce4 = POOL_OP(vdata.s0123, vdata.s4567);\n    VEC_DATA_TYPE(DATA_TYPE, 2)\n    reduce2       = POOL_OP(reduce4.s01, reduce4.s23);\n    DATA_TYPE res = POOL_OP(reduce2.s0, reduce2.s1);\n    res           = POOL_OP(res, sdata);\n\n#if defined(POOL_AVG) || defined(POOL_L2)\n    // Divide by pool region in case of average pooling\n    res = DIV_OP(res, calculate_avg_scale(POOL_SIZE, MAX_WIDTH, MAX_HEIGHT, PAD_X, PAD_Y, STRIDE_X, STRIDE_Y));\n#endif /* defined(POOL_AVG) || defined(POOL_L2) */\n\n#if defined(POOL_L2)\n    // Take square root of the result in L2 pooling\n    res = SQRT_OP(res);\n#endif /* defined(POOL_L2) */\n\n    // Store result\n    *(__global DATA_TYPE *)output.ptr = res;\n}\n#endif // defined(POOL_SIZE)\n\n"
    }, 
    "program": "0x55a2b63500", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe7417930"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.381204", 
      "end": "2018-02-09T10:36:49.403502"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63500", 
    "call": "clBuildProgram", 
    "options": " -DDATA_TYPE=float -DMAX_HEIGHT=7 -DMAX_WIDTH=7 -DPAD_X=0 -DPAD_Y=0 -DPOOL_AVG -DPOOL_SIZE=7 -DSTRIDE_X=1 -DSTRIDE_Y=1 -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a3608000", 
    "name": "pooling_layer_N", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.403689", 
      "end": "2018-02-09T10:36:49.431026"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63500", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741796c"
  }, 
  {
    "buffer": "0x55a37af000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.431221", 
      "end": "2018-02-09T10:36:49.431367"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 229376
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe7417578", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.435290", 
      "end": "2018-02-09T10:36:49.435335"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe741756c", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#if defined(FIXED_POINT_POSITION)\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n\n#define ADD_OP(a, b) ADD_SAT_OP_EXPAND((a), (b), DATA_TYPE_PROMOTED, 8)\n#define MUL_OP(a, b) MUL_SAT_OP_EXPAND(CONVERT((a), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), CONVERT((b), VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)), DATA_TYPE_PROMOTED, 8, FIXED_POINT_POSITION)\n\n// There is no need to have a larger intermediate type for qs32 because all the arguments are already promoted\nMULQ_SAT_IMPL(qs32x8, qs32x8)\n\n#else /* FIXED_POINT_POSITION */\n#undef CONVERT_SAT\n\n#define ADD_OP(a, b) ((a) + (b))\n#define MUL_OP(a, b) ((a) * (b))\n#define CONVERT_SAT(a, b) ((a))\n\n#endif /* FIXED_POINT_POSITION */\n\n#if defined(DATA_TYPE) && defined(DATA_SIZE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if STRIDE_X == 3\n#define INPUT_PIXEL_STR(data_size) extract_input_stride3_##data_size\n#define INPUT_PIXEL(data_size) INPUT_PIXEL_STR(data_size)\n#elif STRIDE_X == 2\n#define INPUT_PIXEL(data_size) extract_input_stride2\n#elif STRIDE_X == 1\n#define INPUT_PIXEL(data_size) extract_input_stride1\n#else /* STRIDE_X not equals 1, 2 or 3 */\n#error \"Only support strides 1, 2 and 3\"\n#endif /* STRIDE_X == 3 */\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 1.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride1(__global const DATA_TYPE *input_pixel)\n{\n    return vload8(0, input_pixel);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 2.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride2(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp = vload16(0, input_pixel);\n    return temp.s02468ace;\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 32-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_32(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp1 = vload4(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp2 = vload4(0, input_pixel + 6);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp3 = vload4(0, input_pixel + 12);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    temp4 = vload4(0, input_pixel + 18);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s03, temp2.s03, temp3.s03, temp4.s03);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 16-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_16(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp1 = vload8(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp2 = vload8(0, input_pixel + 8);\n    VEC_DATA_TYPE(DATA_TYPE, 8)\n    temp3 = vload8(0, input_pixel + 16);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s036, temp2.s147, temp3.s25);\n}\n\n/** Extracts a 1D horizontal vector from the input tensor with stride as 3 and 8-bit data size.\n *\n * @param[in] input_pixel Pointer to the first pixel.\n *\n * @return extracted input pixels.\n */\ninline VEC_DATA_TYPE(DATA_TYPE, 8) extract_input_stride3_8(__global const DATA_TYPE *input_pixel)\n{\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp1 = vload16(0, input_pixel);\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    temp2 = vload16(0, input_pixel + 12);\n    return (VEC_DATA_TYPE(DATA_TYPE, 8))(temp1.s0369, temp2.s0369);\n}\n\n/** This kernel performs a direct convolution to convolve the low three dimensions.\n *\n * @note The data type must be passed at compile time using -DDATA_TYPE: e.g. -DDATA_TYPE=float\n * @note The data size must be passed at compile time using -DDATA_SIZE e.g. -DDATA_SIZE=32\n * @note The convolution stride x must be passed at compile time using -DSTRIDE_X e.g. -DSTRIDE_X=1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases will be added to the convolution -DHAS_BIAS has to be passed to append the final matrix with 1 in each row.\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F16/F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    Image    src     = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D weights = CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(weights);\n    Tensor3D dst     = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n#endif /* defined(HAS_BIAS) */\n\n    VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)\n    pixels = 0;\n\n    const uint z_index = get_global_id(2);\n\n    weights.ptr += z_index * weights_stride_w;\n\n    for(volatile int d = 0; d < WEIGHTS_DEPTH; ++d)\n    {\n        DATA_TYPE weight = *(__global DATA_TYPE *)weights.ptr;\n        VEC_DATA_TYPE(DATA_TYPE, 8)\n        input_pixel = INPUT_PIXEL(DATA_SIZE)((__global DATA_TYPE *)src.ptr);\n        pixels      = ADD_OP(pixels, MUL_OP((VEC_DATA_TYPE(DATA_TYPE, 8))weight, input_pixel));\n        src.ptr += src_stride_z;\n        weights.ptr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    pixels = ADD_OP(pixels, (VEC_DATA_TYPE(DATA_TYPE_PROMOTED, 8)) * ((__global DATA_TYPE *)(vector_offset(&biases, z_index))));\n#endif /* defined(HAS_BIAS) */\n\n    vstore8(CONVERT_SAT(pixels, VEC_DATA_TYPE(DATA_TYPE, 8)), 0, (__global DATA_TYPE *)dst.ptr);\n}\n#endif // defined(DATA_TYPE) && defined(DATA_SIZE) && defined(STRIDE_X) && defined(WEIGHTS_DEPTH)\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n//    printf(\"get_local_size = %u %d %d- %d\\n\", get_local_size(0), get_local_size(1), get_local_size(2));\n//get_enqueued_local_size\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr); \n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n\n        CONVOLUTION1x1_BIFROST(acc0, src0, weight);\n        CONVOLUTION1x1_BIFROST(acc1, src1, weight);\n        CONVOLUTION1x1_BIFROST(acc2, src2, weight);\n        CONVOLUTION1x1_BIFROST(acc3, src3, weight);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_2(acc, src, weight_value) \\\n    ({                                                   \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);      \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);      \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);      \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);      \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_2(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n#if NUM_ELEM_ITERATION_Y == 1\n    float4 acc0 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 2 \n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 4\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n#elif NUM_ELEM_ITERATION_Y == 8\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n    float4 acc4 = 0.0f;\n    float4 acc5 = 0.0f;\n    float4 acc6 = 0.0f;\n    float4 acc7 = 0.0f;\n#endif /*NUM_ELEM_ITERATION_Y */\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr);\n\n        // Load values from row0 of input tensor\n#if NUM_ELEM_ITERATION_Y == 1\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 2\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 4 \n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 8 \n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        float4 src4 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        float4 src5 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        float4 src6 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        float4 src7 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n#endif /* NUM_ELEM_ITERATION_Y */\n\n#if NUM_ELEM_ITERATION_Y == 1\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n#elif NUM_ELEM_ITERATION_Y == 2\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n#elif NUM_ELEM_ITERATION_Y == 4\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n         CONVOLUTION1x1_BIFROST_2(acc2, src2, weight);\n         CONVOLUTION1x1_BIFROST_2(acc3, src3, weight);\n#elif NUM_ELEM_ITERATION_Y == 8\n         CONVOLUTION1x1_BIFROST_2(acc0, src0, weight);\n         CONVOLUTION1x1_BIFROST_2(acc1, src1, weight);\n         CONVOLUTION1x1_BIFROST_2(acc2, src2, weight);\n         CONVOLUTION1x1_BIFROST_2(acc3, src3, weight);\n         CONVOLUTION1x1_BIFROST_2(acc4, src4, weight);\n         CONVOLUTION1x1_BIFROST_2(acc5, src5, weight);\n         CONVOLUTION1x1_BIFROST_2(acc6, src6, weight);\n         CONVOLUTION1x1_BIFROST_2(acc7, src7, weight);\n#endif /* NUM_ELEM_ITERATION_Y  */\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n#if NUM_ELEM_ITERATION_Y >= 1\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n#endif\n#if NUM_ELEM_ITERATION_Y >= 2\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n#endif\n\n#if NUM_ELEM_ITERATION_Y >= 4\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#endif\n\n#if NUM_ELEM_ITERATION_Y >= 8\n    acc4.s0 += bias;\n    acc4.s1 += bias;\n    acc4.s2 += bias;\n    acc4.s3 += bias;\n    acc5.s0 += bias;\n    acc5.s1 += bias;\n    acc5.s2 += bias;\n    acc5.s3 += bias;\n    acc6.s0 += bias;\n    acc6.s1 += bias;\n    acc6.s2 += bias;\n    acc6.s3 += bias;\n    acc7.s0 += bias;\n    acc7.s1 += bias;\n    acc7.s2 += bias;\n    acc7.s3 += bias;\n#endif /* NUM_ELEM_ITERATION_Y  > 8 */\n#endif /* defined(HAS_BIAS) */\n    \n#if NUM_ELEM_ITERATION_Y == 1\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 2\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 4\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n#elif NUM_ELEM_ITERATION_Y == 8\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n    vstore4(acc4, 0, (__global float *)(dst.ptr + 4 * dst_stride_y));\n    vstore4(acc5, 0, (__global float *)(dst.ptr + 5 * dst_stride_y));\n    vstore4(acc6, 0, (__global float *)(dst.ptr + 6 * dst_stride_y));\n    vstore4(acc7, 0, (__global float *)(dst.ptr + 7 * dst_stride_y));\n#endif\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_4(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_4(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n    float4 acc2 = 0.0f;\n    float4 acc3 = 0.0f;\n#if NUM_ELEM_ITERATION_Y == 8\n    float4 acc4 = 0.0f;\n    float4 acc5 = 0.0f;\n    float4 acc6 = 0.0f;\n    float4 acc7 = 0.0f;\n#endif\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w);\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr);\n#ifdef  OVERLAP\n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc0, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc1, src1, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc2, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc3, src1, weight);\n#if NUM_ELEM_ITERATION_Y == 8\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc4, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc5, src1, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc6, src0, weight);\n        CONVOLUTION1x1_BIFROST_4(acc7, src1, weight);\n#endif\n\n\n#else\n   // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc0, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc1, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc2, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc3, src0, weight);\n#if NUM_ELEM_ITERATION_Y == 8\n        src0 = vload4(0, (__global float *)(src_addr + 4 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc4, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 5 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc5, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 6 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc6, src0, weight);\n        src0 = vload4(0, (__global float *)(src_addr + 7 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_4(acc7, src0, weight);\n\n#endif /*NUM_ELEM_ITERATION_Y*/\n#endif /*INTERLEAVE8 */\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n#if NUM_ELEM_ITERATION_Y == 8\n    acc4.s0 += bias;\n    acc4.s1 += bias;\n    acc4.s2 += bias;\n    acc4.s3 += bias;\n    acc5.s0 += bias;\n    acc5.s1 += bias;\n    acc5.s2 += bias;\n    acc5.s3 += bias;\n    acc6.s0 += bias;\n    acc6.s1 += bias;\n    acc6.s2 += bias;\n    acc6.s3 += bias;\n    acc7.s0 += bias;\n    acc7.s1 += bias;\n    acc7.s2 += bias;\n    acc7.s3 += bias;\n#endif /*NUM_ELEM_ITERATION_Y */\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n#if NUM_ELEM_ITERATION_Y == 8\n    vstore4(acc4, 0, (__global float *)(dst.ptr + 4 * dst_stride_y));\n    vstore4(acc5, 0, (__global float *)(dst.ptr + 5 * dst_stride_y));\n    vstore4(acc6, 0, (__global float *)(dst.ptr + 6 * dst_stride_y));\n    vstore4(acc7, 0, (__global float *)(dst.ptr + 7 * dst_stride_y));\n#endif /*NUM_ELEM_ITERATION_Y*/\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n\n#define CONVOLUTION1x1_BIFROST_1(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_1(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float acc0 = 0.0f;\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n    for(ushort d = 0; d < (ushort)WEIGHTS_DEPTH; ++d)\n    {\n        // Load the weights\n        float weight = *((__global float *)weights_addr); \n        // Load values from row0 of input tensor\n        float src0 = *((__global float *)(src_addr));\n        acc0 = mad(src0, weight, acc0);\n\n        src_addr += src_stride_z;\n        weights_addr += weights_stride_z;\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n    acc0    += bias;\n#endif /* defined(HAS_BIAS) */\n     *((__global float *)dst.ptr) = acc0;\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n#if defined(WEIGHTS_DEPTH)\n#define CONVOLUTION1x1_BIFROST_7(acc, src, weight_value) \\\n    ({                                                 \\\n        acc.s0 = mad(src.s0, weight_value, acc.s0);    \\\n        acc.s1 = mad(src.s1, weight_value, acc.s1);    \\\n        acc.s2 = mad(src.s2, weight_value, acc.s2);    \\\n        acc.s3 = mad(src.s3, weight_value, acc.s3);    \\\n    })\n\n/** An optimized direct convolution 1x1 OpenCL kernel for Bifrost architectures when the data type is F32\n *\n * @note This OpenCL kernel works only with stride_x and stride_y equal to 1\n * @note The third dimensions of the weights tensors must be passed at compile time using -DWEIGHTS_DEPTH\n * @note In case biases, -DHAS_BIAS must to be passed at compile\n *\n * @param[in]  src_ptr                               Pointer to the source tensor. Supported data types: F32\n * @param[in]  src_stride_x                          Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                            src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                          Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                            src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                          Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                            src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes     The offset of the first element in the source tensor\n * @param[out] dst_ptr                               Pointer to the destination tensor. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                          Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                            dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                          Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                            dst_stride_y * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_stride_z                          Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                            dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes     The offset of the first element in the destination tensor\n * @param[in]  weights_ptr                           Pointer to the weights tensor. Supported data types: same as @p src_ptr\n * @param[in]  weights_stride_x                      Stride of the weights tensor in X dimension (in bytes)\n * @param[in]  weights_step_x                        weights_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  weights_stride_y                      Stride of the weights tensor in Y dimension (in bytes)\n * @param[in]  weights_step_y                        weights_stride_y * number of elements along y processed per workitem(in bytes)\n * @param[in]  weights_stride_z                      Stride of the weights tensor in Z dimension (in bytes)\n * @param[in]  weights_step_z                        weights_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  weights_offset_first_element_in_bytes The offset of the first element in the weights tensor\n * @param[in]  biases_ptr                            Pointer to the biases tensor. Same as @p src_ptr\n * @param[in]  biases_stride_x                       Stride of the biases tensor in X dimension (in bytes)\n * @param[in]  biases_step_x                         biases_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  biases_offset_first_element_in_bytes  The offset of the first element in the biases tensor\n * @param[in]  weights_stride_w                      Stride of the weights tensor in the 4th dimension\n */\n__kernel void direct_convolution1x1_f32_bifrost_7(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(weights),\n#ifdef HAS_BIAS\n    VECTOR_DECLARATION(biases),\n#endif /* defined(HAS_BIAS) */\n    unsigned int weights_stride_w)\n{\n    // Get the kernel index\n    const int kernel_index = get_global_id(2);\n    Image    src = CONVERT_TO_IMAGE_STRUCT(src);\n    Tensor3D dst = CONVERT_TO_TENSOR3D_STRUCT(dst);\n\n    float4 acc0 = 0.0f;\n    float4 acc1 = 0.0f;\n//    float4 acc2 = 0.0f;\n//    float4 acc3 = 0.0f;\n\n    // times step_w\n    __global uchar *weights_addr = (__global uchar *)(weights_ptr + weights_offset_first_element_in_bytes + kernel_index * weights_stride_w );\n    __global uchar *src_addr     = (__global uchar *)offset(&src, 0, 0);\n//x=4 (see float4 acc), y=2 see how many src, w=4 see float4 w\n    for(ushort d = 0; d < (ushort)(WEIGHTS_DEPTH/4); ++d)\n    {\n        // Load the weights\n        float4 weight = vload4(0,(__global float *)(weights_addr)); \n\n        // Load values from row0 of input tensor\n        float4 src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s0); \n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s0); \n\n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s1); \n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s1);\n    \n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s2);\n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s2);              \n\n        src_addr += src_stride_z;\n        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s3);\n        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s3);\n\n//        float4 src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        float4 src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        float4 src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s0);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s0);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s1);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s1);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s2);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s2);\n\n//        src_addr += src_stride_z;\n//        src0 = vload4(0, (__global float *)(src_addr + 0 * src_stride_y));\n//        src1 = vload4(0, (__global float *)(src_addr + 1 * src_stride_y));\n//        src2 = vload4(0, (__global float *)(src_addr + 2 * src_stride_y));\n//        src3 = vload4(0, (__global float *)(src_addr + 3 * src_stride_y));\n//        CONVOLUTION1x1_BIFROST_7(acc0, src0, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc1, src1, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc2, src2, weight.s3);\n//        CONVOLUTION1x1_BIFROST_7(acc3, src3, weight.s3);\n      \n        src_addr += src_stride_z;\n        weights_addr +=  (4*weights_stride_z);\n    }\n\n#ifdef HAS_BIAS\n    Vector biases = CONVERT_TO_VECTOR_STRUCT_NO_STEP(biases);\n\n    float bias = (float) * ((__global float *)(vector_offset(&biases, kernel_index)));\n\n    acc0.s0 += bias;\n    acc0.s1 += bias;\n    acc0.s2 += bias;\n    acc0.s3 += bias;\n    acc1.s0 += bias;\n    acc1.s1 += bias;\n    acc1.s2 += bias;\n    acc1.s3 += bias;\n/*    acc2.s0 += bias;\n    acc2.s1 += bias;\n    acc2.s2 += bias;\n    acc2.s3 += bias;\n    acc3.s0 += bias;\n    acc3.s1 += bias;\n    acc3.s2 += bias;\n    acc3.s3 += bias;\n*/\n\n\n#endif /* defined(HAS_BIAS) */\n\n    vstore4(acc0, 0, (__global float *)(dst.ptr + 0 * dst_stride_y));\n    vstore4(acc1, 0, (__global float *)(dst.ptr + 1 * dst_stride_y));\n//    vstore4(acc2, 0, (__global float *)(dst.ptr + 2 * dst_stride_y));\n//    vstore4(acc3, 0, (__global float *)(dst.ptr + 3 * dst_stride_y));\n\n}\n#endif // defined(WEIGHTS_DEPTH)\n\n\n\n"
    }, 
    "program": "0x55a2b63400", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe7417570"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.435436", 
      "end": "2018-02-09T10:36:49.472767"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63400", 
    "call": "clBuildProgram", 
    "options": " -DHAS_BIAS -DNUM_ELEM_ITERATION_Y=1 -DWEIGHTS_DEPTH=1024 -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a3607e00", 
    "name": "direct_convolution1x1_f32_bifrost_1", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.472946", 
      "end": "2018-02-09T10:36:49.493993"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63400", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74175ac"
  }, 
  {
    "buffer": "0x55a37aec00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.494197", 
      "end": "2018-02-09T10:36:49.495778"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417cec", 
    "size": 4100096
  }, 
  {
    "buffer": "0x55a37ae800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.497129", 
      "end": "2018-02-09T10:36:49.497148"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417cec", 
    "size": 4004
  }, 
  {
    "buffer": "0x55a37ae400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.499133", 
      "end": "2018-02-09T10:36:49.499150"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 4096
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe74179d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.500068", 
      "end": "2018-02-09T10:36:49.500081"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe74179cc", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n/** Perform tensor reshape\n *\n * @note Datatype should be given as a preprocessor argument using -DDATA_TYPE=type. e.g. -DDATA_TYPE=short\n *\n * @param[in]  input_ptr                            Pointer to the first source tensor. Supported data types: U8/S8/QS8/U16/S16/QS16/U32/S32/F16/F32\n * @param[in]  input_stride_x                       Stride of the first source tensor in X dimension (in bytes)\n * @param[in]  input_step_x                         input_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  input_stride_y                       Stride of the first source tensor in Y dimension (in bytes)\n * @param[in]  input_step_y                         input_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  input_stride_z                       Stride of the first source tensor in Z dimension (in bytes)\n * @param[in]  input_step_z                         input_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  input_offset_first_element_in_bytes  The offset of the first element in the first source tensor\n * @param[out] output_ptr                           Pointer to the destination tensor. Supported data types: same as @p input_ptr\n * @param[in]  output_stride_x                      Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  output_step_x                        output_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  output_stride_y                      Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  output_step_y                        output_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  output_stride_z                      Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  output_step_z                        output_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  output_offset_first_element_in_bytes The offset of the first element in the destination tensor\n * @param[in]  input_shape                          Input spatial shape\n * @param[in]  output_shape                         Output spatial shape\n */\n__kernel void reshape_layer(TENSOR3D_DECLARATION(input),\n                            TENSOR3D_DECLARATION(output),\n                            int2 input_shape,\n                            int2 output_shape)\n{\n    Tensor3D in  = CONVERT_TO_TENSOR3D_STRUCT(input);\n    Tensor3D out = CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(output);\n\n    int3 id = (int3)(get_global_id(0), get_global_id(1), get_global_id(2));\n\n    // Linearize index\n    int linear_idx = id.x + id.y * input_shape.x + id.z * input_shape.x * input_shape.y;\n\n    // Translate to output\n    int3 out_id;\n    out_id.x = linear_idx % output_shape.x;\n    out_id.y = (linear_idx / output_shape.x) % output_shape.y;\n    out_id.z = linear_idx / (output_shape.x * output_shape.y);\n\n    // Store result\n    *((__global DATA_TYPE *)tensor3D_offset(&out, out_id.x, out_id.y, out_id.z)) = *((__global DATA_TYPE *)in.ptr);\n}\n\n"
    }, 
    "program": "0x55a2b63300", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe74179d0"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.500106", 
      "end": "2018-02-09T10:36:49.509093"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63300", 
    "call": "clBuildProgram", 
    "options": " -DDATA_TYPE=float -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a3607c00", 
    "name": "reshape_layer", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.509264", 
      "end": "2018-02-09T10:36:49.523142"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63300", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe7417a0c"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417c40", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.523291", 
      "end": "2018-02-09T10:36:49.523300"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0100000001000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417c48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.523319", 
      "end": "2018-02-09T10:36:49.523324"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e903000001000000", 
    "arg_index": 17
  }, 
  {
    "buffer": "0x55a37ae000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.523370", 
      "end": "2018-02-09T10:36:49.523395"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f3c", 
    "size": 4004
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe7417438", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.526987", 
      "end": "2018-02-09T10:36:49.527033"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe741742c", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#ifdef FIXED_POINT_POSITION\n\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n#define MAX_OP(x, y, type, size) MAX_OP_EXPAND(x, y, type, size)\n#define ADD_OP(x, y, type, size) ADD_SAT_OP_EXPAND((x), (y), type, size)\n#define SUB_OP(x, y, type, size) SUB_SAT_OP_EXPAND((x), (y), type, size)\n#define MUL_OP(x, y, type, size) MUL_SAT_OP_EXPAND((x), (y), type, size, FIXED_POINT_POSITION)\n#define DIV_OP(x, y, type, size) DIV_SAT_OP_VEC_EXPAND((x), (y), type, size, FIXED_POINT_POSITION)\n#define EXP_OP(x, type, size) EXP_OP_EXPAND((x), type, size, FIXED_POINT_POSITION)\n\n#define MIN_VAL_EXPAND(type) type##_MIN\n#define MIN_VAL(type) MIN_VAL_EXPAND(type)\n#define MINVAL MIN_VAL(DATA_TYPE)\n#define SELECT_DATA_TYPE EXPAND(DATA_TYPE)\n\n#else /* FIXED_POINT_POSITION */\n\n#define MAX_OP(x, y, type, size) max((x), (y))\n#define ADD_OP(x, y, type, size) ((x) + (y))\n#define SUB_OP(x, y, type, size) ((x) - (y))\n#define MUL_OP(x, y, type, size) ((x) * (y))\n#define DIV_OP(x, y, type, size) ((x) / (y))\n#define EXP_OP(x, type, size) exp((x))\n\n#ifdef USE_F16\n#define MINVAL -HALF_MAX\n#define SELECT_DATA_TYPE short\n#else /* USE_F16 */\n#define MINVAL -FLT_MAX\n#define SELECT_DATA_TYPE int\n#endif /* USE_F16 */\n\n#endif /* FIXED_POINT_POSITION */\n\n/* Number of workitems in dimension 0. */\n#if !defined(GRID_SIZE)\n#define GRID_SIZE 1\n#endif /* !defined(GRID_SIZE) */\n\n/* Vector size, i.e. number of vector elements. */\n#if VECTOR_SIZE == 2\n__constant VEC_DATA_TYPE(DATA_TYPE, 2) type_min_ = (VEC_DATA_TYPE(DATA_TYPE, 2))(MINVAL);\n__constant uint2 idx__ = (uint2)(0, 1);\n\n#elif VECTOR_SIZE == 4\n__constant VEC_DATA_TYPE(DATA_TYPE, 4) type_min_ = (VEC_DATA_TYPE(DATA_TYPE, 4))(MINVAL);\n__constant uint4 idx__ = (uint4)(0, 1, 2, 3);\n\n#elif VECTOR_SIZE == 8\n__constant VEC_DATA_TYPE(DATA_TYPE, 8) type_min_ = (VEC_DATA_TYPE(DATA_TYPE, 8))(MINVAL);\n__constant uint8 idx__ = (uint8)(0, 1, 2, 3, 4, 5, 6, 7);\n\n#else /* VECTOR_SIZE DEFAULT */\n#define VECTOR_SIZE 16\n#define LOG_VECTOR_SIZE 4\n__constant VEC_DATA_TYPE(DATA_TYPE, 16) type_min_ = (VEC_DATA_TYPE(DATA_TYPE, 16))(MINVAL);\n__constant uint16 idx__ = (uint16)(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n\n#endif /* VECTOR_SIZE END */\n\n// TODO (COMPMID-661): Remove if the non-fused kernels are removed\n__constant VEC_DATA_TYPE(DATA_TYPE, 16) type_min = (VEC_DATA_TYPE(DATA_TYPE, 16))(MINVAL);\n__constant uint16 idx16 = (uint16)(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n__constant uint4 idx4   = (uint4)(0, 1, 2, 3);\n\n/** Identifies the maximum value across the 1st dimension.\n *\n * @note Datatype must be given as a preprocessor argument using -DDATA_TYPE=type. e.g. -DDATA_TYPE=short\n * @note Fixed point position must be given as a preprocessor argument using -DFIXED_POINT_POSITION=pos. e.g. DFIXED_POINT_POSITION=4\n * @note In case the input is not multiple of 16 -DNON_MULTIPLE_OF_16 must be passed.\n *\n * @param[in]  src_ptr                           Pointer to the source tensor slice. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                      Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                        src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                      Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                        src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                      Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                        src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes The offset of the first element in the source tensor\n * @param[out] dst_ptr                           Pointer to the destination tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                      Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                        dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                      Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                        dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_stride_z                      Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                        dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes The offset of the first element in the destination tensor\n * @param[in]  width                             Input image width\n */\n__kernel void softmax_layer_max(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    uint width)\n{\n    Image src = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(src);\n    Image dst = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(dst);\n\n    // Initialize local maximum\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    max_val = (VEC_DATA_TYPE(DATA_TYPE, 16))type_min;\n\n    // Calculate max of row\n    const uint width4 = width >> 4;\n    for(uint i = 0; i < width4; i++)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, 16)\n        data    = vload16(0, (__global DATA_TYPE *)offset(&src, i << 4, 0));\n        max_val = MAX_OP(data, max_val, DATA_TYPE, 16);\n    }\n\n#ifdef NON_MULTIPLE_OF_16\n    // Handle non multiple of 16\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    data = vload16(0, (__global DATA_TYPE *)offset(&src, width4 << 4, 0));\n    VEC_DATA_TYPE(SELECT_DATA_TYPE, 16)\n    widx    = CONVERT(((uint16)(width4 << 4) + idx16) < width, VEC_DATA_TYPE(SELECT_DATA_TYPE, 16));\n    max_val = MAX_OP(max_val, select(type_min, data, widx), DATA_TYPE, 16);\n#endif /* NON_MULTIPLE_OF_16 */\n\n    // Perform max reduction\n    max_val.s01234567 = MAX_OP(max_val.s01234567, max_val.s89ABCDEF, DATA_TYPE, 8);\n    max_val.s0123     = MAX_OP(max_val.s0123, max_val.s4567, DATA_TYPE, 4);\n    max_val.s01       = MAX_OP(max_val.s01, max_val.s23, DATA_TYPE, 2);\n    max_val.s0        = MAX_OP(max_val.s0, max_val.s1, DATA_TYPE, 1);\n\n    // Store result\n    *((__global DATA_TYPE *)dst.ptr) = max_val.s0;\n}\n\n/** Shifts the values of the input tensor by the max calculated in softmax_layer_max kernel,\n * then gets the exponent of each element as sums all elements across each row.\n *\n * @note Datatype must be given as a preprocessor argument using -DDATA_TYPE=type. e.g. -DDATA_TYPE=short\n * @note Fixed point position must be given as a preprocessor argument using -DFIXED_POINT_POSITION=pos. e.g. DFIXED_POINT_POSITION=4\n * @note In case the input is not multiple of 16 -DNON_MULTIPLE_OF_16 must be passed.\n * @note Beta can be optionally passed at compile time using -DBETA (if undefined, assume it equals 1.0)\n *\n * @param[in]  src_ptr                           Pointer to the source tensor slice. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                      Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                        src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                      Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                        src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                      Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                        src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes The offset of the first element in the source tensor\n * @param[in]  max_ptr                           Pointer to the max values tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  max_stride_x                      Stride of the max values tensor in X dimension (in bytes)\n * @param[in]  max_step_x                        max_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  max_stride_y                      Stride of the max values tensor in Y dimension (in bytes)\n * @param[in]  max_step_y                        max_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  max_stride_z                      Stride of the max values tensor in Z dimension (in bytes)\n * @param[in]  max_step_z                        max_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  max_offset_first_element_in_bytes The offset of the first element in the max values tensor\n * @param[out] dst_ptr                           Pointer to the destination tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                      Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                        dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                      Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                        dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_stride_z                      Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                        dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes The offset of the first element in the destination tensor\n * @param[out] sum_ptr                           Pointer to the sum values tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  sum_stride_x                      Stride of the sum values tensor in X dimension (in bytes)\n * @param[in]  sum_step_x                        sum_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  sum_stride_y                      Stride of the sum values tensor in Y dimension (in bytes)\n * @param[in]  sum_step_y                        sum_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  sum_stride_z                      Stride of the sum values tensor in Z dimension (in bytes)\n * @param[in]  sum_step_z                        sum_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  sum_offset_first_element_in_bytes The offset of the first element in the sum values tensor\n * @param[in]  width                             Input image width\n */\n__kernel void softmax_layer_shift_exp_sum(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(max),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(sum),\n    uint width)\n{\n    Image src = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(src);\n    Image dst = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(dst);\n    Image max = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(max);\n    Image sum = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(sum);\n\n#ifdef BETA\n    // Initialize beta\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    beta = (VEC_DATA_TYPE(DATA_TYPE, 16))BETA;\n#endif /* BETA */\n\n    // Load max value of 1D logits vector (row)\n    DATA_TYPE max_val = *((__global DATA_TYPE *)offset(&max, 0, 0));\n\n    // Set sum vector\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    sum1D = 0;\n\n    // Shift values, exp and sum\n    const uint width4 = width >> 4;\n    for(uint i = 0; i < width4; i++)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, 16)\n        data = vload16(0, (__global DATA_TYPE *)offset(&src, i << 4, 0));\n        data = SUB_OP(data, max_val, DATA_TYPE, 16);\n#ifdef BETA\n        data = MUL_OP(data, beta, DATA_TYPE, 16);\n#endif /* BETA */\n        data = EXP_OP(data, DATA_TYPE, 16);\n        vstore16(data, 0, (__global DATA_TYPE *)offset(&dst, i << 4, 0));\n        sum1D = ADD_OP(sum1D, data, DATA_TYPE, 16);\n    }\n\n#ifdef NON_MULTIPLE_OF_16\n    // Handle non multiple of 16\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    data = vload16(0, (__global DATA_TYPE *)offset(&src, width4 << 4, 0));\n    data = SUB_OP(data, max_val, DATA_TYPE, 16);\n#ifdef BETA\n    data = MUL_OP(data, beta, DATA_TYPE, 16);\n#endif /* BETA */\n    data = EXP_OP(data, DATA_TYPE, 16);\n    VEC_DATA_TYPE(SELECT_DATA_TYPE, 16)\n    widx = CONVERT(((uint16)(width4 << 4) + idx16) < width, VEC_DATA_TYPE(SELECT_DATA_TYPE, 16));\n    data = select(0, data, widx);\n    vstore16(data, 0, (__global DATA_TYPE *)offset(&dst, width4 << 4, 0));\n    sum1D = ADD_OP(sum1D, data, DATA_TYPE, 16);\n#endif /* NON_MULTIPLE_OF_16 */\n\n    // Perform min/max reduction\n    sum1D.s01234567 = ADD_OP(sum1D.s01234567, sum1D.s89ABCDEF, DATA_TYPE, 8);\n    sum1D.s0123     = ADD_OP(sum1D.s0123, sum1D.s4567, DATA_TYPE, 4);\n    sum1D.s01       = ADD_OP(sum1D.s01, sum1D.s23, DATA_TYPE, 2);\n    sum1D.s0        = ADD_OP(sum1D.s0, sum1D.s1, DATA_TYPE, 1);\n\n    // Calculate and store result\n    *((__global DATA_TYPE *)sum.ptr) = sum1D.s0;\n}\n\n/** Divides all the values of the input tensor by the sum calculated from softmax_layer_shift_exp_sum kernel.\n *\n * @note Datatype must be given as a preprocessor argument using -DDATA_TYPE=type. e.g. -DDATA_TYPE=short\n * @note Fixed point position must be given as a preprocessor argument using -DFIXED_POINT_POSITION=pos. e.g. DFIXED_POINT_POSITION=4\n *\n * @param[in]  src_ptr                           Pointer to the source tensor slice. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                      Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                        src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                      Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                        src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                      Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                        src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes The offset of the first element in the source tensor\n * @param[in]  sum_ptr                           Pointer to the sum values tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  sum_stride_x                      Stride of the sum values tensor in X dimension (in bytes)\n * @param[in]  sum_step_x                        sum_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  sum_stride_y                      Stride of the sum values tensor in Y dimension (in bytes)\n * @param[in]  sum_step_y                        sum_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  sum_stride_z                      Stride of the sum values tensor in Z dimension (in bytes)\n * @param[in]  sum_step_z                        sum_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  sum_offset_first_element_in_bytes The offset of the first element in the sum values tensor\n * @param[out] dst_ptr                           Pointer to the destination tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                      Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                        dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                      Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                        dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_stride_z                      Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                        dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes The offset of the first element in the destination tensor\n */\n__kernel void softmax_layer_norm(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(sum),\n    TENSOR3D_DECLARATION(dst))\n{\n    Image src = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(src);\n    Image dst = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(dst);\n    Image sum = CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(sum);\n\n    // Load max value of 1D logits vector (row)\n    DATA_TYPE sum_val = *((__global DATA_TYPE *)offset(&sum, 0, get_global_id(1)));\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    data = vload16(0, (__global DATA_TYPE *)offset(&src, 0, 0));\n    vstore16(DIV_OP(data, sum_val, DATA_TYPE, 16), 0, (__global DATA_TYPE *)offset(&dst, 0, 0));\n}\n\n/** Identifies the maximum value across the 1st dimension and shifts the values of the input tensor by this maximum value,\n * then gets the exponent of each element as sums all elements across each row.\n *\n * @note Datatype must be given as a preprocessor argument using -DDATA_TYPE=type. e.g. -DDATA_TYPE=short\n * @note Fixed point position must be given as a preprocessor argument using -DFIXED_POINT_POSITION=pos. e.g. DFIXED_POINT_POSITION=4\n * @note In case the input is not a multiple of VECTOR_SIZE (2,4,8,16) -DNON_MULTIPLE_OF_VECTOR_SIZE must be passed.\n * @note Beta can be optionally passed at compile time using -DBETA (by default, it is 1.0).\n *\n * @param[in]  src_ptr                            Pointer to the source tensor slice. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                       Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                         src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                       Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                         src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                       Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                         src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes  The offset of the first element in the source tensor\n * @param[in]  maxo_ptr                           Pointer to the max values tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  maxo_stride_x                      Stride of the max values tensor in X dimension (in bytes)\n * @param[in]  maxo_step_x                        max_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  maxo_stride_y                      Stride of the max values tensor in Y dimension (in bytes)\n * @param[in]  maxo_step_y                        max_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  maxo_stride_z                      Stride of the max values tensor in Z dimension (in bytes)\n * @param[in]  maxo_step_z                        max_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  maxo_offset_first_element_in_bytes The offset of the first element in the max values tensor\n * @param[out] dst_ptr                            Pointer to the destination tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                       Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                         dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                       Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                         dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_stride_z                       Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                         dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes  The offset of the first element in the destination tensor\n * @param[out] sum_ptr                            Pointer to the sum values tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  sum_stride_x                       Stride of the sum values tensor in X dimension (in bytes)\n * @param[in]  sum_step_x                         sum_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  sum_stride_y                       Stride of the sum values tensor in Y dimension (in bytes)\n * @param[in]  sum_step_y                         sum_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  sum_stride_z                       Stride of the sum values tensor in Z dimension (in bytes)\n * @param[in]  sum_step_z                         sum_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  sum_offset_first_element_in_bytes  The offset of the first element in the sum values tensor\n * @param[in]  width                              Input image width\n */\n__kernel void softmax_layer_max_shift_exp_sum_serial(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(maxo),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(sum),\n    uint width)\n{\n    Image src  = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(src);\n    Image dst  = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(dst);\n    Image maxo = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(maxo);\n    Image sum  = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(sum);\n\n#ifdef BETA\n    // Initialize beta\n    VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE)\n    beta = (VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE))BETA;\n#endif /* BETA */\n\n    // Initialize local maximum\n    VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE)\n    max_val_vec = (VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE))type_min_;\n\n    // Calculate max of row\n    const uint width_ = width >> LOG_VECTOR_SIZE;\n    for(uint i = 0; i < width_; i++)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE)\n        data_max    = VLOAD(VECTOR_SIZE)(0, (__global DATA_TYPE *)offset(&src, i << LOG_VECTOR_SIZE, 0));\n        max_val_vec = MAX_OP(data_max, max_val_vec, DATA_TYPE, VECTOR_SIZE);\n    }\n\n#ifdef NON_MULTIPLE_OF_VECTOR_SIZE\n    VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE)\n    data_max = VLOAD(VECTOR_SIZE)(0, (__global DATA_TYPE *)offset(&src, width_ << LOG_VECTOR_SIZE, 0));\n    VEC_DATA_TYPE(SELECT_DATA_TYPE, VECTOR_SIZE)\n    widx        = CONVERT((EXPAND((CL_VEC_DATA_TYPE(uint, VECTOR_SIZE)))(width_ << LOG_VECTOR_SIZE) + idx__) < width, VEC_DATA_TYPE(SELECT_DATA_TYPE, VECTOR_SIZE));\n    max_val_vec = MAX_OP(max_val_vec, select(type_min_, data_max, widx), DATA_TYPE, VECTOR_SIZE);\n#endif /* NON_MULTIPLE_OF_VECTOR_SIZE */\n\n    // Perform max reduction\n#if VECTOR_SIZE == 16\n    max_val_vec.s01234567 = MAX_OP(max_val_vec.s01234567, max_val_vec.s89ABCDEF, DATA_TYPE, 8);\n#endif /* VECTOR SIZE 16 END */\n#if VECTOR_SIZE >= 8\n    max_val_vec.s0123 = MAX_OP(max_val_vec.s0123, max_val_vec.s4567, DATA_TYPE, 4);\n#endif /* VECTOR SIZE 8 END */\n#if VECTOR_SIZE >= 4\n    max_val_vec.s01 = MAX_OP(max_val_vec.s01, max_val_vec.s23, DATA_TYPE, 2);\n#endif /* VECTOR SIZE 4 END */\n    max_val_vec.s0 = MAX_OP(max_val_vec.s0, max_val_vec.s1, DATA_TYPE, 1);\n    // Store result\n    *((__global DATA_TYPE *)maxo.ptr) = max_val_vec.s0;\n\n    /* Second section */\n\n    // Load max value of 1D logits vector (row)\n    DATA_TYPE max_val = *((__global DATA_TYPE *)offset(&maxo, 0, 0));\n\n    // Set sum vector\n    VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE)\n    sum1D = 0;\n\n    // Shift values, exp and sum\n    for(uint i = 0; i < width_; i++)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE)\n        data = VLOAD(VECTOR_SIZE)(0, (__global DATA_TYPE *)offset(&src, i << LOG_VECTOR_SIZE, 0));\n        data = SUB_OP(data, max_val, DATA_TYPE, VECTOR_SIZE);\n#ifdef BETA\n        data = MUL_OP(data, beta, DATA_TYPE, VECTOR_SIZE);\n#endif /* BETA */\n        data = EXP_OP(data, DATA_TYPE, VECTOR_SIZE);\n        VSTORE(VECTOR_SIZE)\n        (data, 0, (__global DATA_TYPE *)offset(&dst, i << LOG_VECTOR_SIZE, 0));\n        sum1D = ADD_OP(sum1D, data, DATA_TYPE, VECTOR_SIZE);\n    }\n\n#ifdef NON_MULTIPLE_OF_VECTOR_SIZE\n    VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE)\n    data = VLOAD(VECTOR_SIZE)(0, (__global DATA_TYPE *)offset(&src, width_ << LOG_VECTOR_SIZE, 0));\n    data = SUB_OP(data, max_val, DATA_TYPE, VECTOR_SIZE);\n#ifdef BETA\n    data = MUL_OP(data, beta, DATA_TYPE, VECTOR_SIZE);\n#endif /* BETA */\n    data = EXP_OP(data, DATA_TYPE, VECTOR_SIZE);\n    widx = CONVERT((EXPAND((CL_VEC_DATA_TYPE(uint, VECTOR_SIZE)))(width_ << LOG_VECTOR_SIZE) + idx__) < width, VEC_DATA_TYPE(SELECT_DATA_TYPE, VECTOR_SIZE));\n    data = select(0, data, widx);\n    VSTORE(VECTOR_SIZE)\n    (data, 0, (__global DATA_TYPE *)offset(&dst, width_ << LOG_VECTOR_SIZE, 0));\n    sum1D = ADD_OP(sum1D, data, DATA_TYPE, VECTOR_SIZE);\n#endif /* NON_MULTIPLE_OF_VECTOR_SIZE */\n\n    // Perform sum reduction\n#if VECTOR_SIZE == 16\n    sum1D.s01234567 = ADD_OP(sum1D.s01234567, sum1D.s89ABCDEF, DATA_TYPE, 8);\n#endif /* VECTOR SIZE 16 END */\n#if VECTOR_SIZE >= 8\n    sum1D.s0123 = ADD_OP(sum1D.s0123, sum1D.s4567, DATA_TYPE, 4);\n#endif /* VECTOR SIZE 8 END */\n#if VECTOR_SIZE >= 4\n    sum1D.s01 = ADD_OP(sum1D.s01, sum1D.s23, DATA_TYPE, 2);\n#endif /* VECTOR SIZE 4 END */\n    sum1D.s0 = ADD_OP(sum1D.s0, sum1D.s1, DATA_TYPE, 1);\n\n    // Calculate and store result\n    *((__global DATA_TYPE *)sum.ptr) = sum1D.s0;\n}\n\n/** Identifies the maximum value across the 1st dimension and shifts the values of the input tensor by this maximum value,\n * then gets the exponent of each element as sums all elements across each row.\n *\n * @note Datatype must be given as a preprocessor argument using -DDATA_TYPE=type. e.g. -DDATA_TYPE=short\n * @note Fixed point position must be given as a preprocessor argument using -DFIXED_POINT_POSITION=pos. e.g. DFIXED_POINT_POSITION=4\n * @note In case the input is not a multiple of VECTOR_SIZE (2,4,8,16) -DNON_MULTIPLE_OF_VECTOR_SIZE must be passed.\n * @note Beta can be optionally passed at compile time using -DBETA (by default, it is 1.0).\n *\n * @param[in]  src_ptr                            Pointer to the source tensor slice. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                       Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                         src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                       Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                         src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                       Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                         src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes  The offset of the first element in the source tensor\n * @param[in]  maxo_ptr                           Pointer to the max values tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  maxo_stride_x                      Stride of the max values tensor in X dimension (in bytes)\n * @param[in]  maxo_step_x                        max_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  maxo_stride_y                      Stride of the max values tensor in Y dimension (in bytes)\n * @param[in]  maxo_step_y                        max_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  maxo_stride_z                      Stride of the max values tensor in Z dimension (in bytes)\n * @param[in]  maxo_step_z                        max_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  maxo_offset_first_element_in_bytes The offset of the first element in the max values tensor\n * @param[out] dst_ptr                            Pointer to the destination tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                       Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                         dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                       Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                         dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_stride_z                       Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                         dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes  The offset of the first element in the destination tensor\n * @param[out] sum_ptr                            Pointer to the sum values tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  sum_stride_x                       Stride of the sum values tensor in X dimension (in bytes)\n * @param[in]  sum_step_x                         sum_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  sum_stride_y                       Stride of the sum values tensor in Y dimension (in bytes)\n * @param[in]  sum_step_y                         sum_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  sum_stride_z                       Stride of the sum values tensor in Z dimension (in bytes)\n * @param[in]  sum_step_z                         sum_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  sum_offset_first_element_in_bytes  The offset of the first element in the sum values tensor\n * @param[in]  width                              Input image width\n */\n__kernel void softmax_layer_max_shift_exp_sum_parallel(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(maxo),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(sum),\n    uint width)\n{\n    Image src  = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(src);\n    Image dst  = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(dst);\n    Image maxo = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(maxo);\n    Image sum  = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(sum);\n\n    const uint lid = get_local_id(0);\n\n#ifdef BETA\n    // Initialize beta\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    beta = (VEC_DATA_TYPE(DATA_TYPE, 4))BETA;\n#endif /* BETA */\n\n    // Define one temporary vector per work-item.\n    __local VEC_DATA_TYPE(DATA_TYPE, 4) tmp_local[GRID_SIZE];\n    __local DATA_TYPE max_local;\n\n    __constant VEC_DATA_TYPE(DATA_TYPE, 4) type_min4 = (VEC_DATA_TYPE(DATA_TYPE, 4))(MINVAL);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    max_val_vec = (VEC_DATA_TYPE(DATA_TYPE, 4))type_min4;\n    // Number of elements per work-item.\n    const uint row = width / GRID_SIZE;\n    // Number of iterations per work-item.\n    const uint width_ = row >> 2;\n    // Calculate max of row\n    uint i = 0;\n    for(; i < width_; i++)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, 4)\n        data_max    = VLOAD(4)(0, (__global DATA_TYPE *)offset(&src, i * GRID_SIZE * 4, 0));\n        max_val_vec = MAX_OP(data_max, max_val_vec, DATA_TYPE, 4);\n    }\n#ifdef NON_MULTIPLE_OF_GRID_SIZE\n    // How many work-items needed to complete the computation.\n    //TODO: Optimize this calculation (avoid %).\n    int boundary_workitems = (width % (GRID_SIZE * 4)) / 4;\n    if(lid < boundary_workitems)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, 4)\n        data_max    = VLOAD(4)(0, (__global DATA_TYPE *)offset(&src, i * GRID_SIZE * 4, 0));\n        max_val_vec = MAX_OP(data_max, max_val_vec, DATA_TYPE, 4);\n    }\n#ifdef NON_MULTIPLE_OF_VECTOR_SIZE\n    if(boundary_workitems == 0)\n    {\n        boundary_workitems = GRID_SIZE;\n        i--;\n    }\n    if(lid == (boundary_workitems - 1))\n    {\n        // Handle non multiple of 4\n        VEC_DATA_TYPE(DATA_TYPE, 4)\n        data_max = VLOAD(4)(0, (__global DATA_TYPE *)offset(&src, (GRID_SIZE * i * 4) + 4, 0));\n        VEC_DATA_TYPE(SELECT_DATA_TYPE, 4)\n        widx        = CONVERT(((uint4)(GRID_SIZE * i * 4) + boundary_workitems * 4 + idx4) < width, VEC_DATA_TYPE(SELECT_DATA_TYPE, 4));\n        max_val_vec = MAX_OP(max_val_vec, select(type_min_, data_max, widx), DATA_TYPE, 4);\n    }\n#endif /* NON_MULTIPLE_OF_VECTOR_SIZE */\n#endif /* NON_MULTIPLE_OF_GRID_SIZE */\n    tmp_local[lid] = max_val_vec;\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n    if(GRID_SIZE >= 256)\n    {\n        if(lid < 128)\n        {\n            tmp_local[lid] = MAX_OP(tmp_local[lid + 128], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 128)\n    {\n        if(lid < 64)\n        {\n            tmp_local[lid] = MAX_OP(tmp_local[lid + 64], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 64)\n    {\n        if(lid < 32)\n        {\n            tmp_local[lid] = MAX_OP(tmp_local[lid + 32], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 32)\n    {\n        if(lid < 16)\n        {\n            tmp_local[lid] = MAX_OP(tmp_local[lid + 16], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 16)\n    {\n        if(lid < 8)\n        {\n            tmp_local[lid] = MAX_OP(tmp_local[lid + 8], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 8)\n    {\n        if(lid < 4)\n        {\n            tmp_local[lid] = MAX_OP(tmp_local[lid + 4], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 4)\n    {\n        if(lid < 2)\n        {\n            tmp_local[lid] = MAX_OP(tmp_local[lid + 2], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(lid == 0)\n    {\n        max_val_vec     = MAX_OP(tmp_local[lid + 1], tmp_local[lid], DATA_TYPE, 4);\n        max_val_vec.s01 = MAX_OP(max_val_vec.s01, max_val_vec.s23, DATA_TYPE, 2);\n        max_val_vec.s0  = MAX_OP(max_val_vec.s0, max_val_vec.s1, DATA_TYPE, 1);\n        max_local       = max_val_vec.s0;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n    /* Second section */\n\n    // Set sum vector\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    sum1D             = 0;\n    DATA_TYPE max_val = max_local;\n\n    // Shift values, exp and sum\n    for(i = 0; i < width_; i++)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, 4)\n        data = VLOAD(4)(0, (__global DATA_TYPE *)offset(&src, i * GRID_SIZE * 4, 0));\n        data = SUB_OP(data, max_val, DATA_TYPE, 4);\n#ifdef BETA\n        data = MUL_OP(data, beta, DATA_TYPE, 4);\n#endif /* BETA */\n        data = EXP_OP(data, DATA_TYPE, 4);\n        VSTORE(4)\n        (data, 0, (__global DATA_TYPE *)offset(&dst, i * GRID_SIZE * 4, 0));\n        sum1D = ADD_OP(sum1D, data, DATA_TYPE, 4);\n    }\n#ifdef NON_MULTIPLE_OF_GRID_SIZE\n    //TODO: Optimize the calculation (avoid %).\n    boundary_workitems = (width % (GRID_SIZE * 4)) / 4;\n    if(lid < boundary_workitems)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, 4)\n        data = VLOAD(4)(0, (__global DATA_TYPE *)offset(&src, i * GRID_SIZE * 4, 0));\n        data = SUB_OP(data, max_val, DATA_TYPE, 4);\n#ifdef BETA\n        data = MUL_OP(data, beta, DATA_TYPE, 4);\n#endif /* BETA */\n        data = EXP_OP(data, DATA_TYPE, 4);\n        VSTORE(4)\n        (data, 0, (__global DATA_TYPE *)offset(&dst, i * GRID_SIZE * 4, 0));\n        sum1D = ADD_OP(sum1D, data, DATA_TYPE, 4);\n    }\n#ifdef NON_MULTIPLE_OF_VECTOR_SIZE\n    if(boundary_workitems == 0)\n    {\n        boundary_workitems = GRID_SIZE;\n        i--;\n    }\n    if(lid == (boundary_workitems - 1))\n    {\n        // Handle non multiple of vector size ((GRID_SIZE * i * 4) + 4, 0); move 4 float positions ahead, *4 is due to the stride\n        VEC_DATA_TYPE(DATA_TYPE, 4)\n        data = VLOAD(4)(0, (__global DATA_TYPE *)offset(&src, (GRID_SIZE * i * 4) + 4, 0));\n        data = SUB_OP(data, max_val, DATA_TYPE, 4);\n#ifdef BETA\n        data = MUL_OP(data, beta, DATA_TYPE, 4);\n#endif /* BETA */\n        data = EXP_OP(data, DATA_TYPE, 4);\n        VEC_DATA_TYPE(SELECT_DATA_TYPE, 4)\n        widx = CONVERT(((uint4)(GRID_SIZE * i * 4) + boundary_workitems * 4 + idx4) < width, VEC_DATA_TYPE(SELECT_DATA_TYPE, 4));\n        data = select(0, data, widx);\n        VSTORE(4)\n        (data, 0, (__global DATA_TYPE *)offset(&dst, (GRID_SIZE * i * 4) + 4, 0));\n        sum1D = ADD_OP(sum1D, data, DATA_TYPE, 4);\n    }\n#endif /* NON_MULTIPLE_OF_VECTOR_SIZE */\n#endif /* NON_MULTIPLE_OF_GRID_SIZE */\n    tmp_local[lid] = sum1D;\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n    if(GRID_SIZE >= 256)\n    {\n        if(lid < 128)\n        {\n            tmp_local[lid] = ADD_OP(tmp_local[lid + 128], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 128)\n    {\n        if(lid < 64)\n        {\n            tmp_local[lid] = ADD_OP(tmp_local[lid + 64], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 64)\n    {\n        if(lid < 32)\n        {\n            tmp_local[lid] = ADD_OP(tmp_local[lid + 32], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 32)\n    {\n        if(lid < 16)\n        {\n            tmp_local[lid] = ADD_OP(tmp_local[lid + 16], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 16)\n    {\n        if(lid < 8)\n        {\n            tmp_local[lid] = ADD_OP(tmp_local[lid + 8], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 8)\n    {\n        if(lid < 4)\n        {\n            tmp_local[lid] = ADD_OP(tmp_local[lid + 4], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 4)\n    {\n        if(lid < 2)\n        {\n            tmp_local[lid] = ADD_OP(tmp_local[lid + 2], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(lid == 0)\n    {\n        sum1D = ADD_OP(tmp_local[lid + 1], tmp_local[lid], DATA_TYPE, 4);\n        // Perform max reduction\n        sum1D.s01                        = ADD_OP(sum1D.s01, sum1D.s23, DATA_TYPE, 2);\n        sum1D.s0                         = ADD_OP(sum1D.s0, sum1D.s1, DATA_TYPE, 1);\n        *((__global DATA_TYPE *)sum.ptr) = sum1D.s0;\n    }\n}\n\n"
    }, 
    "program": "0x55a2b63200", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe7417430"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.527127", 
      "end": "2018-02-09T10:36:49.572273"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63200", 
    "call": "clBuildProgram", 
    "options": " -DDATA_TYPE=float -DGRID_SIZE=64 -DLOG_VECTOR_SIZE=2 -DNON_MULTIPLE_OF_GRID_SIZE -DNON_MULTIPLE_OF_VECTOR_SIZE -DVECTOR_SIZE=4 -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a3607a00", 
    "name": "softmax_layer_max_shift_exp_sum_parallel", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.572461", 
      "end": "2018-02-09T10:36:49.627757"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63200", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe741746c"
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417840", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.627926", 
      "end": "2018-02-09T10:36:49.627934"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e9030000", 
    "arg_index": 32
  }, 
  {
    "count": 1, 
    "lengths": "0x7fe7417688", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.631409", 
      "end": "2018-02-09T10:36:49.631444"
    }, 
    "errcode": 0, 
    "errcode_ret": "0x7fe741767c", 
    "source": {
      "0": "\n\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Copyright (c) 2016, 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_HELPER_H\n#define ARM_COMPUTE_HELPER_H\n\n#if defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif // defined(ARM_COMPUTE_OPENCL_FP16_ENABLED)\n\n#if defined(ARM_COMPUTE_DEBUG_ENABLED)\n#pragma OPENCL EXTENSION cl_arm_printf : enable\n#endif // defined(ARM_COMPUTE_DEBUG_ENABLED)\n\n#define EXPAND(x) x\n\n#define CLAMP(x, min_val, max_val) min(max(x, min_val), max_val)\n\n#define VLOAD_STR(size) vload##size\n#define VLOAD(size) VLOAD_STR(size)\n\n#define VSTORE_STR(size) vstore##size\n#define VSTORE(size) VSTORE_STR(size)\n\n#define VEC_DATA_TYPE_STR(type, size) type##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CL_VEC_DATA_TYPE_STR(type, size) type##size\n#define CL_VEC_DATA_TYPE(type, size) CL_VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR(x, type) (convert_##type((x)))\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR(x, type) (convert_##type##_sat((x)))\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n#define CONVERT_SAT_ROUND_STR(x, type, round) (convert_##type##_sat_##round((x)))\n#define CONVERT_SAT_ROUND(x, type, round) CONVERT_SAT_ROUND_STR(x, type, round)\n\n#define VECTOR_DECLARATION(name)     \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define IMAGE_DECLARATION(name)      \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR3D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define TENSOR4D_DECLARATION(name)   \\\n    __global uchar *name##_ptr,      \\\n    uint        name##_stride_x, \\\n    uint        name##_step_x,   \\\n    uint        name##_stride_y, \\\n    uint        name##_step_y,   \\\n    uint        name##_stride_z, \\\n    uint        name##_step_z,   \\\n    uint        name##_stride_w, \\\n    uint        name##_step_w,   \\\n    uint        name##_offset_first_element_in_bytes\n\n#define CONVERT_TO_VECTOR_STRUCT(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x)\n\n#define CONVERT_TO_VECTOR_STRUCT_NO_STEP(name) \\\n    update_vector_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0)\n\n#define CONVERT_TO_IMAGE_STRUCT(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y)\n\n#define CONVERT_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, name##_step_z)\n\n#define CONVERT_TENSOR3D_TO_IMAGE_STRUCT(name) \\\n    update_image_from_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT(name)                                                                                                           \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z)\n\n#define CONVERT_TO_TENSOR3D_STRUCT_NO_STEP(name) \\\n    update_tensor3D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0)\n\n#define CONVERT_TO_TENSOR4D_STRUCT(name, mod_size)                                                                                                 \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, name##_step_x, name##_stride_y, name##_step_y, \\\n                                 name##_stride_z, name##_step_z, name##_stride_w, name##_step_z, mod_size)\n\n#define CONVERT_TO_TENSOR4D_STRUCT_NO_STEP(name, mod_size) \\\n    update_tensor4D_workitem_ptr(name##_ptr, name##_offset_first_element_in_bytes, name##_stride_x, 0, name##_stride_y, 0, name##_stride_z, 0, name##_stride_w, 0, mod_size)\n\n/** Structure to hold Vector information */\ntypedef struct Vector\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n} Vector;\n\n/** Structure to hold Image information */\ntypedef struct Image\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n} Image;\n\n/** Structure to hold 3D tensor information */\ntypedef struct Tensor3D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n} Tensor3D;\n\n/** Structure to hold 4D tensor information */\ntypedef struct Tensor4D\n{\n    __global uchar *ptr;                           /**< Pointer to the starting postion of the buffer */\n    int             offset_first_element_in_bytes; /**< The offset of the first element in the source image */\n    int             stride_x;                      /**< Stride of the image in X dimension (in bytes) */\n    int             stride_y;                      /**< Stride of the image in Y dimension (in bytes) */\n    int             stride_z;                      /**< Stride of the image in Z dimension (in bytes) */\n    int             stride_w;                      /**< Stride of the image in W dimension (in bytes) */\n} Tensor4D;\n\n/** Wrap vector information into an Vector structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector\n * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n *\n * @return An image object\n */\nVector inline update_vector_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x)\n{\n    Vector vector =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n    };\n    vector.ptr += vector.offset_first_element_in_bytes + get_global_id(0) * step_x;\n    return vector;\n}\n\n/** Wrap image information into an Image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n *\n * @return An image object\n */\nImage inline update_image_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y;\n    return img;\n}\n\n/** Wrap 3D tensor information into an image structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nImage inline update_image_from_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Image img =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y\n    };\n    img.ptr += img.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return img;\n}\n\n/** Wrap 3D tensor information into an tensor structure, and make the pointer point at this workitem's data.\n *\n * @param[in] ptr                           Pointer to the starting postion of the buffer\n * @param[in] offset_first_element_in_bytes The offset of the first element in the source image\n * @param[in] stride_x                      Stride of the image in X dimension (in bytes)\n * @param[in] step_x                        stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)\n * @param[in] step_y                        stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in] stride_z                      Stride of the image in Z dimension (in bytes)\n * @param[in] step_z                        stride_z * number of elements along Z processed per workitem(in bytes)\n *\n * @return A 3D tensor object\n */\nTensor3D inline update_tensor3D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)\n{\n    Tensor3D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z\n    };\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + get_global_id(2) * step_z;\n    return tensor;\n}\n\nTensor4D inline update_tensor4D_workitem_ptr(__global uchar *ptr, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z, uint stride_w,\n                                             uint step_w,\n                                             uint mod_size)\n{\n    Tensor4D tensor =\n    {\n        .ptr                           = ptr,\n        .offset_first_element_in_bytes = offset_first_element_in_bytes,\n        .stride_x                      = stride_x,\n        .stride_y                      = stride_y,\n        .stride_z                      = stride_z,\n        .stride_w                      = stride_w\n    };\n\n    tensor.ptr += tensor.offset_first_element_in_bytes + get_global_id(0) * step_x + get_global_id(1) * step_y + (get_global_id(2) % mod_size) * step_z + (get_global_id(2) / mod_size) * step_w;\n    return tensor;\n}\n\n/** Get the pointer position of a Vector\n *\n * @param[in] vec Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n */\n__global inline const uchar *vector_offset(const Vector *vec, int x)\n{\n    return vec->ptr + x * vec->stride_x;\n}\n\n/** Get the pointer position of a Image\n *\n * @param[in] img Pointer to the starting position of the buffer\n * @param[in] x   Relative X position\n * @param[in] y   Relative Y position\n */\n__global inline uchar *offset(const Image *img, int x, int y)\n{\n    return img->ptr + x * img->stride_x + y * img->stride_y;\n}\n\n/** Get the pointer position of a Tensor3D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n */\n__global inline const uchar *tensor3D_offset(const Tensor3D *tensor, int x, int y, int z)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z;\n}\n\n/** Get the pointer position of a Tensor4D\n *\n * @param[in] tensor Pointer to the starting position of the buffer\n * @param[in] x      Relative X position\n * @param[in] y      Relative Y position\n * @param[in] z      Relative Z position\n * @param[in] w      Relative W position\n */\n__global inline const uchar *tensor4D_offset(const Tensor4D *tensor, int x, int y, int z, int w)\n{\n    return tensor->ptr + x * tensor->stride_x + y * tensor->stride_y + z * tensor->stride_z + w * tensor->stride_w;\n}\n\n#endif // _HELPER_H\n\n#ifdef FIXED_POINT_POSITION\n\n/*\n * Copyright (c) 2017 ARM Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef ARM_COMPUTE_FIXED_POINT_H\n#define ARM_COMPUTE_FIXED_POINT_H\n\n#define TYPE_ALIAS(type, alias)  \\\n    typedef type alias;          \\\n    typedef type alias##x##1;    \\\n    typedef type##2 alias##x##2; \\\n    typedef type##3 alias##x##3; \\\n    typedef type##4 alias##x##4; \\\n    typedef type##8 alias##x##8; \\\n    typedef type##16 alias##x##16;\n\nTYPE_ALIAS(char, qs8)\nTYPE_ALIAS(short, qs16)\nTYPE_ALIAS(int, qs32)\n\n#define qs8_MIN ((char)CHAR_MIN)\n#define qs8_MAX ((char)CHAR_MAX)\n#define qs16_MIN ((short)SHRT_MIN)\n#define qs16_MAX ((short)SHRT_MAX)\n#define qs32_MIN ((int)INT_MIN)\n#define qs32_MAX ((int)INT_MAX)\n\n#define qu8_MIN ((uchar)0)\n#define qu8_MAX ((uchar)UCHAR_MAX)\n#define qu16_MIN ((ushort)0)\n#define qu16_MAX ((ushort)USHRT_MAX)\n#define qu32_MIN ((uint)0)\n#define qu32_MAX ((uint)UINT_MAX)\n\n#define qs8_TYPE char\n#define qs8x1_TYPE char\n#define qs8x2_TYPE char2\n#define qs8x3_TYPE char3\n#define qs8x4_TYPE char4\n#define qs8x8_TYPE char8\n#define qs8x16_TYPE char16\n\n#define qs16_TYPE short\n#define qs16x1_TYPE short\n#define qs16x2_TYPE short2\n#define qs16x3_TYPE short3\n#define qs16x4_TYPE short4\n#define qs16x8_TYPE short8\n#define qs16x16_TYPE short16\n\n#define qs32_TYPE int\n#define qs32x1_TYPE int\n#define qs32x2_TYPE int2\n#define qs32x3_TYPE int3\n#define qs32x4_TYPE int4\n#define qs32x8_TYPE int8\n#define qs32x16_TYPE int16\n\n/* All internal constants are represented in the maximum supported fixed point format (QS16),\n * thus we define an additional shift parameter required to convert the constant\n * from the maximum supported format to the require one.\n */\n#define qs8_SHIFT 8\n#define qs16_SHIFT 0\n\n#undef VEC_DATA_TYPE_STR\n#undef VEC_DATA_TYPE\n#undef CONVERT_STR\n#undef CONVERT\n#undef CONVERT_SAT_STR\n#undef CONVERT_SAT\n\n#define VEC_DATA_TYPE_STR(type, size) type##x##size\n#define VEC_DATA_TYPE(type, size) VEC_DATA_TYPE_STR(type, size)\n\n#define CONVERT_STR3(x, type, rtype) (convert_##rtype((x)))\n#define CONVERT_STR2(x, type, rtype) CONVERT_STR3(x, type, rtype)\n#define CONVERT_STR(x, type) CONVERT_STR2(x, type, type##_TYPE)\n#define CONVERT(x, type) CONVERT_STR(x, type)\n\n#define CONVERT_SAT_STR3(x, type, rtype) (convert_##rtype##_sat((x)))\n#define CONVERT_SAT_STR2(x, type, rtype) CONVERT_SAT_STR3(x, type, rtype)\n#define CONVERT_SAT_STR(x, type) CONVERT_SAT_STR2(x, type, type##_TYPE)\n#define CONVERT_SAT(x, type) CONVERT_SAT_STR(x, type)\n\n/** Computes saturating absolute value of fixed point vector.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point absolute value.\n */\n#define ABSQ_SAT_IMPL(type)                  \\\n    inline type abs_##type##_sat(type VopA)  \\\n    {                                        \\\n        return CONVERT_SAT(abs(VopA), type); \\\n    }\n\nABSQ_SAT_IMPL(qs8x16)\nABSQ_SAT_IMPL(qs16x8)\n\n#define ABS_SAT_OP_EXPAND_STR(a, type, size) abs_##type##x##size##_sat((a))\n#define ABS_SAT_OP_EXPAND(a, type, size) ABS_SAT_OP_EXPAND_STR(a, type, size)\n\n/** Computes max of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point maximum.\n */\n#define MAXQ_IMPL(type)                          \\\n    inline type max_##type(type VopA, type VopB) \\\n    {                                            \\\n        return max(VopA, VopB);                  \\\n    }\n\nMAXQ_IMPL(qs8x1)\nMAXQ_IMPL(qs8x2)\nMAXQ_IMPL(qs8x4)\nMAXQ_IMPL(qs8x8)\nMAXQ_IMPL(qs8x16)\nMAXQ_IMPL(qs16x1)\nMAXQ_IMPL(qs16x2)\nMAXQ_IMPL(qs16x4)\nMAXQ_IMPL(qs16x8)\nMAXQ_IMPL(qs16x16)\n\n#define MAX_OP_EXPAND_STR(a, b, type, size) max_##type##x##size((a), (b))\n#define MAX_OP_EXPAND(a, b, type, size) MAX_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated addition of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point addition. The result is saturated in case of overflow\n */\n#define ADDQ_SAT_IMPL(type)                          \\\n    inline type add_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return add_sat(VopA, VopB);                  \\\n    }\n\nADDQ_SAT_IMPL(qs8x1)\nADDQ_SAT_IMPL(qs8x2)\nADDQ_SAT_IMPL(qs8x4)\nADDQ_SAT_IMPL(qs8x8)\nADDQ_SAT_IMPL(qs8x16)\nADDQ_SAT_IMPL(qs16x1)\nADDQ_SAT_IMPL(qs16x2)\nADDQ_SAT_IMPL(qs16x4)\nADDQ_SAT_IMPL(qs16x8)\nADDQ_SAT_IMPL(qs16x16)\nADDQ_SAT_IMPL(qs32x1)\nADDQ_SAT_IMPL(qs32x2)\nADDQ_SAT_IMPL(qs32x4)\nADDQ_SAT_IMPL(qs32x8)\nADDQ_SAT_IMPL(qs32x16)\n\n#define ADD_SAT_OP_EXPAND_STR(a, b, type, size) add_sat_##type##x##size((a), (b))\n#define ADD_SAT_OP_EXPAND(a, b, type, size) ADD_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/** Computes saturated subtraction of fixed point types.\n *\n * @param[in] type the actual data type.\n *\n * @return The result of the fixed point subtraction. The result is saturated in case of overflow\n */\n#define SUBQ_SAT_IMPL(type)                          \\\n    inline type sub_sat_##type(type VopA, type VopB) \\\n    {                                                \\\n        return sub_sat(VopA, VopB);                  \\\n    }\n\nSUBQ_SAT_IMPL(qs8x1)\nSUBQ_SAT_IMPL(qs8x2)\nSUBQ_SAT_IMPL(qs8x4)\nSUBQ_SAT_IMPL(qs8x8)\nSUBQ_SAT_IMPL(qs8x16)\nSUBQ_SAT_IMPL(qs16x1)\nSUBQ_SAT_IMPL(qs16x2)\nSUBQ_SAT_IMPL(qs16x4)\nSUBQ_SAT_IMPL(qs16x8)\nSUBQ_SAT_IMPL(qs16x16)\n\n#define SUB_SAT_OP_EXPAND_STR(a, b, type, size) sub_sat_##type##x##size((a), (b))\n#define SUB_SAT_OP_EXPAND(a, b, type, size) SUB_SAT_OP_EXPAND_STR(a, b, type, size)\n\n/* Multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication.\n */\n#define MULQ_IMPL(type, itype)                                                         \\\n    inline type mul_##type(type VopA, type VopB, int fixed_point_position)             \\\n    {                                                                                  \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                    \\\n        itype res       = CONVERT((VopA), itype) * CONVERT((VopB), itype) + round_val; \\\n        return CONVERT((res >> (itype)fixed_point_position), type);                    \\\n    }\n\nMULQ_IMPL(qs8x8, qs16x8)\nMULQ_IMPL(qs16x8, qs32x8)\nMULQ_IMPL(qs8x16, qs16x16)\nMULQ_IMPL(qs16x16, qs32x16)\n\n#define MUL_OP_EXPAND_STR(a, b, type, size, position) mul_##type##x##size((a), (b), (position))\n#define MUL_OP_EXPAND(a, b, type, size, position) MUL_OP_EXPAND_STR(a, b, type, size, position)\n\n/* Saturate multiply of two fixed point numbers\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiplication. The result is saturated in case of overflow\n */\n#define MULQ_SAT_IMPL(type, itype)                                                            \\\n    inline type mul_sat_##type(type VopA, type VopB, int fixed_point_position)                \\\n    {                                                                                         \\\n        itype round_val = (itype)(1 << (fixed_point_position - 1));                           \\\n        itype res       = mad_sat(CONVERT((VopA), itype), CONVERT((VopB), itype), round_val); \\\n        return CONVERT_SAT((res >> (itype)fixed_point_position), type);                       \\\n    }\n\nMULQ_SAT_IMPL(qs8x1, qs16x1)\nMULQ_SAT_IMPL(qs8x2, qs16x2)\nMULQ_SAT_IMPL(qs8x3, qs16x3)\nMULQ_SAT_IMPL(qs8x4, qs16x4)\nMULQ_SAT_IMPL(qs8x8, qs16x8)\nMULQ_SAT_IMPL(qs8x16, qs16x16)\nMULQ_SAT_IMPL(qs16x1, qs32x1)\nMULQ_SAT_IMPL(qs16x2, qs32x2)\nMULQ_SAT_IMPL(qs16x3, qs32x3)\nMULQ_SAT_IMPL(qs16x4, qs32x4)\nMULQ_SAT_IMPL(qs16x8, qs32x8)\nMULQ_SAT_IMPL(qs16x16, qs32x16)\n\n#define MUL_SAT_OP_EXPAND_STR(a, b, type, size, position) mul_sat_##type##x##size((a), (b), (position))\n#define MUL_SAT_OP_EXPAND(a, b, type, size, position) MUL_SAT_OP_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate multiply-accumulate\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate. The result is saturated in case of overflow\n */\n#define MLAQ_SAT_IMPL(type, itype)                                                                                 \\\n    type mla_sat_##type(type VopA, type VopB, type VopC, int fixed_point_position)                                 \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, CONVERT_SAT(res >> (itype)fixed_point_position, type));                               \\\n    }\n\nMLAQ_SAT_IMPL(qs8x8, qs16x8)\nMLAQ_SAT_IMPL(qs8x16, qs16x16)\nMLAQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mla_sat_##type##x##size((a), (b), (c), (position))\n#define MLA_SAT_OP_EXPAND(a, b, c, type, size, position) MLA_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate multiply-accumulate long\n *\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point multiply-accumulate long. The result is saturated in case of overflow\n */\n#define MLALQ_SAT_IMPL(type, itype)                                                                                \\\n    itype mlal_sat_##type(itype VopA, type VopB, type VopC, int fixed_point_position)                              \\\n    {                                                                                                              \\\n        itype res = mad_sat(CONVERT(VopB, itype), CONVERT(VopC, itype), (itype)(1 << (fixed_point_position - 1))); \\\n        return add_sat(VopA, res >> (itype)fixed_point_position);                                                  \\\n    }\n\nMLALQ_SAT_IMPL(qs8x8, qs16x8)\nMLALQ_SAT_IMPL(qs16x8, qs32x8)\n\n#define MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position) mlal_sat_##type##x##size((a), (b), (c), (position))\n#define MLAL_SAT_OP_EXPAND(a, b, c, type, size, position) MLAL_SAT_OP_EXPAND_STR(a, b, c, type, size, position)\n\n/** Saturate division of two fixed point vectors\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] itype the intermediate data type.\n *\n * @return The result of the fixed point division. The result is saturated in case of overflow\n */\n#define DIVQ_SAT_IMPL(stype, type, itype)                                                                                                                                           \\\n    inline type div_sat_##type(type VopA, type VopB, int fixed_point_position)                                                                                                      \\\n    {                                                                                                                                                                               \\\n        itype conv_a      = CONVERT((VopA), itype);                                                                                                                                 \\\n        itype denominator = CONVERT((VopB), itype);                                                                                                                                 \\\n        itype numerator   = conv_a << (itype)(fixed_point_position);                                                                                                                \\\n        itype res         = select((itype)(numerator / denominator), select((itype)stype##_MAX, (itype)stype##_MIN, (itype)(conv_a < (itype)0)), (itype)(denominator == (itype)0)); \\\n        return CONVERT_SAT((res), type);                                                                                                                                            \\\n    }\n\nDIVQ_SAT_IMPL(qs8, qs8x16, qs16x16)\nDIVQ_SAT_IMPL(qs16, qs16x8, qs32x8)\nDIVQ_SAT_IMPL(qs16, qs16x16, qs32x16)\nDIVQ_SAT_IMPL(qs8, qs8, qs16)\nDIVQ_SAT_IMPL(qs16, qs16, qs32)\n\n#define DIV_SAT_OP_EXPAND_STR(a, b, type, position) div_sat_##type((a), (b), (position))\n#define DIV_SAT_OP_EXPAND(a, b, type, position) DIV_SAT_OP_EXPAND_STR(a, b, type, position)\n\n#define DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position) div_sat_##type##x##size((a), (b), (position))\n#define DIV_SAT_OP_VEC_EXPAND(a, b, type, size, position) DIV_SAT_OP_VEC_EXPAND_STR(a, b, type, size, position)\n\n/** Saturate exponential of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the exponential function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point exponential. The result is saturated in case of overflow\n */\n#define EXPQ_IMPL(stype, type, size)                                                                                                              \\\n    inline type exp_sat_##type(type VopA, int fixed_point_position)                                                                               \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type ln2       = (type)((((0x58B9 >> (14 - fixed_point_position))) + 1) >> 1);                                                            \\\n        type inv_ln2   = (type)((((0x38AA >> (14 - fixed_point_position)) + 1) >> 1)) | const_one;                                                \\\n        type A         = (type)(((0x7FBA >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type B         = (type)(((0x3FE9 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type C         = (type)(((0x1693 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type D         = (type)(((0x0592 >> (14 - fixed_point_position)) + 1) >> 1);                                                              \\\n        type m         = MUL_SAT_OP_EXPAND(VopA, inv_ln2, stype, size, fixed_point_position);                                                     \\\n        type dec_m     = m >> (type)fixed_point_position;                                                                                         \\\n        type alpha     = MUL_SAT_OP_EXPAND(dec_m << (type)fixed_point_position, ln2, stype, size, fixed_point_position);                          \\\n        alpha          = CONVERT(abs_diff(VopA, alpha), type);                                                                                    \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(alpha, D, stype, size, fixed_point_position), C);                                              \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), B);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), A);                                            \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(alpha, sum, stype, size, fixed_point_position), const_one);                                    \\\n        return select((type)stype##_MAX, select(sum << dec_m, sum >> -dec_m, dec_m < (type)0), clz(sum) > dec_m); /* Saturate result if needed */ \\\n    }\n\nEXPQ_IMPL(qs8, qs8x2, 2)\nEXPQ_IMPL(qs8, qs8x4, 4)\nEXPQ_IMPL(qs8, qs8x8, 8)\nEXPQ_IMPL(qs8, qs8x16, 16)\nEXPQ_IMPL(qs16, qs16x2, 2)\nEXPQ_IMPL(qs16, qs16x4, 4)\nEXPQ_IMPL(qs16, qs16x8, 8)\nEXPQ_IMPL(qs16, qs16x16, 16)\n\n#define EXP_OP_EXPAND_STR(a, type, size, position) exp_sat_##type##x##size((a), (position))\n#define EXP_OP_EXPAND(a, type, size, position) EXP_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate logarithm of a fixed point vector\n *\n * @note Implemented approach uses taylor polynomial to approximate the logarithm function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point logarithm. The result is saturated in case of overflow\n */\n#define LOGQ_IMPL(stype, type, size)                                                                                                       \\\n    inline type log_sat_##type(type VopA, int fixed_point_position)                                                                        \\\n    {                                                                                                                                      \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                              \\\n        type ln2       = (type)(0x58B9 >> (15 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type A         = (type)(0x5C0F >> (14 - fixed_point_position));  /* 1.4384189 */                                                   \\\n        type B         = -(type)(0x56AE >> (15 - fixed_point_position)); /* -0.6771900 */                                                  \\\n        type C         = (type)(0x2933 >> (15 - fixed_point_position));  /* 0.3218538 */                                                   \\\n        type D         = -(type)(0x0AA7 >> (15 - fixed_point_position)); /* -0.0832229 */                                                  \\\n        type inter_a   = select(VopA, DIV_SAT_OP_VEC_EXPAND(const_one, VopA, stype, size, fixed_point_position), VopA < const_one);        \\\n        type shift_val = (type)(15 - stype##_SHIFT) - clz(inter_a >> (type)fixed_point_position);                                          \\\n        inter_a        = inter_a >> shift_val;                                                                                             \\\n        inter_a        = sub_sat(inter_a, const_one);                                                                                      \\\n        type sum       = add_sat(MUL_SAT_OP_EXPAND(inter_a, D, stype, size, fixed_point_position), C);                                     \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), B);                                   \\\n        sum            = add_sat(MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position), A);                                   \\\n        sum            = MUL_SAT_OP_EXPAND(inter_a, sum, stype, size, fixed_point_position);                                               \\\n        sum            = MUL_SAT_OP_EXPAND(add_sat(sum, shift_val << (type)fixed_point_position), ln2, stype, size, fixed_point_position); \\\n        return select(select(sum, -sum, VopA < const_one), (type)0, VopA < (type)0); /* Saturate result if needed */                       \\\n    }\n\nLOGQ_IMPL(qs8, qs8x16, 16)\nLOGQ_IMPL(qs16, qs16x8, 8)\nLOGQ_IMPL(qs16, qs16x16, 16)\n\n#define LOG_OP_EXPAND_STR(a, type, size, position) log_sat_##type##x##size((a), (position))\n#define LOG_OP_EXPAND(a, type, size, position) LOG_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate inverse square root of a fixed point vector\n *\n * @note Implemented approach uses Newton's method to approximate the inverse square root function.\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point inverse square root. The result is saturated in case of overflow\n */\n#define INVSQRTQ_IMPL(stype, type, size)                                                                                                                                                                                               \\\n    inline type invsqrt_sat_##type(type VopA, int fixed_point_position)                                                                                                                                                                \\\n    {                                                                                                                                                                                                                                  \\\n        type const_three = (type)(3 << (fixed_point_position));                                                                                                                                                                        \\\n        type shift_value = (type)(16 - stype##_SHIFT) - (clz(VopA) + (type)fixed_point_position);                                                                                                                                      \\\n        type temp        = select((type)(VopA >> shift_value), select((type)stype##_MAX, (type)(VopA << (-shift_value)), (type)(clz(VopA) > (-shift_value))), (type)(shift_value < (type)0));                                          \\\n        type x           = temp;                                                                                                                                                                                                       \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        x                = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1; \\\n        if(sizeof((stype)(1)) > 1) /* Perform more iterations if datatype is QS16 */                                                                                                                                                   \\\n        {                                                                                                                                                                                                                              \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n            x = MUL_SAT_OP_EXPAND(x, sub_sat(const_three, MUL_SAT_OP_EXPAND(MUL_SAT_OP_EXPAND(x, x, stype, size, fixed_point_position), temp, stype, size, fixed_point_position)), stype, size, fixed_point_position) >> 1;            \\\n        }                                                                                                                                                                                                                              \\\n        type shift_value2 = select(shift_value >> 1, (-shift_value) >> 1, shift_value < (type)0);                                                                                                                                      \\\n        return select((type)(x >> shift_value2), select((type)stype##_MAX, (type)(x << shift_value2), (type)(clz(x) > shift_value2)), (type)(shift_value < (type)0)); /* Saturate result if needed */                                  \\\n    }\n\nINVSQRTQ_IMPL(qs8, qs8x1, 1)\nINVSQRTQ_IMPL(qs16, qs16x1, 1)\nINVSQRTQ_IMPL(qs8, qs8x16, 16)\nINVSQRTQ_IMPL(qs16, qs16x8, 8)\n\n#define INVSQRT_OP_EXPAND_STR(a, type, size, position) invsqrt_sat_##type##x##size((a), (position))\n#define INVSQRT_OP_EXPAND(a, type, size, position) INVSQRT_OP_EXPAND_STR(a, type, size, position)\n\n/** Saturate hyperbolic tangent of a fixed point vector\n *\n * tanh(x) = (e^2x - 1)/(e^2x + 1)\n *\n * @param[in] stype the actual scalar data type.\n * @param[in] type  the actual data type.\n * @param[in] size  the number of the calculated elements.\n *\n * @return The result of the fixed point hyperbolic tangent. The result is saturated in case of overflow\n */\n#define TANHQ_IMPL(stype, type, size)                                                                                                             \\\n    inline type tanh_sat_##type(type VopA, int fixed_point_position)                                                                              \\\n    {                                                                                                                                             \\\n        type const_one = (type)(1 << (fixed_point_position));                                                                                     \\\n        type const_two = (type)(2 << (fixed_point_position));                                                                                     \\\n        type exp2x     = EXP_OP_EXPAND(MUL_SAT_OP_EXPAND(const_two, VopA, stype, size, fixed_point_position), stype, size, fixed_point_position); \\\n        type num       = SUB_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        type den       = ADD_SAT_OP_EXPAND(exp2x, const_one, stype, size);                                                                        \\\n        return DIV_SAT_OP_VEC_EXPAND(num, den, stype, size, fixed_point_position);                                                                \\\n    }\n\nTANHQ_IMPL(qs8, qs8x16, 16)\nTANHQ_IMPL(qs16, qs16x8, 8)\n\n#define TANH_OP_EXPAND_STR(a, type, size, position) tanh_sat_##type##x##size((a), (position))\n#define TANH_OP_EXPAND(a, type, size, position) TANH_OP_EXPAND_STR(a, type, size, position)\n\n#define floatx16 float16\n#define float16_TYPE float16\n\n#define CONVERTQ_DOWN_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position)                                            \\\n    {                                                                                                                              \\\n        return CONVERT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_IMPL(float16, qs16x16)\n\n#define CONVERTQ_DOWN_SAT_IMPL(in_type, out_type)                                                                                      \\\n    inline out_type convert_##out_type##_##in_type##_sat(in_type a, int fixed_point_position)                                          \\\n    {                                                                                                                                  \\\n        return CONVERT_SAT(a * (1 << fixed_point_position) + select((in_type)-0.5, (in_type)0.5, isgreater(a, (in_type)0)), out_type); \\\n    }\n\nCONVERTQ_DOWN_SAT_IMPL(float16, qs8x16)\nCONVERTQ_DOWN_SAT_IMPL(float16, qs16x16)\n\n#define CONVERTQ_UP_IMPL(in_type, out_type)                                             \\\n    inline out_type convert_##out_type##_##in_type(in_type a, int fixed_point_position) \\\n    {                                                                                   \\\n        return CONVERT(a, out_type) / (1 << fixed_point_position);                      \\\n    }\n\nCONVERTQ_UP_IMPL(qs8x16, float16)\nCONVERTQ_UP_IMPL(qs16x16, float16)\n\n#define SQCVT_SAT_IMPL(type)                                                                    \\\n    inline type sqcvt_##type##_sat(float a, int fixed_point_position)                           \\\n    {                                                                                           \\\n        return CONVERT_SAT((a * (1 << fixed_point_position) + ((a < 0) ? -0.5f : 0.5f)), type); \\\n    }\n\nSQCVT_SAT_IMPL(qs8)\nSQCVT_SAT_IMPL(qs16)\n\n#define SQCVT_SAT_OP_EXPAND_STR(a, type, position) sqcvt_##type##_sat((a), (position))\n#define SQCVT_SAT_OP_EXPAND(a, type, position) SQCVT_SAT_OP_EXPAND_STR((a), type, position)\n\n#endif // ARM_COMPUTE_FIXED_POINT_H\n#define MAX_OP(x, y, type, size) MAX_OP_EXPAND(x, y, type, size)\n#define ADD_OP(x, y, type, size) ADD_SAT_OP_EXPAND((x), (y), type, size)\n#define SUB_OP(x, y, type, size) SUB_SAT_OP_EXPAND((x), (y), type, size)\n#define MUL_OP(x, y, type, size) MUL_SAT_OP_EXPAND((x), (y), type, size, FIXED_POINT_POSITION)\n#define DIV_OP(x, y, type, size) DIV_SAT_OP_VEC_EXPAND((x), (y), type, size, FIXED_POINT_POSITION)\n#define EXP_OP(x, type, size) EXP_OP_EXPAND((x), type, size, FIXED_POINT_POSITION)\n\n#define MIN_VAL_EXPAND(type) type##_MIN\n#define MIN_VAL(type) MIN_VAL_EXPAND(type)\n#define MINVAL MIN_VAL(DATA_TYPE)\n#define SELECT_DATA_TYPE EXPAND(DATA_TYPE)\n\n#else /* FIXED_POINT_POSITION */\n\n#define MAX_OP(x, y, type, size) max((x), (y))\n#define ADD_OP(x, y, type, size) ((x) + (y))\n#define SUB_OP(x, y, type, size) ((x) - (y))\n#define MUL_OP(x, y, type, size) ((x) * (y))\n#define DIV_OP(x, y, type, size) ((x) / (y))\n#define EXP_OP(x, type, size) exp((x))\n\n#ifdef USE_F16\n#define MINVAL -HALF_MAX\n#define SELECT_DATA_TYPE short\n#else /* USE_F16 */\n#define MINVAL -FLT_MAX\n#define SELECT_DATA_TYPE int\n#endif /* USE_F16 */\n\n#endif /* FIXED_POINT_POSITION */\n\n/* Number of workitems in dimension 0. */\n#if !defined(GRID_SIZE)\n#define GRID_SIZE 1\n#endif /* !defined(GRID_SIZE) */\n\n/* Vector size, i.e. number of vector elements. */\n#if VECTOR_SIZE == 2\n__constant VEC_DATA_TYPE(DATA_TYPE, 2) type_min_ = (VEC_DATA_TYPE(DATA_TYPE, 2))(MINVAL);\n__constant uint2 idx__ = (uint2)(0, 1);\n\n#elif VECTOR_SIZE == 4\n__constant VEC_DATA_TYPE(DATA_TYPE, 4) type_min_ = (VEC_DATA_TYPE(DATA_TYPE, 4))(MINVAL);\n__constant uint4 idx__ = (uint4)(0, 1, 2, 3);\n\n#elif VECTOR_SIZE == 8\n__constant VEC_DATA_TYPE(DATA_TYPE, 8) type_min_ = (VEC_DATA_TYPE(DATA_TYPE, 8))(MINVAL);\n__constant uint8 idx__ = (uint8)(0, 1, 2, 3, 4, 5, 6, 7);\n\n#else /* VECTOR_SIZE DEFAULT */\n#define VECTOR_SIZE 16\n#define LOG_VECTOR_SIZE 4\n__constant VEC_DATA_TYPE(DATA_TYPE, 16) type_min_ = (VEC_DATA_TYPE(DATA_TYPE, 16))(MINVAL);\n__constant uint16 idx__ = (uint16)(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n\n#endif /* VECTOR_SIZE END */\n\n// TODO (COMPMID-661): Remove if the non-fused kernels are removed\n__constant VEC_DATA_TYPE(DATA_TYPE, 16) type_min = (VEC_DATA_TYPE(DATA_TYPE, 16))(MINVAL);\n__constant uint16 idx16 = (uint16)(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n__constant uint4 idx4   = (uint4)(0, 1, 2, 3);\n\n/** Identifies the maximum value across the 1st dimension.\n *\n * @note Datatype must be given as a preprocessor argument using -DDATA_TYPE=type. e.g. -DDATA_TYPE=short\n * @note Fixed point position must be given as a preprocessor argument using -DFIXED_POINT_POSITION=pos. e.g. DFIXED_POINT_POSITION=4\n * @note In case the input is not multiple of 16 -DNON_MULTIPLE_OF_16 must be passed.\n *\n * @param[in]  src_ptr                           Pointer to the source tensor slice. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                      Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                        src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                      Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                        src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                      Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                        src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes The offset of the first element in the source tensor\n * @param[out] dst_ptr                           Pointer to the destination tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                      Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                        dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                      Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                        dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_stride_z                      Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                        dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes The offset of the first element in the destination tensor\n * @param[in]  width                             Input image width\n */\n__kernel void softmax_layer_max(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(dst),\n    uint width)\n{\n    Image src = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(src);\n    Image dst = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(dst);\n\n    // Initialize local maximum\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    max_val = (VEC_DATA_TYPE(DATA_TYPE, 16))type_min;\n\n    // Calculate max of row\n    const uint width4 = width >> 4;\n    for(uint i = 0; i < width4; i++)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, 16)\n        data    = vload16(0, (__global DATA_TYPE *)offset(&src, i << 4, 0));\n        max_val = MAX_OP(data, max_val, DATA_TYPE, 16);\n    }\n\n#ifdef NON_MULTIPLE_OF_16\n    // Handle non multiple of 16\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    data = vload16(0, (__global DATA_TYPE *)offset(&src, width4 << 4, 0));\n    VEC_DATA_TYPE(SELECT_DATA_TYPE, 16)\n    widx    = CONVERT(((uint16)(width4 << 4) + idx16) < width, VEC_DATA_TYPE(SELECT_DATA_TYPE, 16));\n    max_val = MAX_OP(max_val, select(type_min, data, widx), DATA_TYPE, 16);\n#endif /* NON_MULTIPLE_OF_16 */\n\n    // Perform max reduction\n    max_val.s01234567 = MAX_OP(max_val.s01234567, max_val.s89ABCDEF, DATA_TYPE, 8);\n    max_val.s0123     = MAX_OP(max_val.s0123, max_val.s4567, DATA_TYPE, 4);\n    max_val.s01       = MAX_OP(max_val.s01, max_val.s23, DATA_TYPE, 2);\n    max_val.s0        = MAX_OP(max_val.s0, max_val.s1, DATA_TYPE, 1);\n\n    // Store result\n    *((__global DATA_TYPE *)dst.ptr) = max_val.s0;\n}\n\n/** Shifts the values of the input tensor by the max calculated in softmax_layer_max kernel,\n * then gets the exponent of each element as sums all elements across each row.\n *\n * @note Datatype must be given as a preprocessor argument using -DDATA_TYPE=type. e.g. -DDATA_TYPE=short\n * @note Fixed point position must be given as a preprocessor argument using -DFIXED_POINT_POSITION=pos. e.g. DFIXED_POINT_POSITION=4\n * @note In case the input is not multiple of 16 -DNON_MULTIPLE_OF_16 must be passed.\n * @note Beta can be optionally passed at compile time using -DBETA (if undefined, assume it equals 1.0)\n *\n * @param[in]  src_ptr                           Pointer to the source tensor slice. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                      Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                        src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                      Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                        src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                      Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                        src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes The offset of the first element in the source tensor\n * @param[in]  max_ptr                           Pointer to the max values tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  max_stride_x                      Stride of the max values tensor in X dimension (in bytes)\n * @param[in]  max_step_x                        max_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  max_stride_y                      Stride of the max values tensor in Y dimension (in bytes)\n * @param[in]  max_step_y                        max_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  max_stride_z                      Stride of the max values tensor in Z dimension (in bytes)\n * @param[in]  max_step_z                        max_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  max_offset_first_element_in_bytes The offset of the first element in the max values tensor\n * @param[out] dst_ptr                           Pointer to the destination tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                      Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                        dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                      Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                        dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_stride_z                      Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                        dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes The offset of the first element in the destination tensor\n * @param[out] sum_ptr                           Pointer to the sum values tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  sum_stride_x                      Stride of the sum values tensor in X dimension (in bytes)\n * @param[in]  sum_step_x                        sum_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  sum_stride_y                      Stride of the sum values tensor in Y dimension (in bytes)\n * @param[in]  sum_step_y                        sum_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  sum_stride_z                      Stride of the sum values tensor in Z dimension (in bytes)\n * @param[in]  sum_step_z                        sum_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  sum_offset_first_element_in_bytes The offset of the first element in the sum values tensor\n * @param[in]  width                             Input image width\n */\n__kernel void softmax_layer_shift_exp_sum(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(max),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(sum),\n    uint width)\n{\n    Image src = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(src);\n    Image dst = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(dst);\n    Image max = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(max);\n    Image sum = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(sum);\n\n#ifdef BETA\n    // Initialize beta\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    beta = (VEC_DATA_TYPE(DATA_TYPE, 16))BETA;\n#endif /* BETA */\n\n    // Load max value of 1D logits vector (row)\n    DATA_TYPE max_val = *((__global DATA_TYPE *)offset(&max, 0, 0));\n\n    // Set sum vector\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    sum1D = 0;\n\n    // Shift values, exp and sum\n    const uint width4 = width >> 4;\n    for(uint i = 0; i < width4; i++)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, 16)\n        data = vload16(0, (__global DATA_TYPE *)offset(&src, i << 4, 0));\n        data = SUB_OP(data, max_val, DATA_TYPE, 16);\n#ifdef BETA\n        data = MUL_OP(data, beta, DATA_TYPE, 16);\n#endif /* BETA */\n        data = EXP_OP(data, DATA_TYPE, 16);\n        vstore16(data, 0, (__global DATA_TYPE *)offset(&dst, i << 4, 0));\n        sum1D = ADD_OP(sum1D, data, DATA_TYPE, 16);\n    }\n\n#ifdef NON_MULTIPLE_OF_16\n    // Handle non multiple of 16\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    data = vload16(0, (__global DATA_TYPE *)offset(&src, width4 << 4, 0));\n    data = SUB_OP(data, max_val, DATA_TYPE, 16);\n#ifdef BETA\n    data = MUL_OP(data, beta, DATA_TYPE, 16);\n#endif /* BETA */\n    data = EXP_OP(data, DATA_TYPE, 16);\n    VEC_DATA_TYPE(SELECT_DATA_TYPE, 16)\n    widx = CONVERT(((uint16)(width4 << 4) + idx16) < width, VEC_DATA_TYPE(SELECT_DATA_TYPE, 16));\n    data = select(0, data, widx);\n    vstore16(data, 0, (__global DATA_TYPE *)offset(&dst, width4 << 4, 0));\n    sum1D = ADD_OP(sum1D, data, DATA_TYPE, 16);\n#endif /* NON_MULTIPLE_OF_16 */\n\n    // Perform min/max reduction\n    sum1D.s01234567 = ADD_OP(sum1D.s01234567, sum1D.s89ABCDEF, DATA_TYPE, 8);\n    sum1D.s0123     = ADD_OP(sum1D.s0123, sum1D.s4567, DATA_TYPE, 4);\n    sum1D.s01       = ADD_OP(sum1D.s01, sum1D.s23, DATA_TYPE, 2);\n    sum1D.s0        = ADD_OP(sum1D.s0, sum1D.s1, DATA_TYPE, 1);\n\n    // Calculate and store result\n    *((__global DATA_TYPE *)sum.ptr) = sum1D.s0;\n}\n\n/** Divides all the values of the input tensor by the sum calculated from softmax_layer_shift_exp_sum kernel.\n *\n * @note Datatype must be given as a preprocessor argument using -DDATA_TYPE=type. e.g. -DDATA_TYPE=short\n * @note Fixed point position must be given as a preprocessor argument using -DFIXED_POINT_POSITION=pos. e.g. DFIXED_POINT_POSITION=4\n *\n * @param[in]  src_ptr                           Pointer to the source tensor slice. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                      Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                        src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                      Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                        src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                      Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                        src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes The offset of the first element in the source tensor\n * @param[in]  sum_ptr                           Pointer to the sum values tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  sum_stride_x                      Stride of the sum values tensor in X dimension (in bytes)\n * @param[in]  sum_step_x                        sum_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  sum_stride_y                      Stride of the sum values tensor in Y dimension (in bytes)\n * @param[in]  sum_step_y                        sum_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  sum_stride_z                      Stride of the sum values tensor in Z dimension (in bytes)\n * @param[in]  sum_step_z                        sum_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  sum_offset_first_element_in_bytes The offset of the first element in the sum values tensor\n * @param[out] dst_ptr                           Pointer to the destination tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                      Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                        dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                      Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                        dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_stride_z                      Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                        dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes The offset of the first element in the destination tensor\n */\n__kernel void softmax_layer_norm(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(sum),\n    TENSOR3D_DECLARATION(dst))\n{\n    Image src = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(src);\n    Image dst = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(dst);\n    Image sum = CONVERT_TENSOR3D_TO_IMAGE_STRUCT_NO_STEP(sum);\n\n    // Load max value of 1D logits vector (row)\n    DATA_TYPE sum_val = *((__global DATA_TYPE *)offset(&sum, 0, get_global_id(1)));\n    VEC_DATA_TYPE(DATA_TYPE, 16)\n    data = vload16(0, (__global DATA_TYPE *)offset(&src, 0, 0));\n    vstore16(DIV_OP(data, sum_val, DATA_TYPE, 16), 0, (__global DATA_TYPE *)offset(&dst, 0, 0));\n}\n\n/** Identifies the maximum value across the 1st dimension and shifts the values of the input tensor by this maximum value,\n * then gets the exponent of each element as sums all elements across each row.\n *\n * @note Datatype must be given as a preprocessor argument using -DDATA_TYPE=type. e.g. -DDATA_TYPE=short\n * @note Fixed point position must be given as a preprocessor argument using -DFIXED_POINT_POSITION=pos. e.g. DFIXED_POINT_POSITION=4\n * @note In case the input is not a multiple of VECTOR_SIZE (2,4,8,16) -DNON_MULTIPLE_OF_VECTOR_SIZE must be passed.\n * @note Beta can be optionally passed at compile time using -DBETA (by default, it is 1.0).\n *\n * @param[in]  src_ptr                            Pointer to the source tensor slice. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                       Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                         src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                       Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                         src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                       Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                         src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes  The offset of the first element in the source tensor\n * @param[in]  maxo_ptr                           Pointer to the max values tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  maxo_stride_x                      Stride of the max values tensor in X dimension (in bytes)\n * @param[in]  maxo_step_x                        max_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  maxo_stride_y                      Stride of the max values tensor in Y dimension (in bytes)\n * @param[in]  maxo_step_y                        max_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  maxo_stride_z                      Stride of the max values tensor in Z dimension (in bytes)\n * @param[in]  maxo_step_z                        max_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  maxo_offset_first_element_in_bytes The offset of the first element in the max values tensor\n * @param[out] dst_ptr                            Pointer to the destination tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                       Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                         dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                       Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                         dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_stride_z                       Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                         dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes  The offset of the first element in the destination tensor\n * @param[out] sum_ptr                            Pointer to the sum values tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  sum_stride_x                       Stride of the sum values tensor in X dimension (in bytes)\n * @param[in]  sum_step_x                         sum_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  sum_stride_y                       Stride of the sum values tensor in Y dimension (in bytes)\n * @param[in]  sum_step_y                         sum_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  sum_stride_z                       Stride of the sum values tensor in Z dimension (in bytes)\n * @param[in]  sum_step_z                         sum_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  sum_offset_first_element_in_bytes  The offset of the first element in the sum values tensor\n * @param[in]  width                              Input image width\n */\n__kernel void softmax_layer_max_shift_exp_sum_serial(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(maxo),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(sum),\n    uint width)\n{\n    Image src  = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(src);\n    Image dst  = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(dst);\n    Image maxo = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(maxo);\n    Image sum  = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(sum);\n\n#ifdef BETA\n    // Initialize beta\n    VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE)\n    beta = (VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE))BETA;\n#endif /* BETA */\n\n    // Initialize local maximum\n    VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE)\n    max_val_vec = (VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE))type_min_;\n\n    // Calculate max of row\n    const uint width_ = width >> LOG_VECTOR_SIZE;\n    for(uint i = 0; i < width_; i++)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE)\n        data_max    = VLOAD(VECTOR_SIZE)(0, (__global DATA_TYPE *)offset(&src, i << LOG_VECTOR_SIZE, 0));\n        max_val_vec = MAX_OP(data_max, max_val_vec, DATA_TYPE, VECTOR_SIZE);\n    }\n\n#ifdef NON_MULTIPLE_OF_VECTOR_SIZE\n    VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE)\n    data_max = VLOAD(VECTOR_SIZE)(0, (__global DATA_TYPE *)offset(&src, width_ << LOG_VECTOR_SIZE, 0));\n    VEC_DATA_TYPE(SELECT_DATA_TYPE, VECTOR_SIZE)\n    widx        = CONVERT((EXPAND((CL_VEC_DATA_TYPE(uint, VECTOR_SIZE)))(width_ << LOG_VECTOR_SIZE) + idx__) < width, VEC_DATA_TYPE(SELECT_DATA_TYPE, VECTOR_SIZE));\n    max_val_vec = MAX_OP(max_val_vec, select(type_min_, data_max, widx), DATA_TYPE, VECTOR_SIZE);\n#endif /* NON_MULTIPLE_OF_VECTOR_SIZE */\n\n    // Perform max reduction\n#if VECTOR_SIZE == 16\n    max_val_vec.s01234567 = MAX_OP(max_val_vec.s01234567, max_val_vec.s89ABCDEF, DATA_TYPE, 8);\n#endif /* VECTOR SIZE 16 END */\n#if VECTOR_SIZE >= 8\n    max_val_vec.s0123 = MAX_OP(max_val_vec.s0123, max_val_vec.s4567, DATA_TYPE, 4);\n#endif /* VECTOR SIZE 8 END */\n#if VECTOR_SIZE >= 4\n    max_val_vec.s01 = MAX_OP(max_val_vec.s01, max_val_vec.s23, DATA_TYPE, 2);\n#endif /* VECTOR SIZE 4 END */\n    max_val_vec.s0 = MAX_OP(max_val_vec.s0, max_val_vec.s1, DATA_TYPE, 1);\n    // Store result\n    *((__global DATA_TYPE *)maxo.ptr) = max_val_vec.s0;\n\n    /* Second section */\n\n    // Load max value of 1D logits vector (row)\n    DATA_TYPE max_val = *((__global DATA_TYPE *)offset(&maxo, 0, 0));\n\n    // Set sum vector\n    VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE)\n    sum1D = 0;\n\n    // Shift values, exp and sum\n    for(uint i = 0; i < width_; i++)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE)\n        data = VLOAD(VECTOR_SIZE)(0, (__global DATA_TYPE *)offset(&src, i << LOG_VECTOR_SIZE, 0));\n        data = SUB_OP(data, max_val, DATA_TYPE, VECTOR_SIZE);\n#ifdef BETA\n        data = MUL_OP(data, beta, DATA_TYPE, VECTOR_SIZE);\n#endif /* BETA */\n        data = EXP_OP(data, DATA_TYPE, VECTOR_SIZE);\n        VSTORE(VECTOR_SIZE)\n        (data, 0, (__global DATA_TYPE *)offset(&dst, i << LOG_VECTOR_SIZE, 0));\n        sum1D = ADD_OP(sum1D, data, DATA_TYPE, VECTOR_SIZE);\n    }\n\n#ifdef NON_MULTIPLE_OF_VECTOR_SIZE\n    VEC_DATA_TYPE(DATA_TYPE, VECTOR_SIZE)\n    data = VLOAD(VECTOR_SIZE)(0, (__global DATA_TYPE *)offset(&src, width_ << LOG_VECTOR_SIZE, 0));\n    data = SUB_OP(data, max_val, DATA_TYPE, VECTOR_SIZE);\n#ifdef BETA\n    data = MUL_OP(data, beta, DATA_TYPE, VECTOR_SIZE);\n#endif /* BETA */\n    data = EXP_OP(data, DATA_TYPE, VECTOR_SIZE);\n    widx = CONVERT((EXPAND((CL_VEC_DATA_TYPE(uint, VECTOR_SIZE)))(width_ << LOG_VECTOR_SIZE) + idx__) < width, VEC_DATA_TYPE(SELECT_DATA_TYPE, VECTOR_SIZE));\n    data = select(0, data, widx);\n    VSTORE(VECTOR_SIZE)\n    (data, 0, (__global DATA_TYPE *)offset(&dst, width_ << LOG_VECTOR_SIZE, 0));\n    sum1D = ADD_OP(sum1D, data, DATA_TYPE, VECTOR_SIZE);\n#endif /* NON_MULTIPLE_OF_VECTOR_SIZE */\n\n    // Perform sum reduction\n#if VECTOR_SIZE == 16\n    sum1D.s01234567 = ADD_OP(sum1D.s01234567, sum1D.s89ABCDEF, DATA_TYPE, 8);\n#endif /* VECTOR SIZE 16 END */\n#if VECTOR_SIZE >= 8\n    sum1D.s0123 = ADD_OP(sum1D.s0123, sum1D.s4567, DATA_TYPE, 4);\n#endif /* VECTOR SIZE 8 END */\n#if VECTOR_SIZE >= 4\n    sum1D.s01 = ADD_OP(sum1D.s01, sum1D.s23, DATA_TYPE, 2);\n#endif /* VECTOR SIZE 4 END */\n    sum1D.s0 = ADD_OP(sum1D.s0, sum1D.s1, DATA_TYPE, 1);\n\n    // Calculate and store result\n    *((__global DATA_TYPE *)sum.ptr) = sum1D.s0;\n}\n\n/** Identifies the maximum value across the 1st dimension and shifts the values of the input tensor by this maximum value,\n * then gets the exponent of each element as sums all elements across each row.\n *\n * @note Datatype must be given as a preprocessor argument using -DDATA_TYPE=type. e.g. -DDATA_TYPE=short\n * @note Fixed point position must be given as a preprocessor argument using -DFIXED_POINT_POSITION=pos. e.g. DFIXED_POINT_POSITION=4\n * @note In case the input is not a multiple of VECTOR_SIZE (2,4,8,16) -DNON_MULTIPLE_OF_VECTOR_SIZE must be passed.\n * @note Beta can be optionally passed at compile time using -DBETA (by default, it is 1.0).\n *\n * @param[in]  src_ptr                            Pointer to the source tensor slice. Supported data types: QS8/QS16/F16/F32\n * @param[in]  src_stride_x                       Stride of the source tensor in X dimension (in bytes)\n * @param[in]  src_step_x                         src_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  src_stride_y                       Stride of the source tensor in Y dimension (in bytes)\n * @param[in]  src_step_y                         src_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  src_stride_z                       Stride of the source tensor in Z dimension (in bytes)\n * @param[in]  src_step_z                         src_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  src_offset_first_element_in_bytes  The offset of the first element in the source tensor\n * @param[in]  maxo_ptr                           Pointer to the max values tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  maxo_stride_x                      Stride of the max values tensor in X dimension (in bytes)\n * @param[in]  maxo_step_x                        max_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  maxo_stride_y                      Stride of the max values tensor in Y dimension (in bytes)\n * @param[in]  maxo_step_y                        max_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  maxo_stride_z                      Stride of the max values tensor in Z dimension (in bytes)\n * @param[in]  maxo_step_z                        max_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  maxo_offset_first_element_in_bytes The offset of the first element in the max values tensor\n * @param[out] dst_ptr                            Pointer to the destination tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  dst_stride_x                       Stride of the destination tensor in X dimension (in bytes)\n * @param[in]  dst_step_x                         dst_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  dst_stride_y                       Stride of the destination tensor in Y dimension (in bytes)\n * @param[in]  dst_step_y                         dst_stride_y * number of elements along Y processed per workitem(in bytes)\n * @param[in]  dst_stride_z                       Stride of the destination tensor in Z dimension (in bytes)\n * @param[in]  dst_step_z                         dst_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  dst_offset_first_element_in_bytes  The offset of the first element in the destination tensor\n * @param[out] sum_ptr                            Pointer to the sum values tensor slice. Supported data types: same as @p src_ptr\n * @param[in]  sum_stride_x                       Stride of the sum values tensor in X dimension (in bytes)\n * @param[in]  sum_step_x                         sum_stride_x * number of elements along X processed per workitem(in bytes)\n * @param[in]  sum_stride_y                       Stride of the sum values tensor in Y dimension (in bytes)\n * @param[in]  sum_step_y                         sum_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  sum_stride_z                       Stride of the sum values tensor in Z dimension (in bytes)\n * @param[in]  sum_step_z                         sum_stride_z * number of elements along Z processed per workitem(in bytes)\n * @param[in]  sum_offset_first_element_in_bytes  The offset of the first element in the sum values tensor\n * @param[in]  width                              Input image width\n */\n__kernel void softmax_layer_max_shift_exp_sum_parallel(\n    TENSOR3D_DECLARATION(src),\n    TENSOR3D_DECLARATION(maxo),\n    TENSOR3D_DECLARATION(dst),\n    TENSOR3D_DECLARATION(sum),\n    uint width)\n{\n    Image src  = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(src);\n    Image dst  = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(dst);\n    Image maxo = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(maxo);\n    Image sum  = CONVERT_TENSOR3D_TO_IMAGE_STRUCT(sum);\n\n    const uint lid = get_local_id(0);\n\n#ifdef BETA\n    // Initialize beta\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    beta = (VEC_DATA_TYPE(DATA_TYPE, 4))BETA;\n#endif /* BETA */\n\n    // Define one temporary vector per work-item.\n    __local VEC_DATA_TYPE(DATA_TYPE, 4) tmp_local[GRID_SIZE];\n    __local DATA_TYPE max_local;\n\n    __constant VEC_DATA_TYPE(DATA_TYPE, 4) type_min4 = (VEC_DATA_TYPE(DATA_TYPE, 4))(MINVAL);\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    max_val_vec = (VEC_DATA_TYPE(DATA_TYPE, 4))type_min4;\n    // Number of elements per work-item.\n    const uint row = width / GRID_SIZE;\n    // Number of iterations per work-item.\n    const uint width_ = row >> 2;\n    // Calculate max of row\n    uint i = 0;\n    for(; i < width_; i++)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, 4)\n        data_max    = VLOAD(4)(0, (__global DATA_TYPE *)offset(&src, i * GRID_SIZE * 4, 0));\n        max_val_vec = MAX_OP(data_max, max_val_vec, DATA_TYPE, 4);\n    }\n#ifdef NON_MULTIPLE_OF_GRID_SIZE\n    // How many work-items needed to complete the computation.\n    //TODO: Optimize this calculation (avoid %).\n    int boundary_workitems = (width % (GRID_SIZE * 4)) / 4;\n    if(lid < boundary_workitems)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, 4)\n        data_max    = VLOAD(4)(0, (__global DATA_TYPE *)offset(&src, i * GRID_SIZE * 4, 0));\n        max_val_vec = MAX_OP(data_max, max_val_vec, DATA_TYPE, 4);\n    }\n#ifdef NON_MULTIPLE_OF_VECTOR_SIZE\n    if(boundary_workitems == 0)\n    {\n        boundary_workitems = GRID_SIZE;\n        i--;\n    }\n    if(lid == (boundary_workitems - 1))\n    {\n        // Handle non multiple of 4\n        VEC_DATA_TYPE(DATA_TYPE, 4)\n        data_max = VLOAD(4)(0, (__global DATA_TYPE *)offset(&src, (GRID_SIZE * i * 4) + 4, 0));\n        VEC_DATA_TYPE(SELECT_DATA_TYPE, 4)\n        widx        = CONVERT(((uint4)(GRID_SIZE * i * 4) + boundary_workitems * 4 + idx4) < width, VEC_DATA_TYPE(SELECT_DATA_TYPE, 4));\n        max_val_vec = MAX_OP(max_val_vec, select(type_min_, data_max, widx), DATA_TYPE, 4);\n    }\n#endif /* NON_MULTIPLE_OF_VECTOR_SIZE */\n#endif /* NON_MULTIPLE_OF_GRID_SIZE */\n    tmp_local[lid] = max_val_vec;\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n    if(GRID_SIZE >= 256)\n    {\n        if(lid < 128)\n        {\n            tmp_local[lid] = MAX_OP(tmp_local[lid + 128], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 128)\n    {\n        if(lid < 64)\n        {\n            tmp_local[lid] = MAX_OP(tmp_local[lid + 64], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 64)\n    {\n        if(lid < 32)\n        {\n            tmp_local[lid] = MAX_OP(tmp_local[lid + 32], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 32)\n    {\n        if(lid < 16)\n        {\n            tmp_local[lid] = MAX_OP(tmp_local[lid + 16], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 16)\n    {\n        if(lid < 8)\n        {\n            tmp_local[lid] = MAX_OP(tmp_local[lid + 8], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 8)\n    {\n        if(lid < 4)\n        {\n            tmp_local[lid] = MAX_OP(tmp_local[lid + 4], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 4)\n    {\n        if(lid < 2)\n        {\n            tmp_local[lid] = MAX_OP(tmp_local[lid + 2], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(lid == 0)\n    {\n        max_val_vec     = MAX_OP(tmp_local[lid + 1], tmp_local[lid], DATA_TYPE, 4);\n        max_val_vec.s01 = MAX_OP(max_val_vec.s01, max_val_vec.s23, DATA_TYPE, 2);\n        max_val_vec.s0  = MAX_OP(max_val_vec.s0, max_val_vec.s1, DATA_TYPE, 1);\n        max_local       = max_val_vec.s0;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n    /* Second section */\n\n    // Set sum vector\n    VEC_DATA_TYPE(DATA_TYPE, 4)\n    sum1D             = 0;\n    DATA_TYPE max_val = max_local;\n\n    // Shift values, exp and sum\n    for(i = 0; i < width_; i++)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, 4)\n        data = VLOAD(4)(0, (__global DATA_TYPE *)offset(&src, i * GRID_SIZE * 4, 0));\n        data = SUB_OP(data, max_val, DATA_TYPE, 4);\n#ifdef BETA\n        data = MUL_OP(data, beta, DATA_TYPE, 4);\n#endif /* BETA */\n        data = EXP_OP(data, DATA_TYPE, 4);\n        VSTORE(4)\n        (data, 0, (__global DATA_TYPE *)offset(&dst, i * GRID_SIZE * 4, 0));\n        sum1D = ADD_OP(sum1D, data, DATA_TYPE, 4);\n    }\n#ifdef NON_MULTIPLE_OF_GRID_SIZE\n    //TODO: Optimize the calculation (avoid %).\n    boundary_workitems = (width % (GRID_SIZE * 4)) / 4;\n    if(lid < boundary_workitems)\n    {\n        VEC_DATA_TYPE(DATA_TYPE, 4)\n        data = VLOAD(4)(0, (__global DATA_TYPE *)offset(&src, i * GRID_SIZE * 4, 0));\n        data = SUB_OP(data, max_val, DATA_TYPE, 4);\n#ifdef BETA\n        data = MUL_OP(data, beta, DATA_TYPE, 4);\n#endif /* BETA */\n        data = EXP_OP(data, DATA_TYPE, 4);\n        VSTORE(4)\n        (data, 0, (__global DATA_TYPE *)offset(&dst, i * GRID_SIZE * 4, 0));\n        sum1D = ADD_OP(sum1D, data, DATA_TYPE, 4);\n    }\n#ifdef NON_MULTIPLE_OF_VECTOR_SIZE\n    if(boundary_workitems == 0)\n    {\n        boundary_workitems = GRID_SIZE;\n        i--;\n    }\n    if(lid == (boundary_workitems - 1))\n    {\n        // Handle non multiple of vector size ((GRID_SIZE * i * 4) + 4, 0); move 4 float positions ahead, *4 is due to the stride\n        VEC_DATA_TYPE(DATA_TYPE, 4)\n        data = VLOAD(4)(0, (__global DATA_TYPE *)offset(&src, (GRID_SIZE * i * 4) + 4, 0));\n        data = SUB_OP(data, max_val, DATA_TYPE, 4);\n#ifdef BETA\n        data = MUL_OP(data, beta, DATA_TYPE, 4);\n#endif /* BETA */\n        data = EXP_OP(data, DATA_TYPE, 4);\n        VEC_DATA_TYPE(SELECT_DATA_TYPE, 4)\n        widx = CONVERT(((uint4)(GRID_SIZE * i * 4) + boundary_workitems * 4 + idx4) < width, VEC_DATA_TYPE(SELECT_DATA_TYPE, 4));\n        data = select(0, data, widx);\n        VSTORE(4)\n        (data, 0, (__global DATA_TYPE *)offset(&dst, (GRID_SIZE * i * 4) + 4, 0));\n        sum1D = ADD_OP(sum1D, data, DATA_TYPE, 4);\n    }\n#endif /* NON_MULTIPLE_OF_VECTOR_SIZE */\n#endif /* NON_MULTIPLE_OF_GRID_SIZE */\n    tmp_local[lid] = sum1D;\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n    if(GRID_SIZE >= 256)\n    {\n        if(lid < 128)\n        {\n            tmp_local[lid] = ADD_OP(tmp_local[lid + 128], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 128)\n    {\n        if(lid < 64)\n        {\n            tmp_local[lid] = ADD_OP(tmp_local[lid + 64], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 64)\n    {\n        if(lid < 32)\n        {\n            tmp_local[lid] = ADD_OP(tmp_local[lid + 32], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 32)\n    {\n        if(lid < 16)\n        {\n            tmp_local[lid] = ADD_OP(tmp_local[lid + 16], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 16)\n    {\n        if(lid < 8)\n        {\n            tmp_local[lid] = ADD_OP(tmp_local[lid + 8], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 8)\n    {\n        if(lid < 4)\n        {\n            tmp_local[lid] = ADD_OP(tmp_local[lid + 4], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(GRID_SIZE >= 4)\n    {\n        if(lid < 2)\n        {\n            tmp_local[lid] = ADD_OP(tmp_local[lid + 2], tmp_local[lid], DATA_TYPE, 4);\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n    }\n    if(lid == 0)\n    {\n        sum1D = ADD_OP(tmp_local[lid + 1], tmp_local[lid], DATA_TYPE, 4);\n        // Perform max reduction\n        sum1D.s01                        = ADD_OP(sum1D.s01, sum1D.s23, DATA_TYPE, 2);\n        sum1D.s0                         = ADD_OP(sum1D.s0, sum1D.s1, DATA_TYPE, 1);\n        *((__global DATA_TYPE *)sum.ptr) = sum1D.s0;\n    }\n}\n\n"
    }, 
    "program": "0x55a2b63100", 
    "call": "clCreateProgramWithSource", 
    "context": "0x55a2b19800", 
    "strings": "0x7fe7417680"
  }, 
  {
    "device_list": [], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.631510", 
      "end": "2018-02-09T10:36:49.665826"
    }, 
    "user_data": "0", 
    "errcode": 0, 
    "pfn_notify": "0", 
    "program": "0x55a2b63100", 
    "call": "clBuildProgram", 
    "options": " -DDATA_TYPE=float -DARM_COMPUTE_OPENCL_FP16_ENABLED=1  -cl-arm-non-uniform-work-group-size "
  }, 
  {
    "kernel": "0x55a3607800", 
    "name": "softmax_layer_norm", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.666021", 
      "end": "2018-02-09T10:36:49.681415"
    }, 
    "errcode": 0, 
    "program": "0x55a2b63100", 
    "call": "clCreateKernel", 
    "errcode_ret": "0x7fe74176bc"
  }, 
  {
    "buffer": "0x55a37adc00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.681595", 
      "end": "2018-02-09T10:36:49.681613"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe74179cc", 
    "size": 4032
  }, 
  {
    "buffer": "0x55a37ad800", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.681633", 
      "end": "2018-02-09T10:36:49.681642"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe74179cc", 
    "size": 4
  }, 
  {
    "buffer": "0x55a37ad400", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.681660", 
      "end": "2018-02-09T10:36:49.681667"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe74179cc", 
    "size": 4
  }, 
  {
    "buffer": "0x55a37ad000", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.681693", 
      "end": "2018-02-09T10:36:49.681722"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe7417f5c", 
    "size": 4016
  }, 
  {
    "buffer": "0x55a37acc00", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.681743", 
      "end": "2018-02-09T10:36:49.681751"
    }, 
    "errcode": 0, 
    "flags": 17, 
    "context": "0x55a2b19800", 
    "host_ptr": "0", 
    "call": "clCreateBuffer", 
    "errcode_ret": "0x7fe74180ec", 
    "size": 4032
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57a00", 
    "arg_value_ptr": "0x55a2b3b8f8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.683405", 
      "end": "2018-02-09T10:36:49.683416"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d4b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57a00", 
    "arg_value_ptr": "0x7fe7417ffc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.683435", 
      "end": "2018-02-09T10:36:49.683442"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57a00", 
    "arg_value_ptr": "0x7fe7417ffc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.683459", 
      "end": "2018-02-09T10:36:49.683464"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57a00", 
    "arg_value_ptr": "0x7fe7417ffc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.683480", 
      "end": "2018-02-09T10:36:49.683486"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "bc030000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57a00", 
    "arg_value_ptr": "0x7fe7417ffc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.683501", 
      "end": "2018-02-09T10:36:49.683506"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "bc030000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57a00", 
    "arg_value_ptr": "0x7fe7417ffc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.683522", 
      "end": "2018-02-09T10:36:49.683526"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "2c570300", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57a00", 
    "arg_value_ptr": "0x7fe7417ffc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.683542", 
      "end": "2018-02-09T10:36:49.683548"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "2c570300", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57a00", 
    "arg_value_ptr": "0x7fe7417ff8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.683564", 
      "end": "2018-02-09T10:36:49.683570"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0030000", 
    "arg_index": 7
  }, 
  {
    "kernel": "0x55a2b57a00", 
    "profiling": {
      "start": 315018683983278, 
      "end": 315018683988486, 
      "queued": 315018680289971, 
      "submit": 315018680574867
    }, 
    "name": "fill_image_borders_constant", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      449, 
      1, 
      3
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.683617", 
      "end": "2018-02-09T10:36:49.687711"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x55a2b3f318", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.687748", 
      "end": "2018-02-09T10:36:49.687758"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d8b2a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.687780", 
      "end": "2018-02-09T10:36:49.687788"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.687810", 
      "end": "2018-02-09T10:36:49.687817"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.687834", 
      "end": "2018-02-09T10:36:49.687841"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.687858", 
      "end": "2018-02-09T10:36:49.687865"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.687881", 
      "end": "2018-02-09T10:36:49.687888"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.687907", 
      "end": "2018-02-09T10:36:49.687913"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.687929", 
      "end": "2018-02-09T10:36:49.687937"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7418040", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.687954", 
      "end": "2018-02-09T10:36:49.687962"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "6c000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x55a2b3b8f8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.687978", 
      "end": "2018-02-09T10:36:49.687985"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d4b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688001", 
      "end": "2018-02-09T10:36:49.688007"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688024", 
      "end": "2018-02-09T10:36:49.688032"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688048", 
      "end": "2018-02-09T10:36:49.688056"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "bc030000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688073", 
      "end": "2018-02-09T10:36:49.688082"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "78070000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688097", 
      "end": "2018-02-09T10:36:49.688105"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "2c570300", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688121", 
      "end": "2018-02-09T10:36:49.688126"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "2c570300", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688141", 
      "end": "2018-02-09T10:36:49.688148"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0030000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x55a2b3bbb8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688165", 
      "end": "2018-02-09T10:36:49.688171"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c0b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688186", 
      "end": "2018-02-09T10:36:49.688193"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688211", 
      "end": "2018-02-09T10:36:49.688218"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688236", 
      "end": "2018-02-09T10:36:49.688242"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688257", 
      "end": "2018-02-09T10:36:49.688264"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688281", 
      "end": "2018-02-09T10:36:49.688286"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688302", 
      "end": "2018-02-09T10:36:49.688308"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57c00", 
    "arg_value_ptr": "0x7fe7417f38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688325", 
      "end": "2018-02-09T10:36:49.688330"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b57c00", 
    "profiling": {
      "start": 315018685913158, 
      "end": 315018692272950, 
      "queued": 315018685363929, 
      "submit": 315018685384241
    }, 
    "name": "direct_convolution3x3", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      14, 
      112, 
      32
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.688354", 
      "end": "2018-02-09T10:36:49.697017"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x55a3008788", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697057", 
      "end": "2018-02-09T10:36:49.697064"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d0b2a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697084", 
      "end": "2018-02-09T10:36:49.697118"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697138", 
      "end": "2018-02-09T10:36:49.697145"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697162", 
      "end": "2018-02-09T10:36:49.697167"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x55a2bb9c98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697186", 
      "end": "2018-02-09T10:36:49.697191"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00ccb2a255000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697208", 
      "end": "2018-02-09T10:36:49.697214"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697231", 
      "end": "2018-02-09T10:36:49.697236"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697253", 
      "end": "2018-02-09T10:36:49.697259"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x55a301dff8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697276", 
      "end": "2018-02-09T10:36:49.697281"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c4b2a255000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697298", 
      "end": "2018-02-09T10:36:49.697304"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697321", 
      "end": "2018-02-09T10:36:49.697327"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697344", 
      "end": "2018-02-09T10:36:49.697349"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x55a2bbe668", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697367", 
      "end": "2018-02-09T10:36:49.697372"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c8b2a255000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697388", 
      "end": "2018-02-09T10:36:49.697395"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697412", 
      "end": "2018-02-09T10:36:49.697417"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697435", 
      "end": "2018-02-09T10:36:49.697440"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x55a2b3bbb8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697472", 
      "end": "2018-02-09T10:36:49.697478"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c0b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697496", 
      "end": "2018-02-09T10:36:49.697502"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697520", 
      "end": "2018-02-09T10:36:49.697525"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697542", 
      "end": "2018-02-09T10:36:49.697547"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697564", 
      "end": "2018-02-09T10:36:49.697570"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697587", 
      "end": "2018-02-09T10:36:49.697592"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697610", 
      "end": "2018-02-09T10:36:49.697615"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697633", 
      "end": "2018-02-09T10:36:49.697638"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x55a2c42528", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697656", 
      "end": "2018-02-09T10:36:49.697662"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00bcb2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697680", 
      "end": "2018-02-09T10:36:49.697685"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697702", 
      "end": "2018-02-09T10:36:49.697709"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697725", 
      "end": "2018-02-09T10:36:49.697730"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697747", 
      "end": "2018-02-09T10:36:49.697753"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697770", 
      "end": "2018-02-09T10:36:49.697775"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697792", 
      "end": "2018-02-09T10:36:49.697798"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57800", 
    "arg_value_ptr": "0x7fe7417f98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697816", 
      "end": "2018-02-09T10:36:49.697821"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b57800", 
    "profiling": {
      "start": 315018696258343, 
      "end": 315018696398983, 
      "queued": 315018694513926, 
      "submit": 315018694738405
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      28, 
      112, 
      32
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.697845", 
      "end": "2018-02-09T10:36:49.701201"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x55a2c42528", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701238", 
      "end": "2018-02-09T10:36:49.701245"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00bcb2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x7fe7417fbc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701265", 
      "end": "2018-02-09T10:36:49.701272"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x7fe7417fbc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701291", 
      "end": "2018-02-09T10:36:49.701296"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x7fe7417fbc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701319", 
      "end": "2018-02-09T10:36:49.701326"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x7fe7417fbc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701346", 
      "end": "2018-02-09T10:36:49.701351"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x7fe7417fbc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701373", 
      "end": "2018-02-09T10:36:49.701381"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x7fe7417fbc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701401", 
      "end": "2018-02-09T10:36:49.701409"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x7fe7417fb8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701428", 
      "end": "2018-02-09T10:36:49.701436"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x55a2bc6bb8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701456", 
      "end": "2018-02-09T10:36:49.701461"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "007cb2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x7fe7417fbc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701479", 
      "end": "2018-02-09T10:36:49.701486"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x7fe7417fbc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701504", 
      "end": "2018-02-09T10:36:49.701510"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x7fe7417fbc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701528", 
      "end": "2018-02-09T10:36:49.701533"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c8010000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x7fe7417fbc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701552", 
      "end": "2018-02-09T10:36:49.701557"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c8010000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x7fe7417fbc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701576", 
      "end": "2018-02-09T10:36:49.701583"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10cb0000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x7fe7417fbc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701603", 
      "end": "2018-02-09T10:36:49.701609"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10cb0000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57600", 
    "arg_value_ptr": "0x7fe7417fb8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701630", 
      "end": "2018-02-09T10:36:49.701638"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "cc010000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b57600", 
    "profiling": {
      "start": 315018698402712, 
      "end": 315018698544303, 
      "queued": 315018698326945, 
      "submit": 315018698350383
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      28, 
      112, 
      32
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.701664", 
      "end": "2018-02-09T10:36:49.703121"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57200", 
    "arg_value_ptr": "0x55a2bc6bb8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.703164", 
      "end": "2018-02-09T10:36:49.703172"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "007cb2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57200", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.703195", 
      "end": "2018-02-09T10:36:49.703203"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57200", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.703224", 
      "end": "2018-02-09T10:36:49.703230"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57200", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.703249", 
      "end": "2018-02-09T10:36:49.703256"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c8010000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57200", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.703276", 
      "end": "2018-02-09T10:36:49.703283"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c8010000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57200", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.703301", 
      "end": "2018-02-09T10:36:49.703306"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10cb0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57200", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.703327", 
      "end": "2018-02-09T10:36:49.703335"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10cb0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57200", 
    "arg_value_ptr": "0x7fe7417fa8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.703355", 
      "end": "2018-02-09T10:36:49.703363"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "cc010000", 
    "arg_index": 7
  }, 
  {
    "kernel": "0x55a2b57200", 
    "profiling": {
      "start": 315018700981102, 
      "end": 315018700999872, 
      "queued": 315018700048300, 
      "submit": 315018700070695
    }, 
    "name": "fill_image_borders_constant", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      226, 
      1, 
      32
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.703389", 
      "end": "2018-02-09T10:36:49.704800"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x55a2bc6bb8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.704836", 
      "end": "2018-02-09T10:36:49.704845"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "007cb2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.704866", 
      "end": "2018-02-09T10:36:49.704873"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.704896", 
      "end": "2018-02-09T10:36:49.704904"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.704925", 
      "end": "2018-02-09T10:36:49.704931"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c8010000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.704951", 
      "end": "2018-02-09T10:36:49.704957"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c8010000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.704976", 
      "end": "2018-02-09T10:36:49.704981"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10cb0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.704999", 
      "end": "2018-02-09T10:36:49.705007"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10cb0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705027", 
      "end": "2018-02-09T10:36:49.705034"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x55a2ba3538", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705078", 
      "end": "2018-02-09T10:36:49.705085"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a4b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705110", 
      "end": "2018-02-09T10:36:49.705119"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705139", 
      "end": "2018-02-09T10:36:49.705144"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705165", 
      "end": "2018-02-09T10:36:49.705171"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705191", 
      "end": "2018-02-09T10:36:49.705198"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705217", 
      "end": "2018-02-09T10:36:49.705224"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705243", 
      "end": "2018-02-09T10:36:49.705249"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705269", 
      "end": "2018-02-09T10:36:49.705276"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x55a2c02838", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705297", 
      "end": "2018-02-09T10:36:49.705303"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00b8b2a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705323", 
      "end": "2018-02-09T10:36:49.705329"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705348", 
      "end": "2018-02-09T10:36:49.705354"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705375", 
      "end": "2018-02-09T10:36:49.705382"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705400", 
      "end": "2018-02-09T10:36:49.705406"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705425", 
      "end": "2018-02-09T10:36:49.705431"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705450", 
      "end": "2018-02-09T10:36:49.705457"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57400", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705475", 
      "end": "2018-02-09T10:36:49.705481"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "kernel": "0x55a2b57400", 
    "profiling": {
      "start": 315018702271140, 
      "end": 315018702482718, 
      "queued": 315018702167569, 
      "submit": 315018702221736
    }, 
    "name": "depthwise_convolution_3x3", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      56, 
      112, 
      32
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.705503", 
      "end": "2018-02-09T10:36:49.706287"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x55a300dbf8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706322", 
      "end": "2018-02-09T10:36:49.706331"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00b4b2a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706355", 
      "end": "2018-02-09T10:36:49.706363"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706385", 
      "end": "2018-02-09T10:36:49.706393"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706415", 
      "end": "2018-02-09T10:36:49.706421"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x55a3052d38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706445", 
      "end": "2018-02-09T10:36:49.706452"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00b0b2a255000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706472", 
      "end": "2018-02-09T10:36:49.706480"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706500", 
      "end": "2018-02-09T10:36:49.706507"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706525", 
      "end": "2018-02-09T10:36:49.706532"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x55a300e8b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706553", 
      "end": "2018-02-09T10:36:49.706559"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a8b2a255000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706580", 
      "end": "2018-02-09T10:36:49.706587"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706607", 
      "end": "2018-02-09T10:36:49.706613"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706633", 
      "end": "2018-02-09T10:36:49.706641"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x55a311b428", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706662", 
      "end": "2018-02-09T10:36:49.706668"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00acb2a255000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706689", 
      "end": "2018-02-09T10:36:49.706697"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706719", 
      "end": "2018-02-09T10:36:49.706726"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706745", 
      "end": "2018-02-09T10:36:49.706751"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x55a2ba3538", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706773", 
      "end": "2018-02-09T10:36:49.706778"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a4b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706799", 
      "end": "2018-02-09T10:36:49.706806"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706827", 
      "end": "2018-02-09T10:36:49.706835"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706853", 
      "end": "2018-02-09T10:36:49.706859"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706880", 
      "end": "2018-02-09T10:36:49.706887"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706907", 
      "end": "2018-02-09T10:36:49.706914"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706935", 
      "end": "2018-02-09T10:36:49.706941"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706962", 
      "end": "2018-02-09T10:36:49.706970"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x55a300bc38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.706993", 
      "end": "2018-02-09T10:36:49.706997"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a0b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.707018", 
      "end": "2018-02-09T10:36:49.707025"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.707044", 
      "end": "2018-02-09T10:36:49.707049"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.707070", 
      "end": "2018-02-09T10:36:49.707076"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.707098", 
      "end": "2018-02-09T10:36:49.707105"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.707126", 
      "end": "2018-02-09T10:36:49.707134"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.707153", 
      "end": "2018-02-09T10:36:49.707161"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b57000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.707181", 
      "end": "2018-02-09T10:36:49.707189"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b57000", 
    "profiling": {
      "start": 315018703948767, 
      "end": 315018704089955, 
      "queued": 315018703876944, 
      "submit": 315018703899340
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      28, 
      112, 
      32
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.707211", 
      "end": "2018-02-09T10:36:49.707883"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x55a300bc38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.707919", 
      "end": "2018-02-09T10:36:49.707926"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a0b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.707950", 
      "end": "2018-02-09T10:36:49.707959"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.707981", 
      "end": "2018-02-09T10:36:49.707989"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.708010", 
      "end": "2018-02-09T10:36:49.708016"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.708036", 
      "end": "2018-02-09T10:36:49.708043"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.708063", 
      "end": "2018-02-09T10:36:49.708069"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.708089", 
      "end": "2018-02-09T10:36:49.708095"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.708115", 
      "end": "2018-02-09T10:36:49.708121"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x55a317a708", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.708141", 
      "end": "2018-02-09T10:36:49.708147"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0098b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.708166", 
      "end": "2018-02-09T10:36:49.708173"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.708191", 
      "end": "2018-02-09T10:36:49.708198"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.708218", 
      "end": "2018-02-09T10:36:49.708224"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.708244", 
      "end": "2018-02-09T10:36:49.708250"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.708271", 
      "end": "2018-02-09T10:36:49.708276"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.708295", 
      "end": "2018-02-09T10:36:49.708300"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56e00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.708321", 
      "end": "2018-02-09T10:36:49.708326"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b56e00", 
    "profiling": {
      "start": 315018705086746, 
      "end": 315018705214183, 
      "queued": 315018705015486, 
      "submit": 315018705038403
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      28, 
      112, 
      32
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.708355", 
      "end": "2018-02-09T10:36:49.709424"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x55a31e0f18", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709462", 
      "end": "2018-02-09T10:36:49.709470"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "009cb2a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709490", 
      "end": "2018-02-09T10:36:49.709498"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709518", 
      "end": "2018-02-09T10:36:49.709524"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709546", 
      "end": "2018-02-09T10:36:49.709553"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709575", 
      "end": "2018-02-09T10:36:49.709581"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709602", 
      "end": "2018-02-09T10:36:49.709610"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709632", 
      "end": "2018-02-09T10:36:49.709637"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709655", 
      "end": "2018-02-09T10:36:49.709664"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417ff0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709685", 
      "end": "2018-02-09T10:36:49.709690"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x55a317a708", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709711", 
      "end": "2018-02-09T10:36:49.709717"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0098b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709736", 
      "end": "2018-02-09T10:36:49.709741"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709762", 
      "end": "2018-02-09T10:36:49.709769"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709789", 
      "end": "2018-02-09T10:36:49.709795"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709814", 
      "end": "2018-02-09T10:36:49.709820"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00070000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709839", 
      "end": "2018-02-09T10:36:49.709846"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709866", 
      "end": "2018-02-09T10:36:49.709872"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709890", 
      "end": "2018-02-09T10:36:49.709897"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x55a31be618", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709917", 
      "end": "2018-02-09T10:36:49.709923"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0084b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709945", 
      "end": "2018-02-09T10:36:49.709949"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709967", 
      "end": "2018-02-09T10:36:49.709972"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.709991", 
      "end": "2018-02-09T10:36:49.709998"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.710018", 
      "end": "2018-02-09T10:36:49.710026"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00070000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.710045", 
      "end": "2018-02-09T10:36:49.710051"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.710072", 
      "end": "2018-02-09T10:36:49.710078"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56c00", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.710097", 
      "end": "2018-02-09T10:36:49.710103"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b56c00", 
    "profiling": {
      "start": 315018706859575, 
      "end": 315018707990857, 
      "queued": 315018706788402, 
      "submit": 315018706810277
    }, 
    "name": "direct_convolution1x1_f32_bifrost_2", 
    "lws": [
      1, 
      1, 
      8
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      28, 
      28, 
      64
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.710127", 
      "end": "2018-02-09T10:36:49.712594"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x55a32d30f8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712630", 
      "end": "2018-02-09T10:36:49.712637"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0094b2a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712659", 
      "end": "2018-02-09T10:36:49.712665"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712685", 
      "end": "2018-02-09T10:36:49.712692"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712710", 
      "end": "2018-02-09T10:36:49.712716"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x55a32c4028", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712738", 
      "end": "2018-02-09T10:36:49.712743"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0090b2a255000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712762", 
      "end": "2018-02-09T10:36:49.712768"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712787", 
      "end": "2018-02-09T10:36:49.712793"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712813", 
      "end": "2018-02-09T10:36:49.712820"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x55a32a3638", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712841", 
      "end": "2018-02-09T10:36:49.712848"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0088b2a255000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712867", 
      "end": "2018-02-09T10:36:49.712873"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712891", 
      "end": "2018-02-09T10:36:49.712898"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712917", 
      "end": "2018-02-09T10:36:49.712923"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x55a2fd5608", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712944", 
      "end": "2018-02-09T10:36:49.712948"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "008cb2a255000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712969", 
      "end": "2018-02-09T10:36:49.712974"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.712994", 
      "end": "2018-02-09T10:36:49.712999"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713021", 
      "end": "2018-02-09T10:36:49.713026"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x55a31be618", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713047", 
      "end": "2018-02-09T10:36:49.713073"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0084b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713100", 
      "end": "2018-02-09T10:36:49.713107"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713127", 
      "end": "2018-02-09T10:36:49.713135"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713153", 
      "end": "2018-02-09T10:36:49.713162"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713182", 
      "end": "2018-02-09T10:36:49.713188"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713208", 
      "end": "2018-02-09T10:36:49.713212"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713232", 
      "end": "2018-02-09T10:36:49.713238"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713258", 
      "end": "2018-02-09T10:36:49.713263"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x55a30133e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713285", 
      "end": "2018-02-09T10:36:49.713290"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0080b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713311", 
      "end": "2018-02-09T10:36:49.713319"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713338", 
      "end": "2018-02-09T10:36:49.713345"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713365", 
      "end": "2018-02-09T10:36:49.713371"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713392", 
      "end": "2018-02-09T10:36:49.713398"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713420", 
      "end": "2018-02-09T10:36:49.713427"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713447", 
      "end": "2018-02-09T10:36:49.713453"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713473", 
      "end": "2018-02-09T10:36:49.713480"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b56a00", 
    "profiling": {
      "start": 315018710329992, 
      "end": 315018710621471, 
      "queued": 315018710169130, 
      "submit": 315018710192047
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      28, 
      112, 
      64
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.713504", 
      "end": "2018-02-09T10:36:49.714564"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x55a30133e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.714601", 
      "end": "2018-02-09T10:36:49.714609"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0080b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.714635", 
      "end": "2018-02-09T10:36:49.714644"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.714668", 
      "end": "2018-02-09T10:36:49.714675"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.714698", 
      "end": "2018-02-09T10:36:49.714704"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.714725", 
      "end": "2018-02-09T10:36:49.714732"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.714753", 
      "end": "2018-02-09T10:36:49.714760"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.714782", 
      "end": "2018-02-09T10:36:49.714789"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c40000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.714811", 
      "end": "2018-02-09T10:36:49.714820"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x55a2bcd358", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.714840", 
      "end": "2018-02-09T10:36:49.714847"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003cb2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.714868", 
      "end": "2018-02-09T10:36:49.714874"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.714896", 
      "end": "2018-02-09T10:36:49.714902"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.714923", 
      "end": "2018-02-09T10:36:49.714930"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c4010000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.714951", 
      "end": "2018-02-09T10:36:49.714957"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c4010000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.714978", 
      "end": "2018-02-09T10:36:49.714987"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "84c70000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.715008", 
      "end": "2018-02-09T10:36:49.715014"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "84c70000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56800", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.715036", 
      "end": "2018-02-09T10:36:49.715041"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b56800", 
    "profiling": {
      "start": 315018711799538, 
      "end": 315018712105995, 
      "queued": 315018711727984, 
      "submit": 315018711752984
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      28, 
      112, 
      64
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.715064", 
      "end": "2018-02-09T10:36:49.716059"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56400", 
    "arg_value_ptr": "0x55a2bcd358", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.716097", 
      "end": "2018-02-09T10:36:49.716104"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003cb2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56400", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.716129", 
      "end": "2018-02-09T10:36:49.716138"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56400", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.716161", 
      "end": "2018-02-09T10:36:49.716168"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56400", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.716192", 
      "end": "2018-02-09T10:36:49.716198"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c4010000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56400", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.716218", 
      "end": "2018-02-09T10:36:49.716223"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c4010000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56400", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.716244", 
      "end": "2018-02-09T10:36:49.716249"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "84c70000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56400", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.716272", 
      "end": "2018-02-09T10:36:49.716281"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "84c70000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56400", 
    "arg_value_ptr": "0x7fe7417fa8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.716302", 
      "end": "2018-02-09T10:36:49.716309"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "kernel": "0x55a2b56400", 
    "profiling": {
      "start": 315018713074103, 
      "end": 315018713112615, 
      "queued": 315018712999338, 
      "submit": 315018713025901
    }, 
    "name": "fill_image_borders_constant", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      225, 
      1, 
      64
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.716337", 
      "end": "2018-02-09T10:36:49.716951"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x55a2bcd358", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.716988", 
      "end": "2018-02-09T10:36:49.716996"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003cb2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717021", 
      "end": "2018-02-09T10:36:49.717028"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717069", 
      "end": "2018-02-09T10:36:49.717077"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717104", 
      "end": "2018-02-09T10:36:49.717112"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c4010000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717138", 
      "end": "2018-02-09T10:36:49.717146"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "88030000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717168", 
      "end": "2018-02-09T10:36:49.717173"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "84c70000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717198", 
      "end": "2018-02-09T10:36:49.717204"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "84c70000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717226", 
      "end": "2018-02-09T10:36:49.717234"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x55a328a848", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717258", 
      "end": "2018-02-09T10:36:49.717266"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0064b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717286", 
      "end": "2018-02-09T10:36:49.717293"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717314", 
      "end": "2018-02-09T10:36:49.717320"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717343", 
      "end": "2018-02-09T10:36:49.717348"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717374", 
      "end": "2018-02-09T10:36:49.717381"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717403", 
      "end": "2018-02-09T10:36:49.717409"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717435", 
      "end": "2018-02-09T10:36:49.717440"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717462", 
      "end": "2018-02-09T10:36:49.717470"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x55a300f408", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717493", 
      "end": "2018-02-09T10:36:49.717501"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0078b2a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717524", 
      "end": "2018-02-09T10:36:49.717531"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717554", 
      "end": "2018-02-09T10:36:49.717561"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717582", 
      "end": "2018-02-09T10:36:49.717587"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717611", 
      "end": "2018-02-09T10:36:49.717619"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717640", 
      "end": "2018-02-09T10:36:49.717645"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717667", 
      "end": "2018-02-09T10:36:49.717674"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56600", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717695", 
      "end": "2018-02-09T10:36:49.717699"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "kernel": "0x55a2b56600", 
    "profiling": {
      "start": 315018714552273, 
      "end": 315018714824704, 
      "queued": 315018714404025, 
      "submit": 315018714458712
    }, 
    "name": "depthwise_convolution_3x3", 
    "lws": [
      8, 
      5, 
      2
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      28, 
      56, 
      64
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.717724", 
      "end": "2018-02-09T10:36:49.718736"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x55a32c54f8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.718769", 
      "end": "2018-02-09T10:36:49.718776"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0074b2a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.718801", 
      "end": "2018-02-09T10:36:49.718808"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.718831", 
      "end": "2018-02-09T10:36:49.718837"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.718858", 
      "end": "2018-02-09T10:36:49.718864"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x55a30c7ad8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.718887", 
      "end": "2018-02-09T10:36:49.718892"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0070b2a255000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.718913", 
      "end": "2018-02-09T10:36:49.718919"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.718938", 
      "end": "2018-02-09T10:36:49.718944"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.718965", 
      "end": "2018-02-09T10:36:49.718971"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x55a300b908", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.718993", 
      "end": "2018-02-09T10:36:49.718998"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0068b2a255000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719021", 
      "end": "2018-02-09T10:36:49.719026"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719065", 
      "end": "2018-02-09T10:36:49.719071"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719093", 
      "end": "2018-02-09T10:36:49.719098"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x55a32af4b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719122", 
      "end": "2018-02-09T10:36:49.719127"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "006cb2a255000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719150", 
      "end": "2018-02-09T10:36:49.719157"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719179", 
      "end": "2018-02-09T10:36:49.719184"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719204", 
      "end": "2018-02-09T10:36:49.719210"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x55a328a848", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719233", 
      "end": "2018-02-09T10:36:49.719238"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0064b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719259", 
      "end": "2018-02-09T10:36:49.719264"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719286", 
      "end": "2018-02-09T10:36:49.719292"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719315", 
      "end": "2018-02-09T10:36:49.719321"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719343", 
      "end": "2018-02-09T10:36:49.719348"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719369", 
      "end": "2018-02-09T10:36:49.719374"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719399", 
      "end": "2018-02-09T10:36:49.719405"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719427", 
      "end": "2018-02-09T10:36:49.719432"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x55a32cb1a8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719455", 
      "end": "2018-02-09T10:36:49.719460"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0060b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719482", 
      "end": "2018-02-09T10:36:49.719487"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719509", 
      "end": "2018-02-09T10:36:49.719514"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719537", 
      "end": "2018-02-09T10:36:49.719542"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719564", 
      "end": "2018-02-09T10:36:49.719570"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719593", 
      "end": "2018-02-09T10:36:49.719598"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719619", 
      "end": "2018-02-09T10:36:49.719624"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719645", 
      "end": "2018-02-09T10:36:49.719650"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b56200", 
    "profiling": {
      "start": 315018717559134, 
      "end": 315018717624703, 
      "queued": 315018716339441, 
      "submit": 315018716859233
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      14, 
      56, 
      64
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.719676", 
      "end": "2018-02-09T10:36:49.721516"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x55a32cb1a8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721549", 
      "end": "2018-02-09T10:36:49.721556"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0060b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721580", 
      "end": "2018-02-09T10:36:49.721586"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721609", 
      "end": "2018-02-09T10:36:49.721615"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721637", 
      "end": "2018-02-09T10:36:49.721642"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721665", 
      "end": "2018-02-09T10:36:49.721671"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721691", 
      "end": "2018-02-09T10:36:49.721696"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721718", 
      "end": "2018-02-09T10:36:49.721723"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721743", 
      "end": "2018-02-09T10:36:49.721749"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x55a3053388", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721773", 
      "end": "2018-02-09T10:36:49.721778"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0058b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721799", 
      "end": "2018-02-09T10:36:49.721804"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721842", 
      "end": "2018-02-09T10:36:49.721849"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721872", 
      "end": "2018-02-09T10:36:49.721877"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721899", 
      "end": "2018-02-09T10:36:49.721905"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721926", 
      "end": "2018-02-09T10:36:49.721932"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721952", 
      "end": "2018-02-09T10:36:49.721958"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b56000", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.721980", 
      "end": "2018-02-09T10:36:49.721985"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b56000", 
    "profiling": {
      "start": 315018719118611, 
      "end": 315018719178513, 
      "queued": 315018718665482, 
      "submit": 315018718897253
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      14, 
      56, 
      64
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.722010", 
      "end": "2018-02-09T10:36:49.722954"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x55a3289878", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.722994", 
      "end": "2018-02-09T10:36:49.723002"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "005cb2a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723027", 
      "end": "2018-02-09T10:36:49.723034"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723059", 
      "end": "2018-02-09T10:36:49.723064"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723088", 
      "end": "2018-02-09T10:36:49.723093"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723116", 
      "end": "2018-02-09T10:36:49.723122"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723147", 
      "end": "2018-02-09T10:36:49.723152"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723177", 
      "end": "2018-02-09T10:36:49.723183"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723206", 
      "end": "2018-02-09T10:36:49.723211"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417ff0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723234", 
      "end": "2018-02-09T10:36:49.723239"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x55a3053388", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723264", 
      "end": "2018-02-09T10:36:49.723270"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0058b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723293", 
      "end": "2018-02-09T10:36:49.723300"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723324", 
      "end": "2018-02-09T10:36:49.723332"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723355", 
      "end": "2018-02-09T10:36:49.723362"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723386", 
      "end": "2018-02-09T10:36:49.723392"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723414", 
      "end": "2018-02-09T10:36:49.723421"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723444", 
      "end": "2018-02-09T10:36:49.723448"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723471", 
      "end": "2018-02-09T10:36:49.723476"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x55a32cd6f8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723502", 
      "end": "2018-02-09T10:36:49.723508"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0044b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723530", 
      "end": "2018-02-09T10:36:49.723537"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723561", 
      "end": "2018-02-09T10:36:49.723568"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723592", 
      "end": "2018-02-09T10:36:49.723599"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723623", 
      "end": "2018-02-09T10:36:49.723629"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723650", 
      "end": "2018-02-09T10:36:49.723655"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723677", 
      "end": "2018-02-09T10:36:49.723685"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55e00", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723709", 
      "end": "2018-02-09T10:36:49.723715"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b55e00", 
    "profiling": {
      "start": 315018720629685, 
      "end": 315018721448144, 
      "queued": 315018720409232, 
      "submit": 315018720447774
    }, 
    "name": "direct_convolution1x1_f32_bifrost_2", 
    "lws": [
      1, 
      1, 
      8
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      14, 
      14, 
      128
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.723746", 
      "end": "2018-02-09T10:36:49.725197"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x55a3138318", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725237", 
      "end": "2018-02-09T10:36:49.725245"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0054b2a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725271", 
      "end": "2018-02-09T10:36:49.725280"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725305", 
      "end": "2018-02-09T10:36:49.725313"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725337", 
      "end": "2018-02-09T10:36:49.725343"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x55a336e298", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725367", 
      "end": "2018-02-09T10:36:49.725372"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0050b2a255000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725398", 
      "end": "2018-02-09T10:36:49.725405"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725429", 
      "end": "2018-02-09T10:36:49.725435"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725459", 
      "end": "2018-02-09T10:36:49.725467"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x55a3001828", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725491", 
      "end": "2018-02-09T10:36:49.725496"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0048b2a255000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725520", 
      "end": "2018-02-09T10:36:49.725525"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725551", 
      "end": "2018-02-09T10:36:49.725556"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725581", 
      "end": "2018-02-09T10:36:49.725586"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x55a338d8d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725610", 
      "end": "2018-02-09T10:36:49.725616"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004cb2a255000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725639", 
      "end": "2018-02-09T10:36:49.725645"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725669", 
      "end": "2018-02-09T10:36:49.725675"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725697", 
      "end": "2018-02-09T10:36:49.725702"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x55a32cd6f8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725728", 
      "end": "2018-02-09T10:36:49.725735"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0044b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725757", 
      "end": "2018-02-09T10:36:49.725764"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725790", 
      "end": "2018-02-09T10:36:49.725798"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725823", 
      "end": "2018-02-09T10:36:49.725830"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725854", 
      "end": "2018-02-09T10:36:49.725861"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725883", 
      "end": "2018-02-09T10:36:49.725889"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725914", 
      "end": "2018-02-09T10:36:49.725919"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725943", 
      "end": "2018-02-09T10:36:49.725948"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x55a32a3d18", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.725974", 
      "end": "2018-02-09T10:36:49.725980"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0040b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.726005", 
      "end": "2018-02-09T10:36:49.726010"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.726036", 
      "end": "2018-02-09T10:36:49.726044"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.726067", 
      "end": "2018-02-09T10:36:49.726072"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.726096", 
      "end": "2018-02-09T10:36:49.726104"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.726129", 
      "end": "2018-02-09T10:36:49.726134"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.726158", 
      "end": "2018-02-09T10:36:49.726164"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55c00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.726188", 
      "end": "2018-02-09T10:36:49.726194"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b55c00", 
    "profiling": {
      "start": 315018723116547, 
      "end": 315018723259088, 
      "queued": 315018722892564, 
      "submit": 315018722932148
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      14, 
      56, 
      128
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.726221", 
      "end": "2018-02-09T10:36:49.727004"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x55a32a3d18", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727042", 
      "end": "2018-02-09T10:36:49.727050"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0040b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727076", 
      "end": "2018-02-09T10:36:49.727084"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727110", 
      "end": "2018-02-09T10:36:49.727115"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727139", 
      "end": "2018-02-09T10:36:49.727145"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727169", 
      "end": "2018-02-09T10:36:49.727175"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727198", 
      "end": "2018-02-09T10:36:49.727205"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727229", 
      "end": "2018-02-09T10:36:49.727234"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727258", 
      "end": "2018-02-09T10:36:49.727266"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x55a32c4cc8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727291", 
      "end": "2018-02-09T10:36:49.727298"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00fcb1a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727324", 
      "end": "2018-02-09T10:36:49.727330"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727354", 
      "end": "2018-02-09T10:36:49.727361"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727387", 
      "end": "2018-02-09T10:36:49.727393"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e8000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727418", 
      "end": "2018-02-09T10:36:49.727423"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e8000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727446", 
      "end": "2018-02-09T10:36:49.727454"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "90340000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727478", 
      "end": "2018-02-09T10:36:49.727484"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "90340000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55a00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727508", 
      "end": "2018-02-09T10:36:49.727516"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "ec000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b55a00", 
    "profiling": {
      "start": 315018724497152, 
      "end": 315018724657689, 
      "queued": 315018724206627, 
      "submit": 315018724303502
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      14, 
      56, 
      128
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.727547", 
      "end": "2018-02-09T10:36:49.728410"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55600", 
    "arg_value_ptr": "0x55a32c4cc8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.728453", 
      "end": "2018-02-09T10:36:49.728461"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00fcb1a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55600", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.728489", 
      "end": "2018-02-09T10:36:49.728499"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55600", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.728525", 
      "end": "2018-02-09T10:36:49.728530"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55600", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.728555", 
      "end": "2018-02-09T10:36:49.728560"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e8000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55600", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.728586", 
      "end": "2018-02-09T10:36:49.728594"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e8000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55600", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.728617", 
      "end": "2018-02-09T10:36:49.728623"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "90340000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55600", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.728647", 
      "end": "2018-02-09T10:36:49.728654"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "90340000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55600", 
    "arg_value_ptr": "0x7fe7417fa8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.728678", 
      "end": "2018-02-09T10:36:49.728683"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "ec000000", 
    "arg_index": 7
  }, 
  {
    "kernel": "0x55a2b55600", 
    "profiling": {
      "start": 315018725476139, 
      "end": 315018725508797, 
      "queued": 315018725375898, 
      "submit": 315018725412356
    }, 
    "name": "fill_image_borders_constant", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      114, 
      1, 
      128
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.728710", 
      "end": "2018-02-09T10:36:49.729249"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x55a32c4cc8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729290", 
      "end": "2018-02-09T10:36:49.729299"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00fcb1a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729328", 
      "end": "2018-02-09T10:36:49.729335"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729363", 
      "end": "2018-02-09T10:36:49.729371"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729396", 
      "end": "2018-02-09T10:36:49.729401"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e8000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729428", 
      "end": "2018-02-09T10:36:49.729435"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e8000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729459", 
      "end": "2018-02-09T10:36:49.729467"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "90340000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729490", 
      "end": "2018-02-09T10:36:49.729495"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "90340000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729518", 
      "end": "2018-02-09T10:36:49.729523"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x55a315b1d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729548", 
      "end": "2018-02-09T10:36:49.729554"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0024b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729577", 
      "end": "2018-02-09T10:36:49.729582"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729606", 
      "end": "2018-02-09T10:36:49.729611"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729634", 
      "end": "2018-02-09T10:36:49.729638"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729662", 
      "end": "2018-02-09T10:36:49.729670"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729694", 
      "end": "2018-02-09T10:36:49.729699"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729724", 
      "end": "2018-02-09T10:36:49.729729"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729752", 
      "end": "2018-02-09T10:36:49.729760"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x55a30515e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729785", 
      "end": "2018-02-09T10:36:49.729791"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0038b2a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729816", 
      "end": "2018-02-09T10:36:49.729821"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729846", 
      "end": "2018-02-09T10:36:49.729851"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729876", 
      "end": "2018-02-09T10:36:49.729882"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729907", 
      "end": "2018-02-09T10:36:49.729912"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729935", 
      "end": "2018-02-09T10:36:49.729940"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729967", 
      "end": "2018-02-09T10:36:49.729972"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55800", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.729996", 
      "end": "2018-02-09T10:36:49.730001"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "kernel": "0x55a2b55800", 
    "profiling": {
      "start": 315018726931578, 
      "end": 315018727146532, 
      "queued": 315018726699855, 
      "submit": 315018726735272
    }, 
    "name": "depthwise_convolution_3x3", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      28, 
      56, 
      128
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.730033", 
      "end": "2018-02-09T10:36:49.730889"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x55a33a6e58", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.730931", 
      "end": "2018-02-09T10:36:49.730939"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0034b2a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.730968", 
      "end": "2018-02-09T10:36:49.730975"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731004", 
      "end": "2018-02-09T10:36:49.731009"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731034", 
      "end": "2018-02-09T10:36:49.731040"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x55a336c9a8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731068", 
      "end": "2018-02-09T10:36:49.731075"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0030b2a255000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731100", 
      "end": "2018-02-09T10:36:49.731106"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731132", 
      "end": "2018-02-09T10:36:49.731137"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731164", 
      "end": "2018-02-09T10:36:49.731169"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x55a3033b48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731195", 
      "end": "2018-02-09T10:36:49.731201"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0028b2a255000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731225", 
      "end": "2018-02-09T10:36:49.731231"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731256", 
      "end": "2018-02-09T10:36:49.731263"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731288", 
      "end": "2018-02-09T10:36:49.731294"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x55a33b5288", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731321", 
      "end": "2018-02-09T10:36:49.731326"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002cb2a255000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731350", 
      "end": "2018-02-09T10:36:49.731357"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731382", 
      "end": "2018-02-09T10:36:49.731389"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731414", 
      "end": "2018-02-09T10:36:49.731420"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x55a315b1d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731446", 
      "end": "2018-02-09T10:36:49.731451"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0024b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731477", 
      "end": "2018-02-09T10:36:49.731482"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731508", 
      "end": "2018-02-09T10:36:49.731514"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731538", 
      "end": "2018-02-09T10:36:49.731545"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731569", 
      "end": "2018-02-09T10:36:49.731574"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731602", 
      "end": "2018-02-09T10:36:49.731608"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731634", 
      "end": "2018-02-09T10:36:49.731639"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731663", 
      "end": "2018-02-09T10:36:49.731669"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x55a3387678", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731696", 
      "end": "2018-02-09T10:36:49.731703"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0020b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731727", 
      "end": "2018-02-09T10:36:49.731733"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731759", 
      "end": "2018-02-09T10:36:49.731764"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731791", 
      "end": "2018-02-09T10:36:49.731795"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731821", 
      "end": "2018-02-09T10:36:49.731829"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731854", 
      "end": "2018-02-09T10:36:49.731861"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731884", 
      "end": "2018-02-09T10:36:49.731889"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731915", 
      "end": "2018-02-09T10:36:49.731922"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b55400", 
    "profiling": {
      "start": 315018728887818, 
      "end": 315018729030415, 
      "queued": 315018728626418, 
      "submit": 315018728761834
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      14, 
      56, 
      128
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.731954", 
      "end": "2018-02-09T10:36:49.732578"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x55a3387678", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.732617", 
      "end": "2018-02-09T10:36:49.732624"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0020b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.732654", 
      "end": "2018-02-09T10:36:49.732661"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.732688", 
      "end": "2018-02-09T10:36:49.732696"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.732722", 
      "end": "2018-02-09T10:36:49.732729"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.732757", 
      "end": "2018-02-09T10:36:49.732763"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.732790", 
      "end": "2018-02-09T10:36:49.732797"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.732840", 
      "end": "2018-02-09T10:36:49.732845"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.732875", 
      "end": "2018-02-09T10:36:49.732880"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x55a3033f78", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.732908", 
      "end": "2018-02-09T10:36:49.732915"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0018b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.732943", 
      "end": "2018-02-09T10:36:49.732949"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.732975", 
      "end": "2018-02-09T10:36:49.732980"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.733006", 
      "end": "2018-02-09T10:36:49.733013"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.733039", 
      "end": "2018-02-09T10:36:49.733047"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.733095", 
      "end": "2018-02-09T10:36:49.733102"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.733130", 
      "end": "2018-02-09T10:36:49.733136"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55200", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.733166", 
      "end": "2018-02-09T10:36:49.733173"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b55200", 
    "profiling": {
      "start": 315018730087050, 
      "end": 315018730219593, 
      "queued": 315018729872250, 
      "submit": 315018729907667
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      14, 
      56, 
      128
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.733205", 
      "end": "2018-02-09T10:36:49.733965"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x55a30309f8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734006", 
      "end": "2018-02-09T10:36:49.734014"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "001cb2a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734044", 
      "end": "2018-02-09T10:36:49.734053"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734079", 
      "end": "2018-02-09T10:36:49.734085"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734111", 
      "end": "2018-02-09T10:36:49.734119"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734146", 
      "end": "2018-02-09T10:36:49.734154"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734178", 
      "end": "2018-02-09T10:36:49.734184"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734210", 
      "end": "2018-02-09T10:36:49.734215"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734240", 
      "end": "2018-02-09T10:36:49.734246"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417ff0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734272", 
      "end": "2018-02-09T10:36:49.734278"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00020000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x55a3033f78", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734304", 
      "end": "2018-02-09T10:36:49.734311"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0018b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734338", 
      "end": "2018-02-09T10:36:49.734344"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734369", 
      "end": "2018-02-09T10:36:49.734375"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734402", 
      "end": "2018-02-09T10:36:49.734408"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734434", 
      "end": "2018-02-09T10:36:49.734442"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734467", 
      "end": "2018-02-09T10:36:49.734474"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734501", 
      "end": "2018-02-09T10:36:49.734507"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734532", 
      "end": "2018-02-09T10:36:49.734537"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x55a32f3758", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734565", 
      "end": "2018-02-09T10:36:49.734570"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0004b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734594", 
      "end": "2018-02-09T10:36:49.734601"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734628", 
      "end": "2018-02-09T10:36:49.734633"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734660", 
      "end": "2018-02-09T10:36:49.734668"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734693", 
      "end": "2018-02-09T10:36:49.734699"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734726", 
      "end": "2018-02-09T10:36:49.734731"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734757", 
      "end": "2018-02-09T10:36:49.734765"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b55000", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734790", 
      "end": "2018-02-09T10:36:49.734796"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b55000", 
    "profiling": {
      "start": 315018731727641, 
      "end": 315018733476526, 
      "queued": 315018731495167, 
      "submit": 315018731531104
    }, 
    "name": "direct_convolution1x1_f32_bifrost_2", 
    "lws": [
      1, 
      1, 
      8
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      14, 
      14, 
      128
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.734827", 
      "end": "2018-02-09T10:36:49.737208"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x55a3473358", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737250", 
      "end": "2018-02-09T10:36:49.737258"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0014b2a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737288", 
      "end": "2018-02-09T10:36:49.737297"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737324", 
      "end": "2018-02-09T10:36:49.737330"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737358", 
      "end": "2018-02-09T10:36:49.737365"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x55a3384bd8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737393", 
      "end": "2018-02-09T10:36:49.737400"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0010b2a255000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737426", 
      "end": "2018-02-09T10:36:49.737435"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737461", 
      "end": "2018-02-09T10:36:49.737469"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737496", 
      "end": "2018-02-09T10:36:49.737502"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x55a3478518", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737530", 
      "end": "2018-02-09T10:36:49.737537"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0008b2a255000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737563", 
      "end": "2018-02-09T10:36:49.737571"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737599", 
      "end": "2018-02-09T10:36:49.737604"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737631", 
      "end": "2018-02-09T10:36:49.737638"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x55a346a128", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737666", 
      "end": "2018-02-09T10:36:49.737673"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000cb2a255000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737698", 
      "end": "2018-02-09T10:36:49.737704"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737729", 
      "end": "2018-02-09T10:36:49.737737"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737764", 
      "end": "2018-02-09T10:36:49.737769"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x55a32f3758", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737800", 
      "end": "2018-02-09T10:36:49.737808"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0004b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737833", 
      "end": "2018-02-09T10:36:49.737838"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737863", 
      "end": "2018-02-09T10:36:49.737869"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737896", 
      "end": "2018-02-09T10:36:49.737903"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737930", 
      "end": "2018-02-09T10:36:49.737936"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737962", 
      "end": "2018-02-09T10:36:49.737967"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.737994", 
      "end": "2018-02-09T10:36:49.737999"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.738027", 
      "end": "2018-02-09T10:36:49.738032"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x55a3246428", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.738060", 
      "end": "2018-02-09T10:36:49.738068"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000b2a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.738094", 
      "end": "2018-02-09T10:36:49.738099"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.738126", 
      "end": "2018-02-09T10:36:49.738131"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.738158", 
      "end": "2018-02-09T10:36:49.738162"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.738188", 
      "end": "2018-02-09T10:36:49.738196"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.738223", 
      "end": "2018-02-09T10:36:49.738228"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.738255", 
      "end": "2018-02-09T10:36:49.738263"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54e00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.738289", 
      "end": "2018-02-09T10:36:49.738295"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b54e00", 
    "profiling": {
      "start": 315018735234803, 
      "end": 315018735373108, 
      "queued": 315018734999853, 
      "submit": 315018735037874
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      14, 
      56, 
      128
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.738329", 
      "end": "2018-02-09T10:36:49.739111"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x55a3246428", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739155", 
      "end": "2018-02-09T10:36:49.739163"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0000b2a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739194", 
      "end": "2018-02-09T10:36:49.739202"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739230", 
      "end": "2018-02-09T10:36:49.739237"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739266", 
      "end": "2018-02-09T10:36:49.739270"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739298", 
      "end": "2018-02-09T10:36:49.739304"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739330", 
      "end": "2018-02-09T10:36:49.739334"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739361", 
      "end": "2018-02-09T10:36:49.739367"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00310000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739392", 
      "end": "2018-02-09T10:36:49.739397"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x55a3392608", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739425", 
      "end": "2018-02-09T10:36:49.739430"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "006431a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739458", 
      "end": "2018-02-09T10:36:49.739465"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739494", 
      "end": "2018-02-09T10:36:49.739499"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739525", 
      "end": "2018-02-09T10:36:49.739533"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e4000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739559", 
      "end": "2018-02-09T10:36:49.739566"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e4000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739594", 
      "end": "2018-02-09T10:36:49.739602"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c4320000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739630", 
      "end": "2018-02-09T10:36:49.739637"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c4320000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54c00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739663", 
      "end": "2018-02-09T10:36:49.739669"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b54c00", 
    "profiling": {
      "start": 315018736605207, 
      "end": 315018736760140, 
      "queued": 315018736367561, 
      "submit": 315018736412353
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      14, 
      56, 
      128
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.739702", 
      "end": "2018-02-09T10:36:49.740497"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54800", 
    "arg_value_ptr": "0x55a3392608", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.740541", 
      "end": "2018-02-09T10:36:49.740548"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "006431a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54800", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.740578", 
      "end": "2018-02-09T10:36:49.740587"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54800", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.740616", 
      "end": "2018-02-09T10:36:49.740621"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54800", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.740650", 
      "end": "2018-02-09T10:36:49.740658"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e4000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54800", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.740686", 
      "end": "2018-02-09T10:36:49.740694"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e4000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54800", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.740723", 
      "end": "2018-02-09T10:36:49.740730"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c4320000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54800", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.740756", 
      "end": "2018-02-09T10:36:49.740765"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c4320000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54800", 
    "arg_value_ptr": "0x7fe7417fa8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.740794", 
      "end": "2018-02-09T10:36:49.740801"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "kernel": "0x55a2b54800", 
    "profiling": {
      "start": 315018737596466, 
      "end": 315018737632597, 
      "queued": 315018737499853, 
      "submit": 315018737533707
    }, 
    "name": "fill_image_borders_constant", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      113, 
      1, 
      128
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.740833", 
      "end": "2018-02-09T10:36:49.741383"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x55a3392608", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741425", 
      "end": "2018-02-09T10:36:49.741432"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "006431a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741461", 
      "end": "2018-02-09T10:36:49.741468"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741496", 
      "end": "2018-02-09T10:36:49.741502"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741529", 
      "end": "2018-02-09T10:36:49.741535"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e4000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741561", 
      "end": "2018-02-09T10:36:49.741567"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c8010000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741594", 
      "end": "2018-02-09T10:36:49.741599"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c4320000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741625", 
      "end": "2018-02-09T10:36:49.741631"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c4320000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741657", 
      "end": "2018-02-09T10:36:49.741663"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x55a33acf28", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741691", 
      "end": "2018-02-09T10:36:49.741697"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e4b1a255000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741723", 
      "end": "2018-02-09T10:36:49.741729"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741755", 
      "end": "2018-02-09T10:36:49.741760"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741787", 
      "end": "2018-02-09T10:36:49.741792"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741819", 
      "end": "2018-02-09T10:36:49.741824"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741850", 
      "end": "2018-02-09T10:36:49.741856"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741884", 
      "end": "2018-02-09T10:36:49.741889"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741915", 
      "end": "2018-02-09T10:36:49.741921"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x55a331d198", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741948", 
      "end": "2018-02-09T10:36:49.741954"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f8b1a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.741980", 
      "end": "2018-02-09T10:36:49.741985"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.742012", 
      "end": "2018-02-09T10:36:49.742018"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.742043", 
      "end": "2018-02-09T10:36:49.742048"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.742074", 
      "end": "2018-02-09T10:36:49.742080"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.742105", 
      "end": "2018-02-09T10:36:49.742110"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.742136", 
      "end": "2018-02-09T10:36:49.742141"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54a00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.742166", 
      "end": "2018-02-09T10:36:49.742172"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "kernel": "0x55a2b54a00", 
    "profiling": {
      "start": 315018739169905, 
      "end": 315018739342894, 
      "queued": 315018738884227, 
      "submit": 315018739018081
    }, 
    "name": "depthwise_convolution_3x3", 
    "lws": [
      8, 
      5, 
      2
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      14, 
      28, 
      128
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.742203", 
      "end": "2018-02-09T10:36:49.742870"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x55a33b4998", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.742908", 
      "end": "2018-02-09T10:36:49.742916"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f4b1a255000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.742945", 
      "end": "2018-02-09T10:36:49.742952"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.742979", 
      "end": "2018-02-09T10:36:49.742985"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743012", 
      "end": "2018-02-09T10:36:49.743019"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x55a33a9c18", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743047", 
      "end": "2018-02-09T10:36:49.743053"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f0b1a255000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743093", 
      "end": "2018-02-09T10:36:49.743099"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743128", 
      "end": "2018-02-09T10:36:49.743133"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743161", 
      "end": "2018-02-09T10:36:49.743167"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x55a31bdb08", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743195", 
      "end": "2018-02-09T10:36:49.743200"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e8b1a255000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743228", 
      "end": "2018-02-09T10:36:49.743234"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743261", 
      "end": "2018-02-09T10:36:49.743267"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743294", 
      "end": "2018-02-09T10:36:49.743299"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x55a3469478", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743332", 
      "end": "2018-02-09T10:36:49.743337"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00ecb1a255000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743365", 
      "end": "2018-02-09T10:36:49.743371"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743398", 
      "end": "2018-02-09T10:36:49.743403"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743430", 
      "end": "2018-02-09T10:36:49.743435"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x55a33acf28", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743463", 
      "end": "2018-02-09T10:36:49.743468"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e4b1a255000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743498", 
      "end": "2018-02-09T10:36:49.743503"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743531", 
      "end": "2018-02-09T10:36:49.743536"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743562", 
      "end": "2018-02-09T10:36:49.743567"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743593", 
      "end": "2018-02-09T10:36:49.743599"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743625", 
      "end": "2018-02-09T10:36:49.743631"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743659", 
      "end": "2018-02-09T10:36:49.743664"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743690", 
      "end": "2018-02-09T10:36:49.743696"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x55a33ac5b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743724", 
      "end": "2018-02-09T10:36:49.743730"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "008831a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743757", 
      "end": "2018-02-09T10:36:49.743764"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743792", 
      "end": "2018-02-09T10:36:49.743797"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743825", 
      "end": "2018-02-09T10:36:49.743830"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743857", 
      "end": "2018-02-09T10:36:49.743863"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743890", 
      "end": "2018-02-09T10:36:49.743895"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743923", 
      "end": "2018-02-09T10:36:49.743928"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743956", 
      "end": "2018-02-09T10:36:49.743961"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b54600", 
    "profiling": {
      "start": 315018740907089, 
      "end": 315018740950970, 
      "queued": 315018740660790, 
      "submit": 315018740785269
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      28, 
      128
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.743994", 
      "end": "2018-02-09T10:36:49.744476"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x55a33ac5b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.744515", 
      "end": "2018-02-09T10:36:49.744521"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "008831a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.744550", 
      "end": "2018-02-09T10:36:49.744557"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.744601", 
      "end": "2018-02-09T10:36:49.744608"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.744638", 
      "end": "2018-02-09T10:36:49.744643"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.744672", 
      "end": "2018-02-09T10:36:49.744677"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.744704", 
      "end": "2018-02-09T10:36:49.744709"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.744736", 
      "end": "2018-02-09T10:36:49.744742"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.744769", 
      "end": "2018-02-09T10:36:49.744774"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x55a33a6c98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.744803", 
      "end": "2018-02-09T10:36:49.744808"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "008031a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.744835", 
      "end": "2018-02-09T10:36:49.744841"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.744881", 
      "end": "2018-02-09T10:36:49.744887"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.744918", 
      "end": "2018-02-09T10:36:49.744924"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.744951", 
      "end": "2018-02-09T10:36:49.744957"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.744985", 
      "end": "2018-02-09T10:36:49.744990"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.745017", 
      "end": "2018-02-09T10:36:49.745022"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54400", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.745048", 
      "end": "2018-02-09T10:36:49.745072"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b54400", 
    "profiling": {
      "start": 315018741980006, 
      "end": 315018742015348, 
      "queued": 315018741765997, 
      "submit": 315018741799851
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      28, 
      128
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.745107", 
      "end": "2018-02-09T10:36:49.745737"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x55a3470b88", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.745780", 
      "end": "2018-02-09T10:36:49.745787"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "008431a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.745817", 
      "end": "2018-02-09T10:36:49.745823"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.745852", 
      "end": "2018-02-09T10:36:49.745857"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.745886", 
      "end": "2018-02-09T10:36:49.745892"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.745919", 
      "end": "2018-02-09T10:36:49.745924"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.745953", 
      "end": "2018-02-09T10:36:49.745959"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.745986", 
      "end": "2018-02-09T10:36:49.745992"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746020", 
      "end": "2018-02-09T10:36:49.746025"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417ff0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746053", 
      "end": "2018-02-09T10:36:49.746059"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00020000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x55a33a6c98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746087", 
      "end": "2018-02-09T10:36:49.746093"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "008031a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746120", 
      "end": "2018-02-09T10:36:49.746126"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746154", 
      "end": "2018-02-09T10:36:49.746159"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746186", 
      "end": "2018-02-09T10:36:49.746192"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746220", 
      "end": "2018-02-09T10:36:49.746225"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746252", 
      "end": "2018-02-09T10:36:49.746257"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746285", 
      "end": "2018-02-09T10:36:49.746290"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746318", 
      "end": "2018-02-09T10:36:49.746323"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x55a3469f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746352", 
      "end": "2018-02-09T10:36:49.746357"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "006c31a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746384", 
      "end": "2018-02-09T10:36:49.746390"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746418", 
      "end": "2018-02-09T10:36:49.746423"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746451", 
      "end": "2018-02-09T10:36:49.746457"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746485", 
      "end": "2018-02-09T10:36:49.746491"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746519", 
      "end": "2018-02-09T10:36:49.746524"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746552", 
      "end": "2018-02-09T10:36:49.746558"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54200", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746585", 
      "end": "2018-02-09T10:36:49.746590"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b54200", 
    "profiling": {
      "start": 315018743516118, 
      "end": 315018744335046, 
      "queued": 315018743283705, 
      "submit": 315018743318601
    }, 
    "name": "direct_convolution1x1_f32_bifrost_2", 
    "lws": [
      1, 
      1, 
      8
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      7, 
      256
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.746622", 
      "end": "2018-02-09T10:36:49.748061"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x55a34766f8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748104", 
      "end": "2018-02-09T10:36:49.748111"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "007c31a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748142", 
      "end": "2018-02-09T10:36:49.748150"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748180", 
      "end": "2018-02-09T10:36:49.748186"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748216", 
      "end": "2018-02-09T10:36:49.748221"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x55a3458af8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748253", 
      "end": "2018-02-09T10:36:49.748258"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "007831a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748287", 
      "end": "2018-02-09T10:36:49.748293"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748321", 
      "end": "2018-02-09T10:36:49.748327"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748355", 
      "end": "2018-02-09T10:36:49.748360"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x55a344ba68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748393", 
      "end": "2018-02-09T10:36:49.748398"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "007031a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748427", 
      "end": "2018-02-09T10:36:49.748434"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748462", 
      "end": "2018-02-09T10:36:49.748468"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748497", 
      "end": "2018-02-09T10:36:49.748504"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x55a33ef1e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748533", 
      "end": "2018-02-09T10:36:49.748538"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "007431a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748565", 
      "end": "2018-02-09T10:36:49.748571"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748599", 
      "end": "2018-02-09T10:36:49.748606"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748635", 
      "end": "2018-02-09T10:36:49.748641"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x55a3469f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748671", 
      "end": "2018-02-09T10:36:49.748677"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "006c31a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748706", 
      "end": "2018-02-09T10:36:49.748712"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748741", 
      "end": "2018-02-09T10:36:49.748747"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748774", 
      "end": "2018-02-09T10:36:49.748780"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748809", 
      "end": "2018-02-09T10:36:49.748815"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748843", 
      "end": "2018-02-09T10:36:49.748848"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748877", 
      "end": "2018-02-09T10:36:49.748883"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748911", 
      "end": "2018-02-09T10:36:49.748917"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x55a346cfe8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748947", 
      "end": "2018-02-09T10:36:49.748953"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "006831a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.748982", 
      "end": "2018-02-09T10:36:49.748987"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.749016", 
      "end": "2018-02-09T10:36:49.749022"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.749068", 
      "end": "2018-02-09T10:36:49.749076"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.749108", 
      "end": "2018-02-09T10:36:49.749115"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.749144", 
      "end": "2018-02-09T10:36:49.749149"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.749179", 
      "end": "2018-02-09T10:36:49.749184"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b54000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.749213", 
      "end": "2018-02-09T10:36:49.749219"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b54000", 
    "profiling": {
      "start": 315018746154560, 
      "end": 315018746232560, 
      "queued": 315018745916517, 
      "submit": 315018745955579
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      28, 
      256
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.749252", 
      "end": "2018-02-09T10:36:49.749961"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x55a346cfe8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750004", 
      "end": "2018-02-09T10:36:49.750011"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "006831a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750044", 
      "end": "2018-02-09T10:36:49.750052"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750082", 
      "end": "2018-02-09T10:36:49.750088"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750118", 
      "end": "2018-02-09T10:36:49.750123"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750152", 
      "end": "2018-02-09T10:36:49.750157"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750186", 
      "end": "2018-02-09T10:36:49.750191"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750222", 
      "end": "2018-02-09T10:36:49.750227"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750255", 
      "end": "2018-02-09T10:36:49.750261"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x55a33da858", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750293", 
      "end": "2018-02-09T10:36:49.750298"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002431a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750327", 
      "end": "2018-02-09T10:36:49.750332"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750361", 
      "end": "2018-02-09T10:36:49.750367"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750396", 
      "end": "2018-02-09T10:36:49.750401"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "78000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750431", 
      "end": "2018-02-09T10:36:49.750437"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "78000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750467", 
      "end": "2018-02-09T10:36:49.750472"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "100e0000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750502", 
      "end": "2018-02-09T10:36:49.750508"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "100e0000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53e00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750537", 
      "end": "2018-02-09T10:36:49.750543"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "7c000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b53e00", 
    "profiling": {
      "start": 315018747466662, 
      "end": 315018747547957, 
      "queued": 315018747235267, 
      "submit": 315018747270163
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      28, 
      256
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.750574", 
      "end": "2018-02-09T10:36:49.751307"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53a00", 
    "arg_value_ptr": "0x55a33da858", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.751353", 
      "end": "2018-02-09T10:36:49.751359"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002431a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53a00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.751392", 
      "end": "2018-02-09T10:36:49.751399"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53a00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.751429", 
      "end": "2018-02-09T10:36:49.751434"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53a00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.751465", 
      "end": "2018-02-09T10:36:49.751470"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "78000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53a00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.751501", 
      "end": "2018-02-09T10:36:49.751507"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "78000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53a00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.751537", 
      "end": "2018-02-09T10:36:49.751543"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "100e0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53a00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.751572", 
      "end": "2018-02-09T10:36:49.751578"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "100e0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53a00", 
    "arg_value_ptr": "0x7fe7417fa8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.751607", 
      "end": "2018-02-09T10:36:49.751612"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "7c000000", 
    "arg_index": 7
  }, 
  {
    "kernel": "0x55a2b53a00", 
    "profiling": {
      "start": 315018748518935, 
      "end": 315018748550290, 
      "queued": 315018748306100, 
      "submit": 315018748340475
    }, 
    "name": "fill_image_borders_constant", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      58, 
      1, 
      256
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.751646", 
      "end": "2018-02-09T10:36:49.752278"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x55a33da858", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752322", 
      "end": "2018-02-09T10:36:49.752330"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002431a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752362", 
      "end": "2018-02-09T10:36:49.752369"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752399", 
      "end": "2018-02-09T10:36:49.752405"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752435", 
      "end": "2018-02-09T10:36:49.752441"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "78000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752471", 
      "end": "2018-02-09T10:36:49.752477"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "78000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752506", 
      "end": "2018-02-09T10:36:49.752511"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "100e0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752540", 
      "end": "2018-02-09T10:36:49.752546"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "100e0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752576", 
      "end": "2018-02-09T10:36:49.752581"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x55a32ce6a8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752611", 
      "end": "2018-02-09T10:36:49.752617"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004c31a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752646", 
      "end": "2018-02-09T10:36:49.752652"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752680", 
      "end": "2018-02-09T10:36:49.752686"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752715", 
      "end": "2018-02-09T10:36:49.752719"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752747", 
      "end": "2018-02-09T10:36:49.752753"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752782", 
      "end": "2018-02-09T10:36:49.752788"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752818", 
      "end": "2018-02-09T10:36:49.752824"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752854", 
      "end": "2018-02-09T10:36:49.752859"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x55a3245d68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752889", 
      "end": "2018-02-09T10:36:49.752894"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "006031a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752924", 
      "end": "2018-02-09T10:36:49.752930"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752960", 
      "end": "2018-02-09T10:36:49.752966"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.752995", 
      "end": "2018-02-09T10:36:49.753001"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.753030", 
      "end": "2018-02-09T10:36:49.753036"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.753085", 
      "end": "2018-02-09T10:36:49.753091"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.753122", 
      "end": "2018-02-09T10:36:49.753129"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53c00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.753159", 
      "end": "2018-02-09T10:36:49.753164"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "kernel": "0x55a2b53c00", 
    "profiling": {
      "start": 315018750119562, 
      "end": 315018750225762, 
      "queued": 315018749868599, 
      "submit": 315018749997245
    }, 
    "name": "depthwise_convolution_3x3", 
    "lws": [
      7, 
      4, 
      3
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      14, 
      28, 
      256
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.753198", 
      "end": "2018-02-09T10:36:49.753754"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x55a327be18", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.753811", 
      "end": "2018-02-09T10:36:49.753819"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "005c31a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.753852", 
      "end": "2018-02-09T10:36:49.753858"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.753890", 
      "end": "2018-02-09T10:36:49.753896"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.753927", 
      "end": "2018-02-09T10:36:49.753932"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x55a31e7438", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.753964", 
      "end": "2018-02-09T10:36:49.753969"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "005831a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.753998", 
      "end": "2018-02-09T10:36:49.754004"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754034", 
      "end": "2018-02-09T10:36:49.754040"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754081", 
      "end": "2018-02-09T10:36:49.754088"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x55a3287658", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754121", 
      "end": "2018-02-09T10:36:49.754126"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "005031a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754157", 
      "end": "2018-02-09T10:36:49.754163"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754193", 
      "end": "2018-02-09T10:36:49.754199"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754230", 
      "end": "2018-02-09T10:36:49.754235"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x55a31a4068", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754267", 
      "end": "2018-02-09T10:36:49.754272"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "005431a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754303", 
      "end": "2018-02-09T10:36:49.754308"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754338", 
      "end": "2018-02-09T10:36:49.754345"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754376", 
      "end": "2018-02-09T10:36:49.754381"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x55a32ce6a8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754413", 
      "end": "2018-02-09T10:36:49.754417"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004c31a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754448", 
      "end": "2018-02-09T10:36:49.754457"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754488", 
      "end": "2018-02-09T10:36:49.754493"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754524", 
      "end": "2018-02-09T10:36:49.754529"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754560", 
      "end": "2018-02-09T10:36:49.754566"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754596", 
      "end": "2018-02-09T10:36:49.754601"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754631", 
      "end": "2018-02-09T10:36:49.754638"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754667", 
      "end": "2018-02-09T10:36:49.754672"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x55a3395208", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754704", 
      "end": "2018-02-09T10:36:49.754709"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004831a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754739", 
      "end": "2018-02-09T10:36:49.754745"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754776", 
      "end": "2018-02-09T10:36:49.754781"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754811", 
      "end": "2018-02-09T10:36:49.754817"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754847", 
      "end": "2018-02-09T10:36:49.754853"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754884", 
      "end": "2018-02-09T10:36:49.754889"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754919", 
      "end": "2018-02-09T10:36:49.754924"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754954", 
      "end": "2018-02-09T10:36:49.754960"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b53800", 
    "profiling": {
      "start": 315018751892027, 
      "end": 315018751970012, 
      "queued": 315018751659745, 
      "submit": 315018751692557
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      28, 
      256
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.754994", 
      "end": "2018-02-09T10:36:49.755700"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x55a3395208", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.755745", 
      "end": "2018-02-09T10:36:49.755752"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004831a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.755785", 
      "end": "2018-02-09T10:36:49.755792"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.755824", 
      "end": "2018-02-09T10:36:49.755830"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.755863", 
      "end": "2018-02-09T10:36:49.755868"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.755898", 
      "end": "2018-02-09T10:36:49.755905"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.755935", 
      "end": "2018-02-09T10:36:49.755941"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.755973", 
      "end": "2018-02-09T10:36:49.755978"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.756009", 
      "end": "2018-02-09T10:36:49.756015"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x55a33b4c08", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.756047", 
      "end": "2018-02-09T10:36:49.756053"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004031a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.756083", 
      "end": "2018-02-09T10:36:49.756088"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.756119", 
      "end": "2018-02-09T10:36:49.756124"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.756155", 
      "end": "2018-02-09T10:36:49.756161"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.756192", 
      "end": "2018-02-09T10:36:49.756197"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.756229", 
      "end": "2018-02-09T10:36:49.756234"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.756265", 
      "end": "2018-02-09T10:36:49.756270"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53600", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.756301", 
      "end": "2018-02-09T10:36:49.756307"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b53600", 
    "profiling": {
      "start": 315018753233345, 
      "end": 315018753301284, 
      "queued": 315018753002974, 
      "submit": 315018753038912
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      28, 
      256
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.756342", 
      "end": "2018-02-09T10:36:49.757028"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x55a33b4608", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757091", 
      "end": "2018-02-09T10:36:49.757099"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004431a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757134", 
      "end": "2018-02-09T10:36:49.757140"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757173", 
      "end": "2018-02-09T10:36:49.757179"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757211", 
      "end": "2018-02-09T10:36:49.757216"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757248", 
      "end": "2018-02-09T10:36:49.757254"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757284", 
      "end": "2018-02-09T10:36:49.757291"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757321", 
      "end": "2018-02-09T10:36:49.757327"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757358", 
      "end": "2018-02-09T10:36:49.757365"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417ff0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757395", 
      "end": "2018-02-09T10:36:49.757402"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00040000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x55a33b4c08", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757433", 
      "end": "2018-02-09T10:36:49.757440"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004031a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757471", 
      "end": "2018-02-09T10:36:49.757478"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757508", 
      "end": "2018-02-09T10:36:49.757514"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757546", 
      "end": "2018-02-09T10:36:49.757551"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757582", 
      "end": "2018-02-09T10:36:49.757587"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757619", 
      "end": "2018-02-09T10:36:49.757624"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757656", 
      "end": "2018-02-09T10:36:49.757661"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757692", 
      "end": "2018-02-09T10:36:49.757697"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x55a33b4f18", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757730", 
      "end": "2018-02-09T10:36:49.757735"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002c31a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757766", 
      "end": "2018-02-09T10:36:49.757771"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757802", 
      "end": "2018-02-09T10:36:49.757807"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757839", 
      "end": "2018-02-09T10:36:49.757844"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757876", 
      "end": "2018-02-09T10:36:49.757882"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c0010000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757913", 
      "end": "2018-02-09T10:36:49.757918"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757949", 
      "end": "2018-02-09T10:36:49.757956"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53400", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.757988", 
      "end": "2018-02-09T10:36:49.757993"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b53400", 
    "profiling": {
      "start": 315018754926145, 
      "end": 315018756979771, 
      "queued": 315018754692556, 
      "submit": 315018754727973
    }, 
    "name": "direct_convolution1x1_f32_bifrost_2", 
    "lws": [
      1, 
      1, 
      4
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      7, 
      256
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.758029", 
      "end": "2018-02-09T10:36:49.760717"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x55a359ec08", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.760768", 
      "end": "2018-02-09T10:36:49.760775"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003c31a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.760812", 
      "end": "2018-02-09T10:36:49.760820"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.760854", 
      "end": "2018-02-09T10:36:49.760860"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.760895", 
      "end": "2018-02-09T10:36:49.760902"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x55a35589d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.760936", 
      "end": "2018-02-09T10:36:49.760942"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003831a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.760975", 
      "end": "2018-02-09T10:36:49.760982"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761019", 
      "end": "2018-02-09T10:36:49.761027"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761078", 
      "end": "2018-02-09T10:36:49.761085"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x55a359f608", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761120", 
      "end": "2018-02-09T10:36:49.761125"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003031a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761158", 
      "end": "2018-02-09T10:36:49.761164"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761196", 
      "end": "2018-02-09T10:36:49.761202"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761234", 
      "end": "2018-02-09T10:36:49.761240"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x55a35a1238", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761271", 
      "end": "2018-02-09T10:36:49.761277"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003431a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761307", 
      "end": "2018-02-09T10:36:49.761313"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761343", 
      "end": "2018-02-09T10:36:49.761350"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761381", 
      "end": "2018-02-09T10:36:49.761386"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x55a33b4f18", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761418", 
      "end": "2018-02-09T10:36:49.761423"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002c31a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761455", 
      "end": "2018-02-09T10:36:49.761460"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761492", 
      "end": "2018-02-09T10:36:49.761497"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761528", 
      "end": "2018-02-09T10:36:49.761533"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761564", 
      "end": "2018-02-09T10:36:49.761570"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761601", 
      "end": "2018-02-09T10:36:49.761606"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761638", 
      "end": "2018-02-09T10:36:49.761643"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761673", 
      "end": "2018-02-09T10:36:49.761679"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x55a359aba8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761711", 
      "end": "2018-02-09T10:36:49.761716"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002831a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761747", 
      "end": "2018-02-09T10:36:49.761752"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761783", 
      "end": "2018-02-09T10:36:49.761789"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761820", 
      "end": "2018-02-09T10:36:49.761826"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761857", 
      "end": "2018-02-09T10:36:49.761863"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761894", 
      "end": "2018-02-09T10:36:49.761898"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761930", 
      "end": "2018-02-09T10:36:49.761936"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.761968", 
      "end": "2018-02-09T10:36:49.761973"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b53200", 
    "profiling": {
      "start": 315018758918865, 
      "end": 315018758997223, 
      "queued": 315018758673285, 
      "submit": 315018758708701
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      28, 
      256
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.762008", 
      "end": "2018-02-09T10:36:49.762559"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x55a359aba8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.762600", 
      "end": "2018-02-09T10:36:49.762607"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002831a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.762641", 
      "end": "2018-02-09T10:36:49.762646"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.762678", 
      "end": "2018-02-09T10:36:49.762684"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.762716", 
      "end": "2018-02-09T10:36:49.762722"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.762754", 
      "end": "2018-02-09T10:36:49.762760"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "70000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.762792", 
      "end": "2018-02-09T10:36:49.762797"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.762830", 
      "end": "2018-02-09T10:36:49.762835"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "400c0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.762868", 
      "end": "2018-02-09T10:36:49.762875"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x55a3457c48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.762909", 
      "end": "2018-02-09T10:36:49.762915"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e430a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.762947", 
      "end": "2018-02-09T10:36:49.762953"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.762986", 
      "end": "2018-02-09T10:36:49.762992"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.763025", 
      "end": "2018-02-09T10:36:49.763029"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "74000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.763063", 
      "end": "2018-02-09T10:36:49.763068"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "74000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.763101", 
      "end": "2018-02-09T10:36:49.763106"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "240d0000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.763138", 
      "end": "2018-02-09T10:36:49.763144"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "240d0000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b53000", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.763176", 
      "end": "2018-02-09T10:36:49.763181"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b53000", 
    "profiling": {
      "start": 315018760107000, 
      "end": 315018760190200, 
      "queued": 315018759892035, 
      "submit": 315018759924847
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      28, 
      256
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.763231", 
      "end": "2018-02-09T10:36:49.763770"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52c00", 
    "arg_value_ptr": "0x55a3457c48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.763812", 
      "end": "2018-02-09T10:36:49.763818"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e430a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52c00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.763850", 
      "end": "2018-02-09T10:36:49.763857"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52c00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.763889", 
      "end": "2018-02-09T10:36:49.763895"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52c00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.763928", 
      "end": "2018-02-09T10:36:49.763934"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "74000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52c00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.763966", 
      "end": "2018-02-09T10:36:49.763972"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "74000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52c00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.764004", 
      "end": "2018-02-09T10:36:49.764010"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "240d0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52c00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.764042", 
      "end": "2018-02-09T10:36:49.764047"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "240d0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52c00", 
    "arg_value_ptr": "0x7fe7417fa8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.764079", 
      "end": "2018-02-09T10:36:49.764085"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "kernel": "0x55a2b52c00", 
    "profiling": {
      "start": 315018761024781, 
      "end": 315018761051294, 
      "queued": 315018760780055, 
      "submit": 315018760882139
    }, 
    "name": "fill_image_borders_constant", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      57, 
      1, 
      256
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.764122", 
      "end": "2018-02-09T10:36:49.764585"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x55a3457c48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.764628", 
      "end": "2018-02-09T10:36:49.764634"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e430a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.764670", 
      "end": "2018-02-09T10:36:49.764677"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.764710", 
      "end": "2018-02-09T10:36:49.764716"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.764755", 
      "end": "2018-02-09T10:36:49.764762"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "74000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.764795", 
      "end": "2018-02-09T10:36:49.764801"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e8000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.764834", 
      "end": "2018-02-09T10:36:49.764840"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "240d0000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.764873", 
      "end": "2018-02-09T10:36:49.764879"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "240d0000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.764912", 
      "end": "2018-02-09T10:36:49.764917"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x55a3592e48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.764951", 
      "end": "2018-02-09T10:36:49.764957"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000c31a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765001", 
      "end": "2018-02-09T10:36:49.765006"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765041", 
      "end": "2018-02-09T10:36:49.765046"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765098", 
      "end": "2018-02-09T10:36:49.765104"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765139", 
      "end": "2018-02-09T10:36:49.765145"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765178", 
      "end": "2018-02-09T10:36:49.765183"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765216", 
      "end": "2018-02-09T10:36:49.765221"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765254", 
      "end": "2018-02-09T10:36:49.765260"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x55a35717c8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765294", 
      "end": "2018-02-09T10:36:49.765301"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002031a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765332", 
      "end": "2018-02-09T10:36:49.765338"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765370", 
      "end": "2018-02-09T10:36:49.765376"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765409", 
      "end": "2018-02-09T10:36:49.765415"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765447", 
      "end": "2018-02-09T10:36:49.765453"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765484", 
      "end": "2018-02-09T10:36:49.765490"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765523", 
      "end": "2018-02-09T10:36:49.765529"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52e00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765563", 
      "end": "2018-02-09T10:36:49.765568"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "kernel": "0x55a2b52e00", 
    "profiling": {
      "start": 315018762495173, 
      "end": 315018762569684, 
      "queued": 315018762271721, 
      "submit": 315018762306096
    }, 
    "name": "depthwise_convolution_3x3", 
    "lws": [
      1, 
      5, 
      2
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      14, 
      256
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.765604", 
      "end": "2018-02-09T10:36:49.766091"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x55a3547bb8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766134", 
      "end": "2018-02-09T10:36:49.766141"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "001c31a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766176", 
      "end": "2018-02-09T10:36:49.766182"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766215", 
      "end": "2018-02-09T10:36:49.766221"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766256", 
      "end": "2018-02-09T10:36:49.766262"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x55a355f618", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766295", 
      "end": "2018-02-09T10:36:49.766301"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "001831a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766332", 
      "end": "2018-02-09T10:36:49.766338"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766372", 
      "end": "2018-02-09T10:36:49.766377"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766410", 
      "end": "2018-02-09T10:36:49.766416"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x55a359ddc8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766450", 
      "end": "2018-02-09T10:36:49.766456"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "001031a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766489", 
      "end": "2018-02-09T10:36:49.766494"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766526", 
      "end": "2018-02-09T10:36:49.766531"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766566", 
      "end": "2018-02-09T10:36:49.766571"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x55a359f798", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766605", 
      "end": "2018-02-09T10:36:49.766610"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "001431a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766643", 
      "end": "2018-02-09T10:36:49.766648"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766681", 
      "end": "2018-02-09T10:36:49.766688"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766721", 
      "end": "2018-02-09T10:36:49.766727"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x55a3592e48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766760", 
      "end": "2018-02-09T10:36:49.766766"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000c31a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766798", 
      "end": "2018-02-09T10:36:49.766804"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766835", 
      "end": "2018-02-09T10:36:49.766841"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766875", 
      "end": "2018-02-09T10:36:49.766880"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766913", 
      "end": "2018-02-09T10:36:49.766918"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766952", 
      "end": "2018-02-09T10:36:49.766957"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.766990", 
      "end": "2018-02-09T10:36:49.766996"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.767030", 
      "end": "2018-02-09T10:36:49.767035"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x55a34b07d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.767070", 
      "end": "2018-02-09T10:36:49.767076"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000831a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.767109", 
      "end": "2018-02-09T10:36:49.767114"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.767148", 
      "end": "2018-02-09T10:36:49.767153"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.767187", 
      "end": "2018-02-09T10:36:49.767192"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.767226", 
      "end": "2018-02-09T10:36:49.767232"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.767265", 
      "end": "2018-02-09T10:36:49.767270"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.767304", 
      "end": "2018-02-09T10:36:49.767310"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.767343", 
      "end": "2018-02-09T10:36:49.767348"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b52a00", 
    "profiling": {
      "start": 315018764291448, 
      "end": 315018764319498, 
      "queued": 315018764053492, 
      "submit": 315018764086825
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      256
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.767388", 
      "end": "2018-02-09T10:36:49.767836"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x55a34b07d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.767880", 
      "end": "2018-02-09T10:36:49.767886"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000831a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.767921", 
      "end": "2018-02-09T10:36:49.767927"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.767962", 
      "end": "2018-02-09T10:36:49.767968"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.768002", 
      "end": "2018-02-09T10:36:49.768007"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.768041", 
      "end": "2018-02-09T10:36:49.768046"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.768080", 
      "end": "2018-02-09T10:36:49.768085"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.768119", 
      "end": "2018-02-09T10:36:49.768125"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.768158", 
      "end": "2018-02-09T10:36:49.768165"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x55a3574798", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.768200", 
      "end": "2018-02-09T10:36:49.768205"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000031a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.768239", 
      "end": "2018-02-09T10:36:49.768245"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.768279", 
      "end": "2018-02-09T10:36:49.768284"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.768318", 
      "end": "2018-02-09T10:36:49.768323"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.768359", 
      "end": "2018-02-09T10:36:49.768365"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.768399", 
      "end": "2018-02-09T10:36:49.768404"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00040000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.768438", 
      "end": "2018-02-09T10:36:49.768443"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00040000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52800", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.768477", 
      "end": "2018-02-09T10:36:49.768483"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b52800", 
    "profiling": {
      "start": 315018765415868, 
      "end": 315018765442548, 
      "queued": 315018765182659, 
      "submit": 315018765214950
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      256
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.768522", 
      "end": "2018-02-09T10:36:49.768962"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x55a355f068", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769006", 
      "end": "2018-02-09T10:36:49.769014"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000431a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769049", 
      "end": "2018-02-09T10:36:49.769072"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769109", 
      "end": "2018-02-09T10:36:49.769116"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769150", 
      "end": "2018-02-09T10:36:49.769155"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769190", 
      "end": "2018-02-09T10:36:49.769195"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769230", 
      "end": "2018-02-09T10:36:49.769236"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769269", 
      "end": "2018-02-09T10:36:49.769275"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769308", 
      "end": "2018-02-09T10:36:49.769313"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417ff0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769346", 
      "end": "2018-02-09T10:36:49.769352"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00040000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x55a3574798", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769388", 
      "end": "2018-02-09T10:36:49.769392"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000031a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769426", 
      "end": "2018-02-09T10:36:49.769431"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769466", 
      "end": "2018-02-09T10:36:49.769472"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769508", 
      "end": "2018-02-09T10:36:49.769515"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769549", 
      "end": "2018-02-09T10:36:49.769554"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769588", 
      "end": "2018-02-09T10:36:49.769593"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00040000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769627", 
      "end": "2018-02-09T10:36:49.769632"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00040000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769666", 
      "end": "2018-02-09T10:36:49.769671"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x55a3577c98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769707", 
      "end": "2018-02-09T10:36:49.769713"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00ec30a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769747", 
      "end": "2018-02-09T10:36:49.769753"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769787", 
      "end": "2018-02-09T10:36:49.769792"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769826", 
      "end": "2018-02-09T10:36:49.769831"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769865", 
      "end": "2018-02-09T10:36:49.769870"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769905", 
      "end": "2018-02-09T10:36:49.769910"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00040000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769945", 
      "end": "2018-02-09T10:36:49.769951"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00040000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52600", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.769984", 
      "end": "2018-02-09T10:36:49.769990"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b52600", 
    "profiling": {
      "start": 315018766924628, 
      "end": 315018768139268, 
      "queued": 315018766688908, 
      "submit": 315018766721720
    }, 
    "name": "direct_convolution1x1_f32_bifrost_2", 
    "lws": [
      1, 
      1, 
      8
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      4, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.770028", 
      "end": "2018-02-09T10:36:49.771657"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x55a34a4c78", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.771702", 
      "end": "2018-02-09T10:36:49.771708"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00fc30a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.771744", 
      "end": "2018-02-09T10:36:49.771751"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.771787", 
      "end": "2018-02-09T10:36:49.771792"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.771826", 
      "end": "2018-02-09T10:36:49.771832"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x55a33b3658", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.771867", 
      "end": "2018-02-09T10:36:49.771871"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f830a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.771906", 
      "end": "2018-02-09T10:36:49.771912"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.771946", 
      "end": "2018-02-09T10:36:49.771952"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.771985", 
      "end": "2018-02-09T10:36:49.771991"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x55a32ae1a8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772027", 
      "end": "2018-02-09T10:36:49.772032"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f030a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772067", 
      "end": "2018-02-09T10:36:49.772072"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772107", 
      "end": "2018-02-09T10:36:49.772113"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772147", 
      "end": "2018-02-09T10:36:49.772153"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x55a357da68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772193", 
      "end": "2018-02-09T10:36:49.772199"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f430a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772232", 
      "end": "2018-02-09T10:36:49.772238"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772273", 
      "end": "2018-02-09T10:36:49.772279"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772314", 
      "end": "2018-02-09T10:36:49.772320"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x55a3577c98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772356", 
      "end": "2018-02-09T10:36:49.772361"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00ec30a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772395", 
      "end": "2018-02-09T10:36:49.772401"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772435", 
      "end": "2018-02-09T10:36:49.772441"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772476", 
      "end": "2018-02-09T10:36:49.772481"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772516", 
      "end": "2018-02-09T10:36:49.772521"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772555", 
      "end": "2018-02-09T10:36:49.772561"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00040000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772595", 
      "end": "2018-02-09T10:36:49.772601"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00040000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772636", 
      "end": "2018-02-09T10:36:49.772642"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x55a3594d18", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772677", 
      "end": "2018-02-09T10:36:49.772682"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e830a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772718", 
      "end": "2018-02-09T10:36:49.772724"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772758", 
      "end": "2018-02-09T10:36:49.772764"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772798", 
      "end": "2018-02-09T10:36:49.772803"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772838", 
      "end": "2018-02-09T10:36:49.772843"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772877", 
      "end": "2018-02-09T10:36:49.772882"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772918", 
      "end": "2018-02-09T10:36:49.772924"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.772958", 
      "end": "2018-02-09T10:36:49.772964"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b52400", 
    "profiling": {
      "start": 315018769969314, 
      "end": 315018770012129, 
      "queued": 315018769667033, 
      "submit": 315018769813386
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.773003", 
      "end": "2018-02-09T10:36:49.773539"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x55a3594d18", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.773585", 
      "end": "2018-02-09T10:36:49.773592"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e830a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.773644", 
      "end": "2018-02-09T10:36:49.773651"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.773687", 
      "end": "2018-02-09T10:36:49.773692"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.773728", 
      "end": "2018-02-09T10:36:49.773733"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.773768", 
      "end": "2018-02-09T10:36:49.773774"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.773809", 
      "end": "2018-02-09T10:36:49.773815"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.773850", 
      "end": "2018-02-09T10:36:49.773855"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.773902", 
      "end": "2018-02-09T10:36:49.773908"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x55a3559a78", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.773949", 
      "end": "2018-02-09T10:36:49.773954"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a430a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.773991", 
      "end": "2018-02-09T10:36:49.773996"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.774043", 
      "end": "2018-02-09T10:36:49.774049"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.774081", 
      "end": "2018-02-09T10:36:49.774087"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.774123", 
      "end": "2018-02-09T10:36:49.774128"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.774161", 
      "end": "2018-02-09T10:36:49.774166"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.774199", 
      "end": "2018-02-09T10:36:49.774204"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52200", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.774237", 
      "end": "2018-02-09T10:36:49.774242"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "48000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b52200", 
    "profiling": {
      "start": 315018771179647, 
      "end": 315018771224974, 
      "queued": 315018770943073, 
      "submit": 315018770977969
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.774284", 
      "end": "2018-02-09T10:36:49.774763"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51e00", 
    "arg_value_ptr": "0x55a3559a78", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.774808", 
      "end": "2018-02-09T10:36:49.774815"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a430a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51e00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.774852", 
      "end": "2018-02-09T10:36:49.774860"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51e00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.774896", 
      "end": "2018-02-09T10:36:49.774902"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51e00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.774941", 
      "end": "2018-02-09T10:36:49.774947"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51e00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.774981", 
      "end": "2018-02-09T10:36:49.774986"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51e00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.775018", 
      "end": "2018-02-09T10:36:49.775024"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51e00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.775061", 
      "end": "2018-02-09T10:36:49.775067"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51e00", 
    "arg_value_ptr": "0x7fe7417fa8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.775100", 
      "end": "2018-02-09T10:36:49.775105"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "48000000", 
    "arg_index": 7
  }, 
  {
    "kernel": "0x55a2b51e00", 
    "profiling": {
      "start": 315018772122470, 
      "end": 315018772153127, 
      "queued": 315018771803490, 
      "submit": 315018771869115
    }, 
    "name": "fill_image_borders_constant", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      30, 
      1, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.775145", 
      "end": "2018-02-09T10:36:49.775674"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x55a3559a78", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.775716", 
      "end": "2018-02-09T10:36:49.775722"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a430a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.775761", 
      "end": "2018-02-09T10:36:49.775767"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.775802", 
      "end": "2018-02-09T10:36:49.775807"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.775840", 
      "end": "2018-02-09T10:36:49.775846"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.775883", 
      "end": "2018-02-09T10:36:49.775889"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.775923", 
      "end": "2018-02-09T10:36:49.775928"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.775961", 
      "end": "2018-02-09T10:36:49.775967"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776003", 
      "end": "2018-02-09T10:36:49.776008"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x55a35a0ec8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776043", 
      "end": "2018-02-09T10:36:49.776049"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00cc30a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776081", 
      "end": "2018-02-09T10:36:49.776087"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776125", 
      "end": "2018-02-09T10:36:49.776130"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776164", 
      "end": "2018-02-09T10:36:49.776168"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776206", 
      "end": "2018-02-09T10:36:49.776212"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776244", 
      "end": "2018-02-09T10:36:49.776250"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776282", 
      "end": "2018-02-09T10:36:49.776288"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776325", 
      "end": "2018-02-09T10:36:49.776330"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x55a33b6e38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776364", 
      "end": "2018-02-09T10:36:49.776369"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e030a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776402", 
      "end": "2018-02-09T10:36:49.776408"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776445", 
      "end": "2018-02-09T10:36:49.776450"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776483", 
      "end": "2018-02-09T10:36:49.776489"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776521", 
      "end": "2018-02-09T10:36:49.776527"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776568", 
      "end": "2018-02-09T10:36:49.776574"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776606", 
      "end": "2018-02-09T10:36:49.776612"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b52000", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776644", 
      "end": "2018-02-09T10:36:49.776650"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "kernel": "0x55a2b52000", 
    "profiling": {
      "start": 315018773583165, 
      "end": 315018773650893, 
      "queued": 315018773350886, 
      "submit": 315018773383177
    }, 
    "name": "depthwise_convolution_3x3", 
    "lws": [
      7, 
      7, 
      4
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.776690", 
      "end": "2018-02-09T10:36:49.777216"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x55a32ff308", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777266", 
      "end": "2018-02-09T10:36:49.777272"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00dc30a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777307", 
      "end": "2018-02-09T10:36:49.777315"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777349", 
      "end": "2018-02-09T10:36:49.777354"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777391", 
      "end": "2018-02-09T10:36:49.777396"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x55a318bba8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777430", 
      "end": "2018-02-09T10:36:49.777436"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d830a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777469", 
      "end": "2018-02-09T10:36:49.777475"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777512", 
      "end": "2018-02-09T10:36:49.777517"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777551", 
      "end": "2018-02-09T10:36:49.777556"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x55a359fbd8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777591", 
      "end": "2018-02-09T10:36:49.777596"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d030a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777633", 
      "end": "2018-02-09T10:36:49.777639"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777672", 
      "end": "2018-02-09T10:36:49.777677"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777711", 
      "end": "2018-02-09T10:36:49.777716"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x55a32f3468", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777755", 
      "end": "2018-02-09T10:36:49.777760"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d430a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777793", 
      "end": "2018-02-09T10:36:49.777799"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777836", 
      "end": "2018-02-09T10:36:49.777842"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777875", 
      "end": "2018-02-09T10:36:49.777881"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x55a35a0ec8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777915", 
      "end": "2018-02-09T10:36:49.777920"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00cc30a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777957", 
      "end": "2018-02-09T10:36:49.777963"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.777996", 
      "end": "2018-02-09T10:36:49.778002"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.778035", 
      "end": "2018-02-09T10:36:49.778040"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.778076", 
      "end": "2018-02-09T10:36:49.778082"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.778115", 
      "end": "2018-02-09T10:36:49.778121"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.778155", 
      "end": "2018-02-09T10:36:49.778161"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.778197", 
      "end": "2018-02-09T10:36:49.778203"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x55a33fc098", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.778239", 
      "end": "2018-02-09T10:36:49.778244"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c830a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.778276", 
      "end": "2018-02-09T10:36:49.778281"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.778317", 
      "end": "2018-02-09T10:36:49.778323"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.778357", 
      "end": "2018-02-09T10:36:49.778362"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.778396", 
      "end": "2018-02-09T10:36:49.778401"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.778439", 
      "end": "2018-02-09T10:36:49.778444"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.778477", 
      "end": "2018-02-09T10:36:49.778483"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51c00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.778520", 
      "end": "2018-02-09T10:36:49.778527"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b51c00", 
    "profiling": {
      "start": 315018775452184, 
      "end": 315018775496509, 
      "queued": 315018775233176, 
      "submit": 315018775265989
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.778569", 
      "end": "2018-02-09T10:36:49.779018"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x55a33fc098", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779066", 
      "end": "2018-02-09T10:36:49.779072"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c830a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779107", 
      "end": "2018-02-09T10:36:49.779114"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779148", 
      "end": "2018-02-09T10:36:49.779154"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779191", 
      "end": "2018-02-09T10:36:49.779198"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779232", 
      "end": "2018-02-09T10:36:49.779238"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779270", 
      "end": "2018-02-09T10:36:49.779276"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779315", 
      "end": "2018-02-09T10:36:49.779320"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779354", 
      "end": "2018-02-09T10:36:49.779360"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x55a3560258", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779394", 
      "end": "2018-02-09T10:36:49.779399"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c030a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779437", 
      "end": "2018-02-09T10:36:49.779442"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779476", 
      "end": "2018-02-09T10:36:49.779481"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779516", 
      "end": "2018-02-09T10:36:49.779521"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779559", 
      "end": "2018-02-09T10:36:49.779566"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779601", 
      "end": "2018-02-09T10:36:49.779606"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779645", 
      "end": "2018-02-09T10:36:49.779650"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51a00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779684", 
      "end": "2018-02-09T10:36:49.779690"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b51a00", 
    "profiling": {
      "start": 315018776607104, 
      "end": 315018776644580, 
      "queued": 315018776390989, 
      "submit": 315018776423281
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.779727", 
      "end": "2018-02-09T10:36:49.780167"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x55a346be68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780209", 
      "end": "2018-02-09T10:36:49.780216"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c430a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780251", 
      "end": "2018-02-09T10:36:49.780257"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780308", 
      "end": "2018-02-09T10:36:49.780314"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780350", 
      "end": "2018-02-09T10:36:49.780355"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780391", 
      "end": "2018-02-09T10:36:49.780396"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780435", 
      "end": "2018-02-09T10:36:49.780441"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780475", 
      "end": "2018-02-09T10:36:49.780481"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780515", 
      "end": "2018-02-09T10:36:49.780520"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417ff0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780557", 
      "end": "2018-02-09T10:36:49.780563"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00080000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x55a3560258", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780598", 
      "end": "2018-02-09T10:36:49.780603"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c030a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780640", 
      "end": "2018-02-09T10:36:49.780645"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780680", 
      "end": "2018-02-09T10:36:49.780686"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780720", 
      "end": "2018-02-09T10:36:49.780726"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780763", 
      "end": "2018-02-09T10:36:49.780768"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780803", 
      "end": "2018-02-09T10:36:49.780809"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780843", 
      "end": "2018-02-09T10:36:49.780848"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780886", 
      "end": "2018-02-09T10:36:49.780892"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x55a33d60d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780927", 
      "end": "2018-02-09T10:36:49.780932"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00ac30a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.780967", 
      "end": "2018-02-09T10:36:49.780973"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.781011", 
      "end": "2018-02-09T10:36:49.781016"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.781072", 
      "end": "2018-02-09T10:36:49.781079"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.781116", 
      "end": "2018-02-09T10:36:49.781121"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.781161", 
      "end": "2018-02-09T10:36:49.781166"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.781200", 
      "end": "2018-02-09T10:36:49.781205"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51800", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.781240", 
      "end": "2018-02-09T10:36:49.781245"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b51800", 
    "profiling": {
      "start": 315018778191687, 
      "end": 315018780754464, 
      "queued": 315018777949842, 
      "submit": 315018777983696
    }, 
    "name": "direct_convolution1x1_f32_bifrost_7", 
    "lws": [
      1, 
      1, 
      4
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      7, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.781289", 
      "end": "2018-02-09T10:36:49.784269"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x55a36b64d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784319", 
      "end": "2018-02-09T10:36:49.784326"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00bc30a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784363", 
      "end": "2018-02-09T10:36:49.784370"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784405", 
      "end": "2018-02-09T10:36:49.784410"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784451", 
      "end": "2018-02-09T10:36:49.784457"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x55a3671648", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784493", 
      "end": "2018-02-09T10:36:49.784499"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00b830a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784533", 
      "end": "2018-02-09T10:36:49.784539"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784577", 
      "end": "2018-02-09T10:36:49.784582"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784617", 
      "end": "2018-02-09T10:36:49.784623"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x55a359b1f8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784659", 
      "end": "2018-02-09T10:36:49.784664"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00b030a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784703", 
      "end": "2018-02-09T10:36:49.784708"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784743", 
      "end": "2018-02-09T10:36:49.784749"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784787", 
      "end": "2018-02-09T10:36:49.784793"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x55a35591e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784829", 
      "end": "2018-02-09T10:36:49.784834"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00b430a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784869", 
      "end": "2018-02-09T10:36:49.784875"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784912", 
      "end": "2018-02-09T10:36:49.784917"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784953", 
      "end": "2018-02-09T10:36:49.784958"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x55a33d60d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.784994", 
      "end": "2018-02-09T10:36:49.785000"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00ac30a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785038", 
      "end": "2018-02-09T10:36:49.785044"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785100", 
      "end": "2018-02-09T10:36:49.785106"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785143", 
      "end": "2018-02-09T10:36:49.785149"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785188", 
      "end": "2018-02-09T10:36:49.785193"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785229", 
      "end": "2018-02-09T10:36:49.785234"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785269", 
      "end": "2018-02-09T10:36:49.785275"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785313", 
      "end": "2018-02-09T10:36:49.785319"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x55a3683a58", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785356", 
      "end": "2018-02-09T10:36:49.785361"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a830a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785395", 
      "end": "2018-02-09T10:36:49.785401"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785439", 
      "end": "2018-02-09T10:36:49.785444"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785479", 
      "end": "2018-02-09T10:36:49.785485"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785523", 
      "end": "2018-02-09T10:36:49.785528"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785564", 
      "end": "2018-02-09T10:36:49.785569"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785604", 
      "end": "2018-02-09T10:36:49.785610"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785648", 
      "end": "2018-02-09T10:36:49.785653"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b51600", 
    "profiling": {
      "start": 315018782613684, 
      "end": 315018782656256, 
      "queued": 315018782357654, 
      "submit": 315018782489424
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.785692", 
      "end": "2018-02-09T10:36:49.786181"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x55a3683a58", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786232", 
      "end": "2018-02-09T10:36:49.786238"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a830a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786290", 
      "end": "2018-02-09T10:36:49.786296"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786333", 
      "end": "2018-02-09T10:36:49.786339"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786380", 
      "end": "2018-02-09T10:36:49.786385"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786420", 
      "end": "2018-02-09T10:36:49.786426"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786461", 
      "end": "2018-02-09T10:36:49.786466"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786507", 
      "end": "2018-02-09T10:36:49.786513"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786558", 
      "end": "2018-02-09T10:36:49.786564"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x55a3580528", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786607", 
      "end": "2018-02-09T10:36:49.786613"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004c65a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786649", 
      "end": "2018-02-09T10:36:49.786654"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786690", 
      "end": "2018-02-09T10:36:49.786695"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786734", 
      "end": "2018-02-09T10:36:49.786739"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786775", 
      "end": "2018-02-09T10:36:49.786780"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786815", 
      "end": "2018-02-09T10:36:49.786820"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786859", 
      "end": "2018-02-09T10:36:49.786864"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51400", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786899", 
      "end": "2018-02-09T10:36:49.786906"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "48000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b51400", 
    "profiling": {
      "start": 315018783847168, 
      "end": 315018783890411, 
      "queued": 315018783610779, 
      "submit": 315018783643591
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.786950", 
      "end": "2018-02-09T10:36:49.787430"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51000", 
    "arg_value_ptr": "0x55a3580528", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.787475", 
      "end": "2018-02-09T10:36:49.787481"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004c65a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51000", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.787517", 
      "end": "2018-02-09T10:36:49.787525"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51000", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.787565", 
      "end": "2018-02-09T10:36:49.787570"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51000", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.787606", 
      "end": "2018-02-09T10:36:49.787613"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51000", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.787652", 
      "end": "2018-02-09T10:36:49.787657"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51000", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.787693", 
      "end": "2018-02-09T10:36:49.787699"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51000", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.787734", 
      "end": "2018-02-09T10:36:49.787740"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51000", 
    "arg_value_ptr": "0x7fe7417fa8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.787780", 
      "end": "2018-02-09T10:36:49.787786"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "48000000", 
    "arg_index": 7
  }, 
  {
    "kernel": "0x55a2b51000", 
    "profiling": {
      "start": 315018784799080, 
      "end": 315018784826171, 
      "queued": 315018784483695, 
      "submit": 315018784526404
    }, 
    "name": "fill_image_borders_constant", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      30, 
      1, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.787825", 
      "end": "2018-02-09T10:36:49.788346"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x55a3580528", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.788395", 
      "end": "2018-02-09T10:36:49.788402"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004c65a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.788438", 
      "end": "2018-02-09T10:36:49.788444"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.788480", 
      "end": "2018-02-09T10:36:49.788486"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.788526", 
      "end": "2018-02-09T10:36:49.788531"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.788567", 
      "end": "2018-02-09T10:36:49.788573"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.788607", 
      "end": "2018-02-09T10:36:49.788613"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.788660", 
      "end": "2018-02-09T10:36:49.788666"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.788703", 
      "end": "2018-02-09T10:36:49.788709"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x55a3458d28", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.788746", 
      "end": "2018-02-09T10:36:49.788751"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "007465a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.788792", 
      "end": "2018-02-09T10:36:49.788798"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.788833", 
      "end": "2018-02-09T10:36:49.788839"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.788880", 
      "end": "2018-02-09T10:36:49.788886"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.788921", 
      "end": "2018-02-09T10:36:49.788927"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.788963", 
      "end": "2018-02-09T10:36:49.788967"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.789007", 
      "end": "2018-02-09T10:36:49.789013"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.789049", 
      "end": "2018-02-09T10:36:49.789075"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x55a3666af8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.789114", 
      "end": "2018-02-09T10:36:49.789119"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a030a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.789162", 
      "end": "2018-02-09T10:36:49.789168"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.789205", 
      "end": "2018-02-09T10:36:49.789211"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.789247", 
      "end": "2018-02-09T10:36:49.789252"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.789292", 
      "end": "2018-02-09T10:36:49.789298"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.789334", 
      "end": "2018-02-09T10:36:49.789339"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.789375", 
      "end": "2018-02-09T10:36:49.789380"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b51200", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.789420", 
      "end": "2018-02-09T10:36:49.789426"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "kernel": "0x55a2b51200", 
    "profiling": {
      "start": 315018786388543, 
      "end": 315018786453742, 
      "queued": 315018786127444, 
      "submit": 315018786166507
    }, 
    "name": "depthwise_convolution_3x3", 
    "lws": [
      7, 
      7, 
      4
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.789465", 
      "end": "2018-02-09T10:36:49.790238"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x55a36e0ce8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790283", 
      "end": "2018-02-09T10:36:49.790290"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "009c30a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790327", 
      "end": "2018-02-09T10:36:49.790333"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790374", 
      "end": "2018-02-09T10:36:49.790380"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790417", 
      "end": "2018-02-09T10:36:49.790423"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x55a3673378", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790460", 
      "end": "2018-02-09T10:36:49.790465"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "009830a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790505", 
      "end": "2018-02-09T10:36:49.790511"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790548", 
      "end": "2018-02-09T10:36:49.790553"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790590", 
      "end": "2018-02-09T10:36:49.790595"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x55a36ae658", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790638", 
      "end": "2018-02-09T10:36:49.790643"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "009030a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790679", 
      "end": "2018-02-09T10:36:49.790685"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790725", 
      "end": "2018-02-09T10:36:49.790730"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790767", 
      "end": "2018-02-09T10:36:49.790773"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x55a36852a8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790810", 
      "end": "2018-02-09T10:36:49.790815"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "009430a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790855", 
      "end": "2018-02-09T10:36:49.790861"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790898", 
      "end": "2018-02-09T10:36:49.790903"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790940", 
      "end": "2018-02-09T10:36:49.790945"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x55a3458d28", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.790985", 
      "end": "2018-02-09T10:36:49.790991"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "007465a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791027", 
      "end": "2018-02-09T10:36:49.791033"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791070", 
      "end": "2018-02-09T10:36:49.791076"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791115", 
      "end": "2018-02-09T10:36:49.791120"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791157", 
      "end": "2018-02-09T10:36:49.791163"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791199", 
      "end": "2018-02-09T10:36:49.791204"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791246", 
      "end": "2018-02-09T10:36:49.791251"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791289", 
      "end": "2018-02-09T10:36:49.791294"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x55a3597db8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791332", 
      "end": "2018-02-09T10:36:49.791338"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "007065a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791378", 
      "end": "2018-02-09T10:36:49.791383"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791419", 
      "end": "2018-02-09T10:36:49.791425"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791467", 
      "end": "2018-02-09T10:36:49.791472"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791508", 
      "end": "2018-02-09T10:36:49.791514"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791550", 
      "end": "2018-02-09T10:36:49.791555"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791595", 
      "end": "2018-02-09T10:36:49.791601"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50e00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791637", 
      "end": "2018-02-09T10:36:49.791642"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b50e00", 
    "profiling": {
      "start": 315018788579773, 
      "end": 315018788624086, 
      "queued": 315018788351403, 
      "submit": 315018788384215
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.791686", 
      "end": "2018-02-09T10:36:49.792368"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x55a3597db8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.792414", 
      "end": "2018-02-09T10:36:49.792420"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "007065a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.792458", 
      "end": "2018-02-09T10:36:49.792465"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.792507", 
      "end": "2018-02-09T10:36:49.792513"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.792550", 
      "end": "2018-02-09T10:36:49.792555"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.792591", 
      "end": "2018-02-09T10:36:49.792597"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.792638", 
      "end": "2018-02-09T10:36:49.792643"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.792679", 
      "end": "2018-02-09T10:36:49.792685"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.792725", 
      "end": "2018-02-09T10:36:49.792730"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x55a36746a8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.792768", 
      "end": "2018-02-09T10:36:49.792773"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "006865a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.792814", 
      "end": "2018-02-09T10:36:49.792819"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.792860", 
      "end": "2018-02-09T10:36:49.792865"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.792903", 
      "end": "2018-02-09T10:36:49.792908"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.792944", 
      "end": "2018-02-09T10:36:49.792950"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.792990", 
      "end": "2018-02-09T10:36:49.792994"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.793031", 
      "end": "2018-02-09T10:36:49.793037"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50c00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.793094", 
      "end": "2018-02-09T10:36:49.793101"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b50c00", 
    "profiling": {
      "start": 315018790160647, 
      "end": 315018790196056, 
      "queued": 315018789805047, 
      "submit": 315018789838381
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.793145", 
      "end": "2018-02-09T10:36:49.793936"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x55a3689f28", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.793981", 
      "end": "2018-02-09T10:36:49.793988"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "006c65a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794030", 
      "end": "2018-02-09T10:36:49.794037"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794074", 
      "end": "2018-02-09T10:36:49.794079"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794116", 
      "end": "2018-02-09T10:36:49.794122"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794163", 
      "end": "2018-02-09T10:36:49.794168"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794205", 
      "end": "2018-02-09T10:36:49.794211"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794251", 
      "end": "2018-02-09T10:36:49.794256"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794293", 
      "end": "2018-02-09T10:36:49.794299"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417ff0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794336", 
      "end": "2018-02-09T10:36:49.794342"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00080000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x55a36746a8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794382", 
      "end": "2018-02-09T10:36:49.794387"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "006865a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794425", 
      "end": "2018-02-09T10:36:49.794430"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794467", 
      "end": "2018-02-09T10:36:49.794472"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794512", 
      "end": "2018-02-09T10:36:49.794518"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794555", 
      "end": "2018-02-09T10:36:49.794561"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794598", 
      "end": "2018-02-09T10:36:49.794603"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794646", 
      "end": "2018-02-09T10:36:49.794651"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794690", 
      "end": "2018-02-09T10:36:49.794695"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x55a36b46b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794733", 
      "end": "2018-02-09T10:36:49.794739"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "005465a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794788", 
      "end": "2018-02-09T10:36:49.794793"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794831", 
      "end": "2018-02-09T10:36:49.794836"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794873", 
      "end": "2018-02-09T10:36:49.794879"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794920", 
      "end": "2018-02-09T10:36:49.794926"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.794963", 
      "end": "2018-02-09T10:36:49.794968"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.795009", 
      "end": "2018-02-09T10:36:49.795015"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50a00", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.795053", 
      "end": "2018-02-09T10:36:49.795058"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b50a00", 
    "profiling": {
      "start": 315018792006705, 
      "end": 315018794556614, 
      "queued": 315018791763902, 
      "submit": 315018791797235
    }, 
    "name": "direct_convolution1x1_f32_bifrost_7", 
    "lws": [
      1, 
      1, 
      4
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      7, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.795099", 
      "end": "2018-02-09T10:36:49.798298"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x55a352d278", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798344", 
      "end": "2018-02-09T10:36:49.798350"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "006465a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798389", 
      "end": "2018-02-09T10:36:49.798396"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798439", 
      "end": "2018-02-09T10:36:49.798445"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798484", 
      "end": "2018-02-09T10:36:49.798489"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x55a36951c8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798527", 
      "end": "2018-02-09T10:36:49.798532"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "006065a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798574", 
      "end": "2018-02-09T10:36:49.798580"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798618", 
      "end": "2018-02-09T10:36:49.798623"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798661", 
      "end": "2018-02-09T10:36:49.798667"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x55a3687398", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798712", 
      "end": "2018-02-09T10:36:49.798717"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "005865a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798755", 
      "end": "2018-02-09T10:36:49.798761"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798803", 
      "end": "2018-02-09T10:36:49.798809"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798847", 
      "end": "2018-02-09T10:36:49.798852"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x55a36a6078", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798891", 
      "end": "2018-02-09T10:36:49.798897"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "005c65a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798938", 
      "end": "2018-02-09T10:36:49.798944"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.798982", 
      "end": "2018-02-09T10:36:49.798987"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799026", 
      "end": "2018-02-09T10:36:49.799031"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x55a36b46b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799073", 
      "end": "2018-02-09T10:36:49.799078"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "005465a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799116", 
      "end": "2018-02-09T10:36:49.799122"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799160", 
      "end": "2018-02-09T10:36:49.799165"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799206", 
      "end": "2018-02-09T10:36:49.799212"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799251", 
      "end": "2018-02-09T10:36:49.799256"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799294", 
      "end": "2018-02-09T10:36:49.799300"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799340", 
      "end": "2018-02-09T10:36:49.799346"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799384", 
      "end": "2018-02-09T10:36:49.799389"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x55a36a8198", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799431", 
      "end": "2018-02-09T10:36:49.799436"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "005065a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799475", 
      "end": "2018-02-09T10:36:49.799480"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799518", 
      "end": "2018-02-09T10:36:49.799523"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799566", 
      "end": "2018-02-09T10:36:49.799572"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799610", 
      "end": "2018-02-09T10:36:49.799616"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799654", 
      "end": "2018-02-09T10:36:49.799659"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799700", 
      "end": "2018-02-09T10:36:49.799705"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799744", 
      "end": "2018-02-09T10:36:49.799749"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b50800", 
    "profiling": {
      "start": 315018796727462, 
      "end": 315018796771156, 
      "queued": 315018796461296, 
      "submit": 315018796600880
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.799795", 
      "end": "2018-02-09T10:36:49.800519"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x55a36a8198", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.800568", 
      "end": "2018-02-09T10:36:49.800575"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "005065a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.800615", 
      "end": "2018-02-09T10:36:49.800622"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.800679", 
      "end": "2018-02-09T10:36:49.800686"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.800726", 
      "end": "2018-02-09T10:36:49.800731"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.800775", 
      "end": "2018-02-09T10:36:49.800780"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.800818", 
      "end": "2018-02-09T10:36:49.800825"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.800863", 
      "end": "2018-02-09T10:36:49.800867"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.800911", 
      "end": "2018-02-09T10:36:49.800916"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x55a33edfb8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.800963", 
      "end": "2018-02-09T10:36:49.800968"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000c65a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.801006", 
      "end": "2018-02-09T10:36:49.801012"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.801081", 
      "end": "2018-02-09T10:36:49.801087"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.801129", 
      "end": "2018-02-09T10:36:49.801134"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.801174", 
      "end": "2018-02-09T10:36:49.801179"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.801221", 
      "end": "2018-02-09T10:36:49.801227"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.801264", 
      "end": "2018-02-09T10:36:49.801269"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50600", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.801307", 
      "end": "2018-02-09T10:36:49.801313"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "48000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b50600", 
    "profiling": {
      "start": 315018798287067, 
      "end": 315018798328771, 
      "queued": 315018798021191, 
      "submit": 315018798056087
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.801360", 
      "end": "2018-02-09T10:36:49.801904"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50200", 
    "arg_value_ptr": "0x55a33edfb8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.801965", 
      "end": "2018-02-09T10:36:49.801972"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000c65a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50200", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.802012", 
      "end": "2018-02-09T10:36:49.802019"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50200", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.802058", 
      "end": "2018-02-09T10:36:49.802063"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50200", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.802106", 
      "end": "2018-02-09T10:36:49.802112"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50200", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.802150", 
      "end": "2018-02-09T10:36:49.802155"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50200", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.802193", 
      "end": "2018-02-09T10:36:49.802198"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50200", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.802241", 
      "end": "2018-02-09T10:36:49.802247"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50200", 
    "arg_value_ptr": "0x7fe7417fa8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.802286", 
      "end": "2018-02-09T10:36:49.802291"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "48000000", 
    "arg_index": 7
  }, 
  {
    "kernel": "0x55a2b50200", 
    "profiling": {
      "start": 315018799235076, 
      "end": 315018799267401, 
      "queued": 315018798998795, 
      "submit": 315018799031608
    }, 
    "name": "fill_image_borders_constant", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      30, 
      1, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.802338", 
      "end": "2018-02-09T10:36:49.802808"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x55a33edfb8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.802856", 
      "end": "2018-02-09T10:36:49.802862"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000c65a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.802902", 
      "end": "2018-02-09T10:36:49.802909"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.802954", 
      "end": "2018-02-09T10:36:49.802960"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.802999", 
      "end": "2018-02-09T10:36:49.803004"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803049", 
      "end": "2018-02-09T10:36:49.803055"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803094", 
      "end": "2018-02-09T10:36:49.803100"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803138", 
      "end": "2018-02-09T10:36:49.803143"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803186", 
      "end": "2018-02-09T10:36:49.803191"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x55a35129b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803232", 
      "end": "2018-02-09T10:36:49.803237"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003465a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803277", 
      "end": "2018-02-09T10:36:49.803282"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803325", 
      "end": "2018-02-09T10:36:49.803330"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803369", 
      "end": "2018-02-09T10:36:49.803375"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803413", 
      "end": "2018-02-09T10:36:49.803418"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803461", 
      "end": "2018-02-09T10:36:49.803466"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803505", 
      "end": "2018-02-09T10:36:49.803511"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803549", 
      "end": "2018-02-09T10:36:49.803554"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x55a33a7578", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803598", 
      "end": "2018-02-09T10:36:49.803603"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004865a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803641", 
      "end": "2018-02-09T10:36:49.803648"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803686", 
      "end": "2018-02-09T10:36:49.803691"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803735", 
      "end": "2018-02-09T10:36:49.803740"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803779", 
      "end": "2018-02-09T10:36:49.803784"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803823", 
      "end": "2018-02-09T10:36:49.803828"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803879", 
      "end": "2018-02-09T10:36:49.803885"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50400", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803924", 
      "end": "2018-02-09T10:36:49.803929"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "kernel": "0x55a2b50400", 
    "profiling": {
      "start": 315018800874594, 
      "end": 315018800938756, 
      "queued": 315018800638379, 
      "submit": 315018800672754
    }, 
    "name": "depthwise_convolution_3x3", 
    "lws": [
      7, 
      7, 
      4
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.803976", 
      "end": "2018-02-09T10:36:49.804508"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x55a36b5f38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.804556", 
      "end": "2018-02-09T10:36:49.804563"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004465a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.804608", 
      "end": "2018-02-09T10:36:49.804615"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.804655", 
      "end": "2018-02-09T10:36:49.804661"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.804701", 
      "end": "2018-02-09T10:36:49.804706"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x55a3675408", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.804751", 
      "end": "2018-02-09T10:36:49.804756"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004065a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.804796", 
      "end": "2018-02-09T10:36:49.804802"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.804841", 
      "end": "2018-02-09T10:36:49.804847"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.804897", 
      "end": "2018-02-09T10:36:49.804903"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x55a3682f28", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.804943", 
      "end": "2018-02-09T10:36:49.804949"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003865a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.804989", 
      "end": "2018-02-09T10:36:49.804995"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805042", 
      "end": "2018-02-09T10:36:49.805048"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805109", 
      "end": "2018-02-09T10:36:49.805114"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x55a3675568", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805162", 
      "end": "2018-02-09T10:36:49.805167"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003c65a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805207", 
      "end": "2018-02-09T10:36:49.805213"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805253", 
      "end": "2018-02-09T10:36:49.805259"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805302", 
      "end": "2018-02-09T10:36:49.805307"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x55a35129b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805347", 
      "end": "2018-02-09T10:36:49.805352"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003465a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805391", 
      "end": "2018-02-09T10:36:49.805398"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805443", 
      "end": "2018-02-09T10:36:49.805448"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805488", 
      "end": "2018-02-09T10:36:49.805493"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805533", 
      "end": "2018-02-09T10:36:49.805538"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805583", 
      "end": "2018-02-09T10:36:49.805588"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805627", 
      "end": "2018-02-09T10:36:49.805634"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805673", 
      "end": "2018-02-09T10:36:49.805678"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x55a36b5dd8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805724", 
      "end": "2018-02-09T10:36:49.805729"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003065a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805769", 
      "end": "2018-02-09T10:36:49.805774"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805820", 
      "end": "2018-02-09T10:36:49.805825"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805865", 
      "end": "2018-02-09T10:36:49.805871"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805910", 
      "end": "2018-02-09T10:36:49.805916"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.805959", 
      "end": "2018-02-09T10:36:49.805964"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.806004", 
      "end": "2018-02-09T10:36:49.806010"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a2b50000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.806050", 
      "end": "2018-02-09T10:36:49.806055"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a2b50000", 
    "profiling": {
      "start": 315018803022724, 
      "end": 315018803065275, 
      "queued": 315018802776919, 
      "submit": 315018802813378
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.806103", 
      "end": "2018-02-09T10:36:49.806610"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x55a36b5dd8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.806666", 
      "end": "2018-02-09T10:36:49.806673"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003065a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.806713", 
      "end": "2018-02-09T10:36:49.806720"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.806760", 
      "end": "2018-02-09T10:36:49.806766"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.806810", 
      "end": "2018-02-09T10:36:49.806815"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.806855", 
      "end": "2018-02-09T10:36:49.806861"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.806900", 
      "end": "2018-02-09T10:36:49.806905"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.806955", 
      "end": "2018-02-09T10:36:49.806961"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.807001", 
      "end": "2018-02-09T10:36:49.807008"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x55a3670e08", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.807049", 
      "end": "2018-02-09T10:36:49.807054"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002865a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.807099", 
      "end": "2018-02-09T10:36:49.807104"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.807145", 
      "end": "2018-02-09T10:36:49.807151"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.807191", 
      "end": "2018-02-09T10:36:49.807196"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.807241", 
      "end": "2018-02-09T10:36:49.807247"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.807287", 
      "end": "2018-02-09T10:36:49.807292"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.807331", 
      "end": "2018-02-09T10:36:49.807337"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360c000", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.807384", 
      "end": "2018-02-09T10:36:49.807389"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a360c000", 
    "profiling": {
      "start": 315018804361133, 
      "end": 315018804397596, 
      "queued": 315018804099315, 
      "submit": 315018804136294
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.807433", 
      "end": "2018-02-09T10:36:49.807972"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x55a36afea8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808022", 
      "end": "2018-02-09T10:36:49.808028"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002c65a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808069", 
      "end": "2018-02-09T10:36:49.808076"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808122", 
      "end": "2018-02-09T10:36:49.808127"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808167", 
      "end": "2018-02-09T10:36:49.808173"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808213", 
      "end": "2018-02-09T10:36:49.808218"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808264", 
      "end": "2018-02-09T10:36:49.808269"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808310", 
      "end": "2018-02-09T10:36:49.808314"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808356", 
      "end": "2018-02-09T10:36:49.808361"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417ff0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808406", 
      "end": "2018-02-09T10:36:49.808411"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00080000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x55a3670e08", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808455", 
      "end": "2018-02-09T10:36:49.808460"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002865a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808505", 
      "end": "2018-02-09T10:36:49.808511"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808551", 
      "end": "2018-02-09T10:36:49.808556"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808597", 
      "end": "2018-02-09T10:36:49.808603"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808648", 
      "end": "2018-02-09T10:36:49.808653"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808694", 
      "end": "2018-02-09T10:36:49.808700"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808740", 
      "end": "2018-02-09T10:36:49.808746"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808791", 
      "end": "2018-02-09T10:36:49.808796"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x55a36afd48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808838", 
      "end": "2018-02-09T10:36:49.808843"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "001465a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808884", 
      "end": "2018-02-09T10:36:49.808890"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808935", 
      "end": "2018-02-09T10:36:49.808941"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.808981", 
      "end": "2018-02-09T10:36:49.808987"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.809027", 
      "end": "2018-02-09T10:36:49.809033"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.809099", 
      "end": "2018-02-09T10:36:49.809105"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.809146", 
      "end": "2018-02-09T10:36:49.809152"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360be00", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.809197", 
      "end": "2018-02-09T10:36:49.809203"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a360be00", 
    "profiling": {
      "start": 315018806172533, 
      "end": 315018808695885, 
      "queued": 315018805915981, 
      "submit": 315018805950356
    }, 
    "name": "direct_convolution1x1_f32_bifrost_7", 
    "lws": [
      1, 
      1, 
      4
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      7, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.809248", 
      "end": "2018-02-09T10:36:49.812232"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x55a34749e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812290", 
      "end": "2018-02-09T10:36:49.812297"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002465a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812338", 
      "end": "2018-02-09T10:36:49.812345"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812386", 
      "end": "2018-02-09T10:36:49.812392"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812437", 
      "end": "2018-02-09T10:36:49.812442"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x55a365ebe8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812484", 
      "end": "2018-02-09T10:36:49.812489"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002065a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812529", 
      "end": "2018-02-09T10:36:49.812535"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812583", 
      "end": "2018-02-09T10:36:49.812589"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812629", 
      "end": "2018-02-09T10:36:49.812635"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x55a32cf468", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812676", 
      "end": "2018-02-09T10:36:49.812681"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "001865a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812726", 
      "end": "2018-02-09T10:36:49.812733"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812773", 
      "end": "2018-02-09T10:36:49.812778"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812823", 
      "end": "2018-02-09T10:36:49.812829"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x55a365ed48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812873", 
      "end": "2018-02-09T10:36:49.812878"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "001c65a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812918", 
      "end": "2018-02-09T10:36:49.812924"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.812967", 
      "end": "2018-02-09T10:36:49.812973"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813014", 
      "end": "2018-02-09T10:36:49.813020"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x55a36afd48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813078", 
      "end": "2018-02-09T10:36:49.813084"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "001465a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813130", 
      "end": "2018-02-09T10:36:49.813136"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813177", 
      "end": "2018-02-09T10:36:49.813182"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813223", 
      "end": "2018-02-09T10:36:49.813228"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813273", 
      "end": "2018-02-09T10:36:49.813280"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813321", 
      "end": "2018-02-09T10:36:49.813325"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813366", 
      "end": "2018-02-09T10:36:49.813372"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813417", 
      "end": "2018-02-09T10:36:49.813423"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x55a3474888", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813464", 
      "end": "2018-02-09T10:36:49.813469"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "001065a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813509", 
      "end": "2018-02-09T10:36:49.813515"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813560", 
      "end": "2018-02-09T10:36:49.813566"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813606", 
      "end": "2018-02-09T10:36:49.813612"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813652", 
      "end": "2018-02-09T10:36:49.813658"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813703", 
      "end": "2018-02-09T10:36:49.813708"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813750", 
      "end": "2018-02-09T10:36:49.813755"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360bc00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813800", 
      "end": "2018-02-09T10:36:49.813806"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a360bc00", 
    "profiling": {
      "start": 315018810799687, 
      "end": 315018810842395, 
      "queued": 315018810516501, 
      "submit": 315018810669626
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.813851", 
      "end": "2018-02-09T10:36:49.814385"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x55a3474888", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.814456", 
      "end": "2018-02-09T10:36:49.814463"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "001065a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.814506", 
      "end": "2018-02-09T10:36:49.814513"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.814554", 
      "end": "2018-02-09T10:36:49.814560"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.814608", 
      "end": "2018-02-09T10:36:49.814613"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.814653", 
      "end": "2018-02-09T10:36:49.814660"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.814700", 
      "end": "2018-02-09T10:36:49.814705"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.814766", 
      "end": "2018-02-09T10:36:49.814772"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.814814", 
      "end": "2018-02-09T10:36:49.814820"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x55a35cd258", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.814867", 
      "end": "2018-02-09T10:36:49.814873"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00cc64a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.814914", 
      "end": "2018-02-09T10:36:49.814920"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.814961", 
      "end": "2018-02-09T10:36:49.814966"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.815017", 
      "end": "2018-02-09T10:36:49.815023"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.815065", 
      "end": "2018-02-09T10:36:49.815071"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.815112", 
      "end": "2018-02-09T10:36:49.815122"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.815167", 
      "end": "2018-02-09T10:36:49.815173"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ba00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.815214", 
      "end": "2018-02-09T10:36:49.815220"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "48000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a360ba00", 
    "profiling": {
      "start": 315018812198997, 
      "end": 315018812239146, 
      "queued": 315018811939417, 
      "submit": 315018811977438
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.815272", 
      "end": "2018-02-09T10:36:49.815813"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b600", 
    "arg_value_ptr": "0x55a35cd258", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.815864", 
      "end": "2018-02-09T10:36:49.815871"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00cc64a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b600", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.815918", 
      "end": "2018-02-09T10:36:49.815926"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b600", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.815968", 
      "end": "2018-02-09T10:36:49.815973"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b600", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.816015", 
      "end": "2018-02-09T10:36:49.816020"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b600", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.816066", 
      "end": "2018-02-09T10:36:49.816072"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b600", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.816113", 
      "end": "2018-02-09T10:36:49.816118"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b600", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.816160", 
      "end": "2018-02-09T10:36:49.816165"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b600", 
    "arg_value_ptr": "0x7fe7417fa8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.816212", 
      "end": "2018-02-09T10:36:49.816218"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "48000000", 
    "arg_index": 7
  }, 
  {
    "kernel": "0x55a360b600", 
    "profiling": {
      "start": 315018813160636, 
      "end": 315018813189143, 
      "queued": 315018812922230, 
      "submit": 315018812954001
    }, 
    "name": "fill_image_borders_constant", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      30, 
      1, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.816264", 
      "end": "2018-02-09T10:36:49.816734"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x55a35cd258", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.816790", 
      "end": "2018-02-09T10:36:49.816796"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00cc64a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.816838", 
      "end": "2018-02-09T10:36:49.816845"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.816887", 
      "end": "2018-02-09T10:36:49.816892"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.816940", 
      "end": "2018-02-09T10:36:49.816946"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.816987", 
      "end": "2018-02-09T10:36:49.816993"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817039", 
      "end": "2018-02-09T10:36:49.817044"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817107", 
      "end": "2018-02-09T10:36:49.817113"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817156", 
      "end": "2018-02-09T10:36:49.817161"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x55a3599218", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817216", 
      "end": "2018-02-09T10:36:49.817222"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f464a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817268", 
      "end": "2018-02-09T10:36:49.817274"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817316", 
      "end": "2018-02-09T10:36:49.817322"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817368", 
      "end": "2018-02-09T10:36:49.817374"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817415", 
      "end": "2018-02-09T10:36:49.817421"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817462", 
      "end": "2018-02-09T10:36:49.817467"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817517", 
      "end": "2018-02-09T10:36:49.817523"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817564", 
      "end": "2018-02-09T10:36:49.817570"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x55a3599378", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817613", 
      "end": "2018-02-09T10:36:49.817618"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000865a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817666", 
      "end": "2018-02-09T10:36:49.817671"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817713", 
      "end": "2018-02-09T10:36:49.817719"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817764", 
      "end": "2018-02-09T10:36:49.817770"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817812", 
      "end": "2018-02-09T10:36:49.817817"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817859", 
      "end": "2018-02-09T10:36:49.817865"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817911", 
      "end": "2018-02-09T10:36:49.817916"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b800", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.817960", 
      "end": "2018-02-09T10:36:49.817965"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "kernel": "0x55a360b800", 
    "profiling": {
      "start": 315018814945972, 
      "end": 315018815011052, 
      "queued": 315018814682646, 
      "submit": 315018814718583
    }, 
    "name": "depthwise_convolution_3x3", 
    "lws": [
      7, 
      7, 
      4
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.818016", 
      "end": "2018-02-09T10:36:49.818578"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x55a36bc3f8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.818628", 
      "end": "2018-02-09T10:36:49.818636"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000465a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.818678", 
      "end": "2018-02-09T10:36:49.818685"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.818734", 
      "end": "2018-02-09T10:36:49.818740"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.818783", 
      "end": "2018-02-09T10:36:49.818788"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x55a301e398", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.818831", 
      "end": "2018-02-09T10:36:49.818837"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000065a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.818883", 
      "end": "2018-02-09T10:36:49.818889"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.818932", 
      "end": "2018-02-09T10:36:49.818937"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.818982", 
      "end": "2018-02-09T10:36:49.818988"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x55a301e658", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819036", 
      "end": "2018-02-09T10:36:49.819040"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f864a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819082", 
      "end": "2018-02-09T10:36:49.819089"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819134", 
      "end": "2018-02-09T10:36:49.819140"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819183", 
      "end": "2018-02-09T10:36:49.819188"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x55a301e4f8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819231", 
      "end": "2018-02-09T10:36:49.819236"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00fc64a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819283", 
      "end": "2018-02-09T10:36:49.819288"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819330", 
      "end": "2018-02-09T10:36:49.819336"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819378", 
      "end": "2018-02-09T10:36:49.819383"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x55a3599218", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819430", 
      "end": "2018-02-09T10:36:49.819436"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f464a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819478", 
      "end": "2018-02-09T10:36:49.819484"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819525", 
      "end": "2018-02-09T10:36:49.819531"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819580", 
      "end": "2018-02-09T10:36:49.819586"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819628", 
      "end": "2018-02-09T10:36:49.819634"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819676", 
      "end": "2018-02-09T10:36:49.819681"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819727", 
      "end": "2018-02-09T10:36:49.819733"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819775", 
      "end": "2018-02-09T10:36:49.819781"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x55a36bc298", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819828", 
      "end": "2018-02-09T10:36:49.819834"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f064a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819876", 
      "end": "2018-02-09T10:36:49.819883"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819924", 
      "end": "2018-02-09T10:36:49.819930"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.819977", 
      "end": "2018-02-09T10:36:49.819983"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.820025", 
      "end": "2018-02-09T10:36:49.820030"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.820072", 
      "end": "2018-02-09T10:36:49.820078"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.820125", 
      "end": "2018-02-09T10:36:49.820130"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.820173", 
      "end": "2018-02-09T10:36:49.820179"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a360b400", 
    "profiling": {
      "start": 315018817152406, 
      "end": 315018817196113, 
      "queued": 315018816898271, 
      "submit": 315018816932125
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.820229", 
      "end": "2018-02-09T10:36:49.820765"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x55a36bc298", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.820822", 
      "end": "2018-02-09T10:36:49.820828"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f064a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.820875", 
      "end": "2018-02-09T10:36:49.820882"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.820934", 
      "end": "2018-02-09T10:36:49.820940"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.820985", 
      "end": "2018-02-09T10:36:49.820990"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.821035", 
      "end": "2018-02-09T10:36:49.821040"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.821105", 
      "end": "2018-02-09T10:36:49.821111"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.821159", 
      "end": "2018-02-09T10:36:49.821166"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.821222", 
      "end": "2018-02-09T10:36:49.821228"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x55a32d8e68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.821275", 
      "end": "2018-02-09T10:36:49.821284"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e864a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.821328", 
      "end": "2018-02-09T10:36:49.821334"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.821380", 
      "end": "2018-02-09T10:36:49.821386"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.821429", 
      "end": "2018-02-09T10:36:49.821435"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.821478", 
      "end": "2018-02-09T10:36:49.821483"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.821532", 
      "end": "2018-02-09T10:36:49.821537"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.821583", 
      "end": "2018-02-09T10:36:49.821589"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b200", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.821632", 
      "end": "2018-02-09T10:36:49.821637"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a360b200", 
    "profiling": {
      "start": 315018818576664, 
      "end": 315018818604167, 
      "queued": 315018818358686, 
      "submit": 315018818397749
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.821689", 
      "end": "2018-02-09T10:36:49.822119"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x55a33d9fc8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822177", 
      "end": "2018-02-09T10:36:49.822184"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00ec64a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822231", 
      "end": "2018-02-09T10:36:49.822237"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822283", 
      "end": "2018-02-09T10:36:49.822288"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822337", 
      "end": "2018-02-09T10:36:49.822342"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822389", 
      "end": "2018-02-09T10:36:49.822394"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822440", 
      "end": "2018-02-09T10:36:49.822446"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822493", 
      "end": "2018-02-09T10:36:49.822499"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822544", 
      "end": "2018-02-09T10:36:49.822550"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417ff0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822592", 
      "end": "2018-02-09T10:36:49.822598"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00080000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x55a32d8e68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822647", 
      "end": "2018-02-09T10:36:49.822652"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e864a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822696", 
      "end": "2018-02-09T10:36:49.822701"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822746", 
      "end": "2018-02-09T10:36:49.822752"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822802", 
      "end": "2018-02-09T10:36:49.822807"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822852", 
      "end": "2018-02-09T10:36:49.822858"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822911", 
      "end": "2018-02-09T10:36:49.822916"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.822965", 
      "end": "2018-02-09T10:36:49.822971"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.823015", 
      "end": "2018-02-09T10:36:49.823023"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x55a33d9e68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.823074", 
      "end": "2018-02-09T10:36:49.823079"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d464a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.823124", 
      "end": "2018-02-09T10:36:49.823129"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.823175", 
      "end": "2018-02-09T10:36:49.823180"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.823229", 
      "end": "2018-02-09T10:36:49.823235"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.823278", 
      "end": "2018-02-09T10:36:49.823284"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.823328", 
      "end": "2018-02-09T10:36:49.823334"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.823384", 
      "end": "2018-02-09T10:36:49.823389"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360b000", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.823433", 
      "end": "2018-02-09T10:36:49.823438"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a360b000", 
    "profiling": {
      "start": 315018820374637, 
      "end": 315018822944908, 
      "queued": 315018820156082, 
      "submit": 315018820189415
    }, 
    "name": "direct_convolution1x1_f32_bifrost_7", 
    "lws": [
      1, 
      1, 
      4
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      7, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.823491", 
      "end": "2018-02-09T10:36:49.826463"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x55a356ee48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.826514", 
      "end": "2018-02-09T10:36:49.826521"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e464a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.826576", 
      "end": "2018-02-09T10:36:49.826583"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.826629", 
      "end": "2018-02-09T10:36:49.826635"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.826682", 
      "end": "2018-02-09T10:36:49.826687"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x55a356efa8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.826737", 
      "end": "2018-02-09T10:36:49.826742"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e064a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.826788", 
      "end": "2018-02-09T10:36:49.826794"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.826838", 
      "end": "2018-02-09T10:36:49.826843"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.826894", 
      "end": "2018-02-09T10:36:49.826899"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x55a3147c58", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.826945", 
      "end": "2018-02-09T10:36:49.826950"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d864a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.826995", 
      "end": "2018-02-09T10:36:49.827001"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827049", 
      "end": "2018-02-09T10:36:49.827055"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827100", 
      "end": "2018-02-09T10:36:49.827106"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x55a3147af8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827155", 
      "end": "2018-02-09T10:36:49.827160"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00dc64a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827208", 
      "end": "2018-02-09T10:36:49.827214"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827260", 
      "end": "2018-02-09T10:36:49.827265"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827312", 
      "end": "2018-02-09T10:36:49.827317"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x55a33d9e68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827368", 
      "end": "2018-02-09T10:36:49.827373"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d464a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827420", 
      "end": "2018-02-09T10:36:49.827426"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827473", 
      "end": "2018-02-09T10:36:49.827478"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827522", 
      "end": "2018-02-09T10:36:49.827527"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827574", 
      "end": "2018-02-09T10:36:49.827579"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827627", 
      "end": "2018-02-09T10:36:49.827632"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827675", 
      "end": "2018-02-09T10:36:49.827681"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827729", 
      "end": "2018-02-09T10:36:49.827735"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x55a356ece8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827784", 
      "end": "2018-02-09T10:36:49.827789"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d064a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827832", 
      "end": "2018-02-09T10:36:49.827838"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827884", 
      "end": "2018-02-09T10:36:49.827889"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827939", 
      "end": "2018-02-09T10:36:49.827944"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.827988", 
      "end": "2018-02-09T10:36:49.827993"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.828040", 
      "end": "2018-02-09T10:36:49.828048"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.828095", 
      "end": "2018-02-09T10:36:49.828100"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ae00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.828146", 
      "end": "2018-02-09T10:36:49.828152"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a360ae00", 
    "profiling": {
      "start": 315018825144653, 
      "end": 315018825186688, 
      "queued": 315018824872748, 
      "submit": 315018825020664
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.828202", 
      "end": "2018-02-09T10:36:49.828718"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x55a356ece8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.828774", 
      "end": "2018-02-09T10:36:49.828780"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d064a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.828848", 
      "end": "2018-02-09T10:36:49.828855"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.828903", 
      "end": "2018-02-09T10:36:49.828912"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.828959", 
      "end": "2018-02-09T10:36:49.828964"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.829014", 
      "end": "2018-02-09T10:36:49.829022"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.829099", 
      "end": "2018-02-09T10:36:49.829105"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.829152", 
      "end": "2018-02-09T10:36:49.829158"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.829209", 
      "end": "2018-02-09T10:36:49.829215"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x55a36b0b38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.829263", 
      "end": "2018-02-09T10:36:49.829269"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "008c64a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.829316", 
      "end": "2018-02-09T10:36:49.829322"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.829369", 
      "end": "2018-02-09T10:36:49.829374"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.829419", 
      "end": "2018-02-09T10:36:49.829423"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.829470", 
      "end": "2018-02-09T10:36:49.829479"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.829534", 
      "end": "2018-02-09T10:36:49.829539"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.829589", 
      "end": "2018-02-09T10:36:49.829595"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360ac00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.829644", 
      "end": "2018-02-09T10:36:49.829650"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "48000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a360ac00", 
    "profiling": {
      "start": 315018826606969, 
      "end": 315018826651641, 
      "queued": 315018826359726, 
      "submit": 315018826397747
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.829701", 
      "end": "2018-02-09T10:36:49.830192"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a800", 
    "arg_value_ptr": "0x55a36b0b38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.830254", 
      "end": "2018-02-09T10:36:49.830261"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "008c64a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a800", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.830310", 
      "end": "2018-02-09T10:36:49.830317"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a800", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.830362", 
      "end": "2018-02-09T10:36:49.830367"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a800", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.830419", 
      "end": "2018-02-09T10:36:49.830425"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a800", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.830471", 
      "end": "2018-02-09T10:36:49.830476"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a800", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.830523", 
      "end": "2018-02-09T10:36:49.830528"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a800", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.830579", 
      "end": "2018-02-09T10:36:49.830585"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a800", 
    "arg_value_ptr": "0x7fe7417fa8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.830632", 
      "end": "2018-02-09T10:36:49.830637"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "48000000", 
    "arg_index": 7
  }, 
  {
    "kernel": "0x55a360a800", 
    "profiling": {
      "start": 315018827570470, 
      "end": 315018827601127, 
      "queued": 315018827355038, 
      "submit": 315018827387330
    }, 
    "name": "fill_image_borders_constant", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      30, 
      1, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.830692", 
      "end": "2018-02-09T10:36:49.831129"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x55a36b0b38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831182", 
      "end": "2018-02-09T10:36:49.831188"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "008c64a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831241", 
      "end": "2018-02-09T10:36:49.831248"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831298", 
      "end": "2018-02-09T10:36:49.831304"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831350", 
      "end": "2018-02-09T10:36:49.831356"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831405", 
      "end": "2018-02-09T10:36:49.831411"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831457", 
      "end": "2018-02-09T10:36:49.831462"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831507", 
      "end": "2018-02-09T10:36:49.831512"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40040000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831563", 
      "end": "2018-02-09T10:36:49.831571"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x55a36ba3a8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831620", 
      "end": "2018-02-09T10:36:49.831625"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00b464a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831672", 
      "end": "2018-02-09T10:36:49.831679"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831728", 
      "end": "2018-02-09T10:36:49.831735"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831781", 
      "end": "2018-02-09T10:36:49.831787"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831837", 
      "end": "2018-02-09T10:36:49.831842"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831889", 
      "end": "2018-02-09T10:36:49.831894"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831939", 
      "end": "2018-02-09T10:36:49.831944"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.831992", 
      "end": "2018-02-09T10:36:49.831997"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x55a36ba508", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.832045", 
      "end": "2018-02-09T10:36:49.832051"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c864a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.832095", 
      "end": "2018-02-09T10:36:49.832101"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.832151", 
      "end": "2018-02-09T10:36:49.832157"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.832205", 
      "end": "2018-02-09T10:36:49.832210"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.832258", 
      "end": "2018-02-09T10:36:49.832264"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.832313", 
      "end": "2018-02-09T10:36:49.832321"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.832369", 
      "end": "2018-02-09T10:36:49.832374"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360aa00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.832420", 
      "end": "2018-02-09T10:36:49.832425"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "kernel": "0x55a360aa00", 
    "profiling": {
      "start": 315018829378909, 
      "end": 315018829444250, 
      "queued": 315018829142018, 
      "submit": 315018829174830
    }, 
    "name": "depthwise_convolution_3x3", 
    "lws": [
      7, 
      7, 
      4
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      7, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.832479", 
      "end": "2018-02-09T10:36:49.833016"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x55a367f138", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833094", 
      "end": "2018-02-09T10:36:49.833101"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c464a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833151", 
      "end": "2018-02-09T10:36:49.833158"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833206", 
      "end": "2018-02-09T10:36:49.833213"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833263", 
      "end": "2018-02-09T10:36:49.833269"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x55a367f298", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833319", 
      "end": "2018-02-09T10:36:49.833324"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00c064a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833372", 
      "end": "2018-02-09T10:36:49.833377"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833428", 
      "end": "2018-02-09T10:36:49.833434"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833480", 
      "end": "2018-02-09T10:36:49.833486"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x55a36467b8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833534", 
      "end": "2018-02-09T10:36:49.833539"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00b864a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833590", 
      "end": "2018-02-09T10:36:49.833596"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833644", 
      "end": "2018-02-09T10:36:49.833649"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833696", 
      "end": "2018-02-09T10:36:49.833701"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x55a3646658", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833751", 
      "end": "2018-02-09T10:36:49.833756"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00bc64a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833804", 
      "end": "2018-02-09T10:36:49.833810"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833854", 
      "end": "2018-02-09T10:36:49.833860"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833909", 
      "end": "2018-02-09T10:36:49.833914"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x55a36ba3a8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.833962", 
      "end": "2018-02-09T10:36:49.833968"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00b464a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834015", 
      "end": "2018-02-09T10:36:49.834021"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834066", 
      "end": "2018-02-09T10:36:49.834071"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834119", 
      "end": "2018-02-09T10:36:49.834124"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834172", 
      "end": "2018-02-09T10:36:49.834177"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834222", 
      "end": "2018-02-09T10:36:49.834227"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834278", 
      "end": "2018-02-09T10:36:49.834283"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834335", 
      "end": "2018-02-09T10:36:49.834340"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x55a367efd8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834388", 
      "end": "2018-02-09T10:36:49.834394"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00b064a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834439", 
      "end": "2018-02-09T10:36:49.834445"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834493", 
      "end": "2018-02-09T10:36:49.834498"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834546", 
      "end": "2018-02-09T10:36:49.834551"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834596", 
      "end": "2018-02-09T10:36:49.834601"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834652", 
      "end": "2018-02-09T10:36:49.834658"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834702", 
      "end": "2018-02-09T10:36:49.834708"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a600", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834756", 
      "end": "2018-02-09T10:36:49.834761"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a360a600", 
    "profiling": {
      "start": 315018831727993, 
      "end": 315018831771123, 
      "queued": 315018831486808, 
      "submit": 315018831522225
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.834814", 
      "end": "2018-02-09T10:36:49.835298"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x55a367efd8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.835356", 
      "end": "2018-02-09T10:36:49.835362"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00b064a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.835414", 
      "end": "2018-02-09T10:36:49.835420"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.835467", 
      "end": "2018-02-09T10:36:49.835473"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.835524", 
      "end": "2018-02-09T10:36:49.835529"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.835578", 
      "end": "2018-02-09T10:36:49.835584"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.835633", 
      "end": "2018-02-09T10:36:49.835638"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.835687", 
      "end": "2018-02-09T10:36:49.835693"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.835738", 
      "end": "2018-02-09T10:36:49.835744"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x55a374e228", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.835793", 
      "end": "2018-02-09T10:36:49.835798"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a864a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.835849", 
      "end": "2018-02-09T10:36:49.835854"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.835903", 
      "end": "2018-02-09T10:36:49.835909"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.835956", 
      "end": "2018-02-09T10:36:49.835963"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.836014", 
      "end": "2018-02-09T10:36:49.836020"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.836065", 
      "end": "2018-02-09T10:36:49.836070"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.836121", 
      "end": "2018-02-09T10:36:49.836126"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a400", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.836181", 
      "end": "2018-02-09T10:36:49.836187"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a360a400", 
    "profiling": {
      "start": 315018833111575, 
      "end": 315018833151153, 
      "queued": 315018832897746, 
      "submit": 315018832928996
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.836238", 
      "end": "2018-02-09T10:36:49.836674"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x55a3759bb8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.836731", 
      "end": "2018-02-09T10:36:49.836737"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00ac64a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.836787", 
      "end": "2018-02-09T10:36:49.836793"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.836842", 
      "end": "2018-02-09T10:36:49.836848"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.836897", 
      "end": "2018-02-09T10:36:49.836902"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.836950", 
      "end": "2018-02-09T10:36:49.836955"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837005", 
      "end": "2018-02-09T10:36:49.837010"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837075", 
      "end": "2018-02-09T10:36:49.837081"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837130", 
      "end": "2018-02-09T10:36:49.837136"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417ff0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837186", 
      "end": "2018-02-09T10:36:49.837191"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00080000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x55a374e228", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837240", 
      "end": "2018-02-09T10:36:49.837245"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a864a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837292", 
      "end": "2018-02-09T10:36:49.837298"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837347", 
      "end": "2018-02-09T10:36:49.837352"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837399", 
      "end": "2018-02-09T10:36:49.837405"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837453", 
      "end": "2018-02-09T10:36:49.837459"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837508", 
      "end": "2018-02-09T10:36:49.837513"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837559", 
      "end": "2018-02-09T10:36:49.837564"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837612", 
      "end": "2018-02-09T10:36:49.837618"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x55a3759a58", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837668", 
      "end": "2018-02-09T10:36:49.837673"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "009464a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837719", 
      "end": "2018-02-09T10:36:49.837726"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837778", 
      "end": "2018-02-09T10:36:49.837784"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837833", 
      "end": "2018-02-09T10:36:49.837838"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837885", 
      "end": "2018-02-09T10:36:49.837891"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837943", 
      "end": "2018-02-09T10:36:49.837948"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.837995", 
      "end": "2018-02-09T10:36:49.838001"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a200", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.838050", 
      "end": "2018-02-09T10:36:49.838056"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a360a200", 
    "profiling": {
      "start": 315018835015049, 
      "end": 315018837496847, 
      "queued": 315018834774828, 
      "submit": 315018834809203
    }, 
    "name": "direct_convolution1x1_f32_bifrost_7", 
    "lws": [
      1, 
      1, 
      4
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      7, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.838108", 
      "end": "2018-02-09T10:36:49.841250"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x55a3764b28", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.841308", 
      "end": "2018-02-09T10:36:49.841314"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a464a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.841362", 
      "end": "2018-02-09T10:36:49.841369"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.841418", 
      "end": "2018-02-09T10:36:49.841424"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.841480", 
      "end": "2018-02-09T10:36:49.841486"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x55a3764c88", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.841536", 
      "end": "2018-02-09T10:36:49.841541"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00a064a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.841589", 
      "end": "2018-02-09T10:36:49.841596"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.841645", 
      "end": "2018-02-09T10:36:49.841650"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.841700", 
      "end": "2018-02-09T10:36:49.841705"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x55a3764f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.841755", 
      "end": "2018-02-09T10:36:49.841760"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "009864a355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.841809", 
      "end": "2018-02-09T10:36:49.841814"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.841861", 
      "end": "2018-02-09T10:36:49.841866"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.841913", 
      "end": "2018-02-09T10:36:49.841921"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x55a3764de8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.841971", 
      "end": "2018-02-09T10:36:49.841977"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "009c64a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842026", 
      "end": "2018-02-09T10:36:49.842032"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842081", 
      "end": "2018-02-09T10:36:49.842086"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842134", 
      "end": "2018-02-09T10:36:49.842139"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x55a3759a58", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842186", 
      "end": "2018-02-09T10:36:49.842194"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "009464a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842244", 
      "end": "2018-02-09T10:36:49.842249"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842296", 
      "end": "2018-02-09T10:36:49.842301"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842348", 
      "end": "2018-02-09T10:36:49.842353"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842405", 
      "end": "2018-02-09T10:36:49.842410"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842460", 
      "end": "2018-02-09T10:36:49.842465"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842513", 
      "end": "2018-02-09T10:36:49.842518"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842567", 
      "end": "2018-02-09T10:36:49.842573"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x55a37649c8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842623", 
      "end": "2018-02-09T10:36:49.842628"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "009064a355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842677", 
      "end": "2018-02-09T10:36:49.842683"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842735", 
      "end": "2018-02-09T10:36:49.842740"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842786", 
      "end": "2018-02-09T10:36:49.842792"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842839", 
      "end": "2018-02-09T10:36:49.842845"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842897", 
      "end": "2018-02-09T10:36:49.842902"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.842951", 
      "end": "2018-02-09T10:36:49.842956"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a360a000", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.843005", 
      "end": "2018-02-09T10:36:49.843010"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a360a000", 
    "profiling": {
      "start": 315018839993490, 
      "end": 315018840036775, 
      "queued": 315018839730035, 
      "submit": 315018839867015
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.843061", 
      "end": "2018-02-09T10:36:49.843786"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x55a37649c8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.843846", 
      "end": "2018-02-09T10:36:49.843853"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "009064a355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.843901", 
      "end": "2018-02-09T10:36:49.843907"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.843969", 
      "end": "2018-02-09T10:36:49.843975"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.844027", 
      "end": "2018-02-09T10:36:49.844033"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.844080", 
      "end": "2018-02-09T10:36:49.844086"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.844135", 
      "end": "2018-02-09T10:36:49.844140"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.844194", 
      "end": "2018-02-09T10:36:49.844200"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "80030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.844250", 
      "end": "2018-02-09T10:36:49.844256"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x55a3485188", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.844313", 
      "end": "2018-02-09T10:36:49.844319"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00347ba355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.844375", 
      "end": "2018-02-09T10:36:49.844381"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.844429", 
      "end": "2018-02-09T10:36:49.844434"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.844484", 
      "end": "2018-02-09T10:36:49.844489"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.844538", 
      "end": "2018-02-09T10:36:49.844544"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.844594", 
      "end": "2018-02-09T10:36:49.844599"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "fc030000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.844648", 
      "end": "2018-02-09T10:36:49.844653"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "fc030000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609e00", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.844703", 
      "end": "2018-02-09T10:36:49.844709"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a3609e00", 
    "profiling": {
      "start": 315018841658553, 
      "end": 315018841704828, 
      "queued": 315018841426910, 
      "submit": 315018841458681
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      14, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.844764", 
      "end": "2018-02-09T10:36:49.845462"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609a00", 
    "arg_value_ptr": "0x55a3485188", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.845522", 
      "end": "2018-02-09T10:36:49.845528"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00347ba355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609a00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.845578", 
      "end": "2018-02-09T10:36:49.845584"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609a00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.845638", 
      "end": "2018-02-09T10:36:49.845644"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609a00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.845699", 
      "end": "2018-02-09T10:36:49.845705"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609a00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.845757", 
      "end": "2018-02-09T10:36:49.845762"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609a00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.845812", 
      "end": "2018-02-09T10:36:49.845818"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "fc030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609a00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.845867", 
      "end": "2018-02-09T10:36:49.845873"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "fc030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609a00", 
    "arg_value_ptr": "0x7fe7417fa8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.845922", 
      "end": "2018-02-09T10:36:49.845927"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "kernel": "0x55a3609a00", 
    "profiling": {
      "start": 315018842757927, 
      "end": 315018842787641, 
      "queued": 315018842638368, 
      "submit": 315018842670139
    }, 
    "name": "fill_image_borders_constant", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      29, 
      1, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.845979", 
      "end": "2018-02-09T10:36:49.846390"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x55a3485188", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.846458", 
      "end": "2018-02-09T10:36:49.846465"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00347ba355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.846515", 
      "end": "2018-02-09T10:36:49.846522"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.846569", 
      "end": "2018-02-09T10:36:49.846575"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.846628", 
      "end": "2018-02-09T10:36:49.846634"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "44000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.846684", 
      "end": "2018-02-09T10:36:49.846689"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "88000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.846736", 
      "end": "2018-02-09T10:36:49.846742"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "fc030000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.846795", 
      "end": "2018-02-09T10:36:49.846800"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "fc030000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.846852", 
      "end": "2018-02-09T10:36:49.846858"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x55a3782e78", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.846912", 
      "end": "2018-02-09T10:36:49.846918"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "005c7ba355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.846971", 
      "end": "2018-02-09T10:36:49.846976"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847026", 
      "end": "2018-02-09T10:36:49.847032"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847082", 
      "end": "2018-02-09T10:36:49.847087"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847140", 
      "end": "2018-02-09T10:36:49.847146"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847196", 
      "end": "2018-02-09T10:36:49.847201"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847254", 
      "end": "2018-02-09T10:36:49.847259"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847310", 
      "end": "2018-02-09T10:36:49.847315"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x55a3782fd8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847369", 
      "end": "2018-02-09T10:36:49.847374"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "008864a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847435", 
      "end": "2018-02-09T10:36:49.847441"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847494", 
      "end": "2018-02-09T10:36:49.847499"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847553", 
      "end": "2018-02-09T10:36:49.847558"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847611", 
      "end": "2018-02-09T10:36:49.847617"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847668", 
      "end": "2018-02-09T10:36:49.847674"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847724", 
      "end": "2018-02-09T10:36:49.847730"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609c00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847783", 
      "end": "2018-02-09T10:36:49.847788"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "kernel": "0x55a3609c00", 
    "profiling": {
      "start": 315018844751704, 
      "end": 315018844803785, 
      "queued": 315018844522743, 
      "submit": 315018844555034
    }, 
    "name": "depthwise_convolution_3x3", 
    "lws": [
      1, 
      5, 
      2
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      7, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.847848", 
      "end": "2018-02-09T10:36:49.848537"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x55a3795488", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.848599", 
      "end": "2018-02-09T10:36:49.848607"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "008464a355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.848659", 
      "end": "2018-02-09T10:36:49.848665"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.848720", 
      "end": "2018-02-09T10:36:49.848726"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.848778", 
      "end": "2018-02-09T10:36:49.848784"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x55a37955e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.848838", 
      "end": "2018-02-09T10:36:49.848844"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "008064a355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.848900", 
      "end": "2018-02-09T10:36:49.848906"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.848957", 
      "end": "2018-02-09T10:36:49.848962"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849012", 
      "end": "2018-02-09T10:36:49.849018"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x55a37958a8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849100", 
      "end": "2018-02-09T10:36:49.849107"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00607ba355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849161", 
      "end": "2018-02-09T10:36:49.849167"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849218", 
      "end": "2018-02-09T10:36:49.849223"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849280", 
      "end": "2018-02-09T10:36:49.849285"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x55a3795748", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849337", 
      "end": "2018-02-09T10:36:49.849343"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "007c64a355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849394", 
      "end": "2018-02-09T10:36:49.849400"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849454", 
      "end": "2018-02-09T10:36:49.849459"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849510", 
      "end": "2018-02-09T10:36:49.849515"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x55a3782e78", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849573", 
      "end": "2018-02-09T10:36:49.849578"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "005c7ba355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849632", 
      "end": "2018-02-09T10:36:49.849637"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849688", 
      "end": "2018-02-09T10:36:49.849694"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849749", 
      "end": "2018-02-09T10:36:49.849754"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849808", 
      "end": "2018-02-09T10:36:49.849813"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849866", 
      "end": "2018-02-09T10:36:49.849871"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849925", 
      "end": "2018-02-09T10:36:49.849931"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.849983", 
      "end": "2018-02-09T10:36:49.849988"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x55a3795328", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.850044", 
      "end": "2018-02-09T10:36:49.850049"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00587ba355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.850102", 
      "end": "2018-02-09T10:36:49.850108"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.850158", 
      "end": "2018-02-09T10:36:49.850163"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.850215", 
      "end": "2018-02-09T10:36:49.850221"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.850281", 
      "end": "2018-02-09T10:36:49.850287"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.850338", 
      "end": "2018-02-09T10:36:49.850343"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.850397", 
      "end": "2018-02-09T10:36:49.850403"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609800", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.850455", 
      "end": "2018-02-09T10:36:49.850460"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a3609800", 
    "profiling": {
      "start": 315018847470441, 
      "end": 315018847493359, 
      "queued": 315018847187325, 
      "submit": 315018847318054
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      2, 
      7, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.850514", 
      "end": "2018-02-09T10:36:49.851229"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x55a3795328", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.851295", 
      "end": "2018-02-09T10:36:49.851301"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00587ba355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.851354", 
      "end": "2018-02-09T10:36:49.851360"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.851426", 
      "end": "2018-02-09T10:36:49.851432"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.851488", 
      "end": "2018-02-09T10:36:49.851493"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.851546", 
      "end": "2018-02-09T10:36:49.851551"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.851603", 
      "end": "2018-02-09T10:36:49.851608"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.851669", 
      "end": "2018-02-09T10:36:49.851674"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.851730", 
      "end": "2018-02-09T10:36:49.851735"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x55a37bc048", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.851799", 
      "end": "2018-02-09T10:36:49.851805"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00507ba355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.851860", 
      "end": "2018-02-09T10:36:49.851865"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.851918", 
      "end": "2018-02-09T10:36:49.851924"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.851975", 
      "end": "2018-02-09T10:36:49.851980"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.852038", 
      "end": "2018-02-09T10:36:49.852044"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.852101", 
      "end": "2018-02-09T10:36:49.852107"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.852161", 
      "end": "2018-02-09T10:36:49.852166"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609600", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.852222", 
      "end": "2018-02-09T10:36:49.852228"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a3609600", 
    "profiling": {
      "start": 315018849195818, 
      "end": 315018849215063, 
      "queued": 315018848955554, 
      "submit": 315018848987846
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      2, 
      7, 
      512
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.852286", 
      "end": "2018-02-09T10:36:49.852944"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x55a37cabb8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853008", 
      "end": "2018-02-09T10:36:49.853017"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00547ba355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853096", 
      "end": "2018-02-09T10:36:49.853103"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853156", 
      "end": "2018-02-09T10:36:49.853161"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853215", 
      "end": "2018-02-09T10:36:49.853221"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853279", 
      "end": "2018-02-09T10:36:49.853285"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853336", 
      "end": "2018-02-09T10:36:49.853342"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853394", 
      "end": "2018-02-09T10:36:49.853399"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853453", 
      "end": "2018-02-09T10:36:49.853459"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417ff0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853512", 
      "end": "2018-02-09T10:36:49.853517"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00080000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x55a37bc048", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853577", 
      "end": "2018-02-09T10:36:49.853583"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00507ba355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853635", 
      "end": "2018-02-09T10:36:49.853644"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853694", 
      "end": "2018-02-09T10:36:49.853700"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853755", 
      "end": "2018-02-09T10:36:49.853761"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853811", 
      "end": "2018-02-09T10:36:49.853817"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853868", 
      "end": "2018-02-09T10:36:49.853875"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.853937", 
      "end": "2018-02-09T10:36:49.853946"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.854000", 
      "end": "2018-02-09T10:36:49.854005"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x55a37caa58", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.854058", 
      "end": "2018-02-09T10:36:49.854066"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003c7ba355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.854121", 
      "end": "2018-02-09T10:36:49.854126"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.854181", 
      "end": "2018-02-09T10:36:49.854186"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.854239", 
      "end": "2018-02-09T10:36:49.854248"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.854304", 
      "end": "2018-02-09T10:36:49.854312"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.854363", 
      "end": "2018-02-09T10:36:49.854368"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.854421", 
      "end": "2018-02-09T10:36:49.854427"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609400", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.854483", 
      "end": "2018-02-09T10:36:49.854489"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a3609400", 
    "profiling": {
      "start": 315018851459880, 
      "end": 315018852764142, 
      "queued": 315018851215449, 
      "submit": 315018851249824
    }, 
    "name": "direct_convolution1x1_f32_bifrost_7", 
    "lws": [
      1, 
      1, 
      4
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      2, 
      4, 
      1024
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.854547", 
      "end": "2018-02-09T10:36:49.856515"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x55a37d5998", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.856581", 
      "end": "2018-02-09T10:36:49.856588"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "004c7ba355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.856643", 
      "end": "2018-02-09T10:36:49.856649"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.856707", 
      "end": "2018-02-09T10:36:49.856713"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.856769", 
      "end": "2018-02-09T10:36:49.856777"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x55a37d5af8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.856832", 
      "end": "2018-02-09T10:36:49.856839"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00487ba355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.856896", 
      "end": "2018-02-09T10:36:49.856901"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.856955", 
      "end": "2018-02-09T10:36:49.856960"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857013", 
      "end": "2018-02-09T10:36:49.857019"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x55a37d5db8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857098", 
      "end": "2018-02-09T10:36:49.857107"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00407ba355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857161", 
      "end": "2018-02-09T10:36:49.857167"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857227", 
      "end": "2018-02-09T10:36:49.857233"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857286", 
      "end": "2018-02-09T10:36:49.857292"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x55a37d5c58", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857344", 
      "end": "2018-02-09T10:36:49.857352"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00447ba355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857407", 
      "end": "2018-02-09T10:36:49.857413"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857467", 
      "end": "2018-02-09T10:36:49.857472"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857524", 
      "end": "2018-02-09T10:36:49.857530"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x55a37caa58", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857585", 
      "end": "2018-02-09T10:36:49.857591"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "003c7ba355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857641", 
      "end": "2018-02-09T10:36:49.857647"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857698", 
      "end": "2018-02-09T10:36:49.857704"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857760", 
      "end": "2018-02-09T10:36:49.857765"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857819", 
      "end": "2018-02-09T10:36:49.857827"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857877", 
      "end": "2018-02-09T10:36:49.857883"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857939", 
      "end": "2018-02-09T10:36:49.857946"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.857997", 
      "end": "2018-02-09T10:36:49.858005"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x55a37d5838", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.858058", 
      "end": "2018-02-09T10:36:49.858066"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00387ba355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.858122", 
      "end": "2018-02-09T10:36:49.858128"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.858181", 
      "end": "2018-02-09T10:36:49.858187"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.858247", 
      "end": "2018-02-09T10:36:49.858253"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.858305", 
      "end": "2018-02-09T10:36:49.858310"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.858361", 
      "end": "2018-02-09T10:36:49.858370"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.858432", 
      "end": "2018-02-09T10:36:49.858437"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609200", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.858489", 
      "end": "2018-02-09T10:36:49.858494"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a3609200", 
    "profiling": {
      "start": 315018855488217, 
      "end": 315018855520622, 
      "queued": 315018855238365, 
      "submit": 315018855277948
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      2, 
      7, 
      1024
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.858556", 
      "end": "2018-02-09T10:36:49.859051"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x55a37d5838", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859113", 
      "end": "2018-02-09T10:36:49.859122"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00387ba355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859173", 
      "end": "2018-02-09T10:36:49.859180"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859236", 
      "end": "2018-02-09T10:36:49.859246"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859299", 
      "end": "2018-02-09T10:36:49.859305"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859358", 
      "end": "2018-02-09T10:36:49.859363"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859419", 
      "end": "2018-02-09T10:36:49.859424"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859476", 
      "end": "2018-02-09T10:36:49.859482"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859538", 
      "end": "2018-02-09T10:36:49.859544"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x55a37827c8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859600", 
      "end": "2018-02-09T10:36:49.859607"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f47aa355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859658", 
      "end": "2018-02-09T10:36:49.859663"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859720", 
      "end": "2018-02-09T10:36:49.859725"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859776", 
      "end": "2018-02-09T10:36:49.859781"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "28000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859832", 
      "end": "2018-02-09T10:36:49.859840"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "28000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859897", 
      "end": "2018-02-09T10:36:49.859902"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "68010000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.859953", 
      "end": "2018-02-09T10:36:49.859958"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "68010000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3609000", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.860010", 
      "end": "2018-02-09T10:36:49.860015"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "2c000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a3609000", 
    "profiling": {
      "start": 315018856973596, 
      "end": 315018857006018, 
      "queued": 315018856735240, 
      "submit": 315018856771698
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      2, 
      7, 
      1024
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.860074", 
      "end": "2018-02-09T10:36:49.860748"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608c00", 
    "arg_value_ptr": "0x55a37827c8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.860824", 
      "end": "2018-02-09T10:36:49.860833"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f47aa355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608c00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.860898", 
      "end": "2018-02-09T10:36:49.860906"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608c00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.860964", 
      "end": "2018-02-09T10:36:49.860971"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608c00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.861034", 
      "end": "2018-02-09T10:36:49.861042"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "28000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608c00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.861121", 
      "end": "2018-02-09T10:36:49.861128"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "28000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608c00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.861181", 
      "end": "2018-02-09T10:36:49.861186"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "68010000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608c00", 
    "arg_value_ptr": "0x7fe7417fac", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.861247", 
      "end": "2018-02-09T10:36:49.861255"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "68010000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608c00", 
    "arg_value_ptr": "0x7fe7417fa8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.861307", 
      "end": "2018-02-09T10:36:49.861313"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "2c000000", 
    "arg_index": 7
  }, 
  {
    "kernel": "0x55a3608c00", 
    "profiling": {
      "start": 315018858284976, 
      "end": 315018858306335, 
      "queued": 315018858041489, 
      "submit": 315018858076385
    }, 
    "name": "fill_image_borders_constant", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      16, 
      1, 
      1024
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.861372", 
      "end": "2018-02-09T10:36:49.862051"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x55a37827c8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862113", 
      "end": "2018-02-09T10:36:49.862120"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f47aa355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862174", 
      "end": "2018-02-09T10:36:49.862180"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862238", 
      "end": "2018-02-09T10:36:49.862246"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862298", 
      "end": "2018-02-09T10:36:49.862304"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "28000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862357", 
      "end": "2018-02-09T10:36:49.862362"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "28000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862417", 
      "end": "2018-02-09T10:36:49.862423"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "68010000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862475", 
      "end": "2018-02-09T10:36:49.862482"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "68010000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862533", 
      "end": "2018-02-09T10:36:49.862541"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x55a37f2678", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862597", 
      "end": "2018-02-09T10:36:49.862605"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "001c7ba355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862659", 
      "end": "2018-02-09T10:36:49.862664"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862721", 
      "end": "2018-02-09T10:36:49.862726"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862778", 
      "end": "2018-02-09T10:36:49.862785"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862842", 
      "end": "2018-02-09T10:36:49.862852"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862909", 
      "end": "2018-02-09T10:36:49.862915"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.862968", 
      "end": "2018-02-09T10:36:49.862975"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.863029", 
      "end": "2018-02-09T10:36:49.863038"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x55a37f27d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.863094", 
      "end": "2018-02-09T10:36:49.863100"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00307ba355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.863153", 
      "end": "2018-02-09T10:36:49.863161"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.863214", 
      "end": "2018-02-09T10:36:49.863222"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.863284", 
      "end": "2018-02-09T10:36:49.863290"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "0c000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.863345", 
      "end": "2018-02-09T10:36:49.863350"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.863404", 
      "end": "2018-02-09T10:36:49.863409"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.863463", 
      "end": "2018-02-09T10:36:49.863469"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "24000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608e00", 
    "arg_value_ptr": "0x7fe7417e98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.863520", 
      "end": "2018-02-09T10:36:49.863525"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "kernel": "0x55a3608e00", 
    "profiling": {
      "start": 315018860492360, 
      "end": 315018860535000, 
      "queued": 315018860255030, 
      "submit": 315018860289405
    }, 
    "name": "depthwise_convolution_3x3", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      4, 
      7, 
      1024
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.863586", 
      "end": "2018-02-09T10:36:49.864066"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x55a3808188", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864131", 
      "end": "2018-02-09T10:36:49.864138"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "002c7ba355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864195", 
      "end": "2018-02-09T10:36:49.864201"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864256", 
      "end": "2018-02-09T10:36:49.864262"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864317", 
      "end": "2018-02-09T10:36:49.864325"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x55a38082e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864382", 
      "end": "2018-02-09T10:36:49.864387"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00287ba355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864441", 
      "end": "2018-02-09T10:36:49.864446"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864500", 
      "end": "2018-02-09T10:36:49.864508"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864568", 
      "end": "2018-02-09T10:36:49.864574"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x55a38085a8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864632", 
      "end": "2018-02-09T10:36:49.864640"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00207ba355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864691", 
      "end": "2018-02-09T10:36:49.864697"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864753", 
      "end": "2018-02-09T10:36:49.864759"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864811", 
      "end": "2018-02-09T10:36:49.864817"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x55a3808448", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864871", 
      "end": "2018-02-09T10:36:49.864876"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00247ba355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864935", 
      "end": "2018-02-09T10:36:49.864944"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.864995", 
      "end": "2018-02-09T10:36:49.865003"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865081", 
      "end": "2018-02-09T10:36:49.865086"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x55a37f2678", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865141", 
      "end": "2018-02-09T10:36:49.865146"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "001c7ba355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865200", 
      "end": "2018-02-09T10:36:49.865206"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865262", 
      "end": "2018-02-09T10:36:49.865268"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865321", 
      "end": "2018-02-09T10:36:49.865326"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865380", 
      "end": "2018-02-09T10:36:49.865386"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865442", 
      "end": "2018-02-09T10:36:49.865447"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865499", 
      "end": "2018-02-09T10:36:49.865508"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865561", 
      "end": "2018-02-09T10:36:49.865569"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x55a3808028", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865636", 
      "end": "2018-02-09T10:36:49.865643"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00187ba355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865696", 
      "end": "2018-02-09T10:36:49.865701"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865755", 
      "end": "2018-02-09T10:36:49.865762"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865819", 
      "end": "2018-02-09T10:36:49.865824"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865875", 
      "end": "2018-02-09T10:36:49.865881"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865936", 
      "end": "2018-02-09T10:36:49.865941"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.865995", 
      "end": "2018-02-09T10:36:49.866000"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608a00", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.866055", 
      "end": "2018-02-09T10:36:49.866060"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a3608a00", 
    "profiling": {
      "start": 315018863110976, 
      "end": 315018863142810, 
      "queued": 315018862795654, 
      "submit": 315018862946175
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      2, 
      7, 
      1024
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.866120", 
      "end": "2018-02-09T10:36:49.866670"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x55a3808028", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.866755", 
      "end": "2018-02-09T10:36:49.866763"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00187ba355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.866822", 
      "end": "2018-02-09T10:36:49.866829"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.866884", 
      "end": "2018-02-09T10:36:49.866890"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.866942", 
      "end": "2018-02-09T10:36:49.866948"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.867018", 
      "end": "2018-02-09T10:36:49.867024"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.867086", 
      "end": "2018-02-09T10:36:49.867091"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.867150", 
      "end": "2018-02-09T10:36:49.867156"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.867209", 
      "end": "2018-02-09T10:36:49.867217"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x55a381cd48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.867274", 
      "end": "2018-02-09T10:36:49.867282"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00107ba355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.867343", 
      "end": "2018-02-09T10:36:49.867348"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.867405", 
      "end": "2018-02-09T10:36:49.867410"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.867462", 
      "end": "2018-02-09T10:36:49.867468"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.867523", 
      "end": "2018-02-09T10:36:49.867528"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.867580", 
      "end": "2018-02-09T10:36:49.867585"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.867637", 
      "end": "2018-02-09T10:36:49.867643"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608800", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.867700", 
      "end": "2018-02-09T10:36:49.867709"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a3608800", 
    "profiling": {
      "start": 315018864675382, 
      "end": 315018864700336, 
      "queued": 315018864434717, 
      "submit": 315018864470654
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      2, 
      7, 
      1024
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.867767", 
      "end": "2018-02-09T10:36:49.868233"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x55a3826568", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.868298", 
      "end": "2018-02-09T10:36:49.868308"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00147ba355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.868361", 
      "end": "2018-02-09T10:36:49.868370"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.868425", 
      "end": "2018-02-09T10:36:49.868430"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.868486", 
      "end": "2018-02-09T10:36:49.868492"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.868543", 
      "end": "2018-02-09T10:36:49.868548"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "08000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.868606", 
      "end": "2018-02-09T10:36:49.868612"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.868664", 
      "end": "2018-02-09T10:36:49.868669"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.868726", 
      "end": "2018-02-09T10:36:49.868731"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417ff0", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.868790", 
      "end": "2018-02-09T10:36:49.868796"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00100000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x55a381cd48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.868850", 
      "end": "2018-02-09T10:36:49.868857"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00107ba355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.868911", 
      "end": "2018-02-09T10:36:49.868917"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.868974", 
      "end": "2018-02-09T10:36:49.868980"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.869034", 
      "end": "2018-02-09T10:36:49.869040"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.869115", 
      "end": "2018-02-09T10:36:49.869121"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.869179", 
      "end": "2018-02-09T10:36:49.869184"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.869240", 
      "end": "2018-02-09T10:36:49.869246"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.869298", 
      "end": "2018-02-09T10:36:49.869307"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x55a3826408", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.869363", 
      "end": "2018-02-09T10:36:49.869368"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00fc7aa355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.869421", 
      "end": "2018-02-09T10:36:49.869427"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.869479", 
      "end": "2018-02-09T10:36:49.869485"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.869540", 
      "end": "2018-02-09T10:36:49.869546"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.869600", 
      "end": "2018-02-09T10:36:49.869608"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.869667", 
      "end": "2018-02-09T10:36:49.869674"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417eec", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.869729", 
      "end": "2018-02-09T10:36:49.869737"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608600", 
    "arg_value_ptr": "0x7fe7417ee8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.869791", 
      "end": "2018-02-09T10:36:49.869796"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a3608600", 
    "profiling": {
      "start": 315018866779083, 
      "end": 315018869765541, 
      "queued": 315018866521174, 
      "submit": 315018866567008
    }, 
    "name": "direct_convolution1x1_f32_bifrost_7", 
    "lws": [
      2, 
      1, 
      2
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      2, 
      4, 
      1024
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.869857", 
      "end": "2018-02-09T10:36:49.873295"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x55a391e7e8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.873358", 
      "end": "2018-02-09T10:36:49.873367"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "000c7ba355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.873430", 
      "end": "2018-02-09T10:36:49.873437"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.873492", 
      "end": "2018-02-09T10:36:49.873497"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.873550", 
      "end": "2018-02-09T10:36:49.873558"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x55a3943138", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.873627", 
      "end": "2018-02-09T10:36:49.873635"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00087ba355000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.873691", 
      "end": "2018-02-09T10:36:49.873699"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.873755", 
      "end": "2018-02-09T10:36:49.873760"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.873817", 
      "end": "2018-02-09T10:36:49.873823"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x55a34e5ec8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.873877", 
      "end": "2018-02-09T10:36:49.873884"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00007ba355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.873942", 
      "end": "2018-02-09T10:36:49.873947"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874002", 
      "end": "2018-02-09T10:36:49.874010"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874065", 
      "end": "2018-02-09T10:36:49.874073"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x55a3976c08", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874132", 
      "end": "2018-02-09T10:36:49.874137"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00047ba355000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874192", 
      "end": "2018-02-09T10:36:49.874198"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874253", 
      "end": "2018-02-09T10:36:49.874260"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874320", 
      "end": "2018-02-09T10:36:49.874327"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x55a3826408", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874381", 
      "end": "2018-02-09T10:36:49.874390"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00fc7aa355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874445", 
      "end": "2018-02-09T10:36:49.874453"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874510", 
      "end": "2018-02-09T10:36:49.874516"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874570", 
      "end": "2018-02-09T10:36:49.874575"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874631", 
      "end": "2018-02-09T10:36:49.874636"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874693", 
      "end": "2018-02-09T10:36:49.874698"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874753", 
      "end": "2018-02-09T10:36:49.874758"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00010000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874819", 
      "end": "2018-02-09T10:36:49.874826"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x55a39572c8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874883", 
      "end": "2018-02-09T10:36:49.874889"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f87aa355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.874944", 
      "end": "2018-02-09T10:36:49.874953"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.875014", 
      "end": "2018-02-09T10:36:49.875020"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.875074", 
      "end": "2018-02-09T10:36:49.875082"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.875135", 
      "end": "2018-02-09T10:36:49.875141"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.875199", 
      "end": "2018-02-09T10:36:49.875207"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f4c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.875260", 
      "end": "2018-02-09T10:36:49.875268"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608400", 
    "arg_value_ptr": "0x7fe7417f48", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.875321", 
      "end": "2018-02-09T10:36:49.875330"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a3608400", 
    "profiling": {
      "start": 315018872334262, 
      "end": 315018872366145, 
      "queued": 315018872063361, 
      "submit": 315018872113882
    }, 
    "name": "batchnormalization_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      2, 
      7, 
      1024
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.875394", 
      "end": "2018-02-09T10:36:49.875894"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x55a39572c8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.875962", 
      "end": "2018-02-09T10:36:49.875969"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f87aa355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876026", 
      "end": "2018-02-09T10:36:49.876033"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876089", 
      "end": "2018-02-09T10:36:49.876095"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876154", 
      "end": "2018-02-09T10:36:49.876159"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876215", 
      "end": "2018-02-09T10:36:49.876221"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876275", 
      "end": "2018-02-09T10:36:49.876281"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876337", 
      "end": "2018-02-09T10:36:49.876344"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876397", 
      "end": "2018-02-09T10:36:49.876403"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x55a37f1ff8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876458", 
      "end": "2018-02-09T10:36:49.876466"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f07aa355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876522", 
      "end": "2018-02-09T10:36:49.876527"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876582", 
      "end": "2018-02-09T10:36:49.876588"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876643", 
      "end": "2018-02-09T10:36:49.876648"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876708", 
      "end": "2018-02-09T10:36:49.876714"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876769", 
      "end": "2018-02-09T10:36:49.876775"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x7fe7417f6c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876829", 
      "end": "2018-02-09T10:36:49.876837"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608200", 
    "arg_value_ptr": "0x7fe7417f68", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876899", 
      "end": "2018-02-09T10:36:49.876906"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a3608200", 
    "profiling": {
      "start": 315018873901331, 
      "end": 315018873927385, 
      "queued": 315018873625340, 
      "submit": 315018873659194
    }, 
    "name": "activation_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      2, 
      7, 
      1024
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.876967", 
      "end": "2018-02-09T10:36:49.877492"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x55a37f1ff8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.877560", 
      "end": "2018-02-09T10:36:49.877569"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00f07aa355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x7fe7417f1c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.877624", 
      "end": "2018-02-09T10:36:49.877633"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x7fe7417f1c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.877694", 
      "end": "2018-02-09T10:36:49.877700"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x7fe7417f1c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.877757", 
      "end": "2018-02-09T10:36:49.877762"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x7fe7417f1c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.877819", 
      "end": "2018-02-09T10:36:49.877825"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "20000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x7fe7417f1c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.877885", 
      "end": "2018-02-09T10:36:49.877891"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x7fe7417f1c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.877945", 
      "end": "2018-02-09T10:36:49.877954"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "e0000000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x7fe7417f18", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.878008", 
      "end": "2018-02-09T10:36:49.878013"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x55a3922fc8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.878072", 
      "end": "2018-02-09T10:36:49.878079"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e47aa355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x7fe7417f1c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.878133", 
      "end": "2018-02-09T10:36:49.878139"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x7fe7417f1c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.878195", 
      "end": "2018-02-09T10:36:49.878203"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x7fe7417f1c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.878261", 
      "end": "2018-02-09T10:36:49.878269"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x7fe7417f1c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.878325", 
      "end": "2018-02-09T10:36:49.878333"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x7fe7417f1c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.878392", 
      "end": "2018-02-09T10:36:49.878397"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x7fe7417f1c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.878455", 
      "end": "2018-02-09T10:36:49.878460"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3608000", 
    "arg_value_ptr": "0x7fe7417f18", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.878517", 
      "end": "2018-02-09T10:36:49.878522"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a3608000", 
    "profiling": {
      "start": 315018875507139, 
      "end": 315018875571459, 
      "queued": 315018875245651, 
      "submit": 315018875287839
    }, 
    "name": "pooling_layer_N", 
    "lws": [
      1, 
      1, 
      1
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      1, 
      1, 
      1024
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.878586", 
      "end": "2018-02-09T10:36:49.879121"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x55a384cb18", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.879191", 
      "end": "2018-02-09T10:36:49.879198"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00ec7aa355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.879258", 
      "end": "2018-02-09T10:36:49.879265"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.879321", 
      "end": "2018-02-09T10:36:49.879326"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.879380", 
      "end": "2018-02-09T10:36:49.879388"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.879446", 
      "end": "2018-02-09T10:36:49.879452"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.879508", 
      "end": "2018-02-09T10:36:49.879514"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.879572", 
      "end": "2018-02-09T10:36:49.879578"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.879636", 
      "end": "2018-02-09T10:36:49.879641"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x55a3352ca8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.879697", 
      "end": "2018-02-09T10:36:49.879705"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e87aa355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.879766", 
      "end": "2018-02-09T10:36:49.879772"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.879828", 
      "end": "2018-02-09T10:36:49.879834"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.879889", 
      "end": "2018-02-09T10:36:49.879894"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7418040", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.879955", 
      "end": "2018-02-09T10:36:49.879960"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00100000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x55a3922fc8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880016", 
      "end": "2018-02-09T10:36:49.880024"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e47aa355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880080", 
      "end": "2018-02-09T10:36:49.880089"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880146", 
      "end": "2018-02-09T10:36:49.880152"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880209", 
      "end": "2018-02-09T10:36:49.880215"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880269", 
      "end": "2018-02-09T10:36:49.880274"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880335", 
      "end": "2018-02-09T10:36:49.880345"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880401", 
      "end": "2018-02-09T10:36:49.880406"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880460", 
      "end": "2018-02-09T10:36:49.880466"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x55a391ce08", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880524", 
      "end": "2018-02-09T10:36:49.880533"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e07aa355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880590", 
      "end": "2018-02-09T10:36:49.880596"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880654", 
      "end": "2018-02-09T10:36:49.880660"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880718", 
      "end": "2018-02-09T10:36:49.880726"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880781", 
      "end": "2018-02-09T10:36:49.880787"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880847", 
      "end": "2018-02-09T10:36:49.880852"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f3c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880908", 
      "end": "2018-02-09T10:36:49.880914"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607e00", 
    "arg_value_ptr": "0x7fe7417f38", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.880968", 
      "end": "2018-02-09T10:36:49.880973"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a3607e00", 
    "profiling": {
      "start": 315018877977004, 
      "end": 315018879605746, 
      "queued": 315018877733150, 
      "submit": 315018877769609
    }, 
    "name": "direct_convolution1x1_f32_bifrost_1", 
    "lws": [
      1, 
      1, 
      1
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      1, 
      1, 
      1001
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.881042", 
      "end": "2018-02-09T10:36:49.883126"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x55a391ce08", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.883190", 
      "end": "2018-02-09T10:36:49.883199"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00e07aa355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417fcc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.883260", 
      "end": "2018-02-09T10:36:49.883266"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417fcc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.883321", 
      "end": "2018-02-09T10:36:49.883327"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417fcc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.883383", 
      "end": "2018-02-09T10:36:49.883387"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417fcc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.883451", 
      "end": "2018-02-09T10:36:49.883460"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417fcc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.883517", 
      "end": "2018-02-09T10:36:49.883522"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417fcc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.883582", 
      "end": "2018-02-09T10:36:49.883588"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417fc8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.883645", 
      "end": "2018-02-09T10:36:49.883653"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x55a3a89308", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.883712", 
      "end": "2018-02-09T10:36:49.883719"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d07aa355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417fcc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.883781", 
      "end": "2018-02-09T10:36:49.883786"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417fcc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.883842", 
      "end": "2018-02-09T10:36:49.883850"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417fcc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.883905", 
      "end": "2018-02-09T10:36:49.883910"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "b00f0000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417fcc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.883968", 
      "end": "2018-02-09T10:36:49.883975"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "b00f0000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417fcc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.884030", 
      "end": "2018-02-09T10:36:49.884038"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417fcc", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.884093", 
      "end": "2018-02-09T10:36:49.884101"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607c00", 
    "arg_value_ptr": "0x7fe7417fc8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.884162", 
      "end": "2018-02-09T10:36:49.884168"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "kernel": "0x55a3607c00", 
    "profiling": {
      "start": 315018881181345, 
      "end": 315018881190220, 
      "queued": 315018880895130, 
      "submit": 315018881052421
    }, 
    "name": "reshape_layer", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      1, 
      1, 
      1001
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.884227", 
      "end": "2018-02-09T10:36:49.884735"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x55a3a89308", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.884808", 
      "end": "2018-02-09T10:36:49.884815"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d07aa355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.884889", 
      "end": "2018-02-09T10:36:49.884899"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.884959", 
      "end": "2018-02-09T10:36:49.884966"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885024", 
      "end": "2018-02-09T10:36:49.885029"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "b00f0000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885117", 
      "end": "2018-02-09T10:36:49.885127"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "b00f0000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885199", 
      "end": "2018-02-09T10:36:49.885205"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885263", 
      "end": "2018-02-09T10:36:49.885271"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885326", 
      "end": "2018-02-09T10:36:49.885331"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x55a34e59d8", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885391", 
      "end": "2018-02-09T10:36:49.885396"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d87aa355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885452", 
      "end": "2018-02-09T10:36:49.885459"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885517", 
      "end": "2018-02-09T10:36:49.885522"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885582", 
      "end": "2018-02-09T10:36:49.885588"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885643", 
      "end": "2018-02-09T10:36:49.885648"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885704", 
      "end": "2018-02-09T10:36:49.885709"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885768", 
      "end": "2018-02-09T10:36:49.885773"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885829", 
      "end": "2018-02-09T10:36:49.885837"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x55a34e5c78", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885896", 
      "end": "2018-02-09T10:36:49.885901"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00dc7aa355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.885960", 
      "end": "2018-02-09T10:36:49.885966"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886022", 
      "end": "2018-02-09T10:36:49.886028"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886088", 
      "end": "2018-02-09T10:36:49.886093"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c00f0000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886148", 
      "end": "2018-02-09T10:36:49.886153"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c00f0000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886211", 
      "end": "2018-02-09T10:36:49.886216"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886285", 
      "end": "2018-02-09T10:36:49.886291"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886349", 
      "end": "2018-02-09T10:36:49.886354"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x55a34e5b28", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886413", 
      "end": "2018-02-09T10:36:49.886420"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d47aa355000000", 
    "arg_index": 24
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886481", 
      "end": "2018-02-09T10:36:49.886486"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 25
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886544", 
      "end": "2018-02-09T10:36:49.886550"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "10000000", 
    "arg_index": 26
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886606", 
      "end": "2018-02-09T10:36:49.886611"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 27
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886670", 
      "end": "2018-02-09T10:36:49.886676"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 28
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886734", 
      "end": "2018-02-09T10:36:49.886739"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 29
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f9c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886794", 
      "end": "2018-02-09T10:36:49.886800"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 30
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607a00", 
    "arg_value_ptr": "0x7fe7417f98", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886865", 
      "end": "2018-02-09T10:36:49.886870"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 31
  }, 
  {
    "kernel": "0x55a3607a00", 
    "profiling": {
      "start": 315018883850048, 
      "end": 315018883875065, 
      "queued": 315018883601379, 
      "submit": 315018883636795
    }, 
    "name": "softmax_layer_max_shift_exp_sum_parallel", 
    "lws": [
      64, 
      1, 
      1
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      64, 
      1, 
      1
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.886930", 
      "end": "2018-02-09T10:36:49.887398"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x55a34e5c78", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.887470", 
      "end": "2018-02-09T10:36:49.887479"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00dc7aa355000000", 
    "arg_index": 0
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.887538", 
      "end": "2018-02-09T10:36:49.887546"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 1
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.887606", 
      "end": "2018-02-09T10:36:49.887613"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 2
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.887669", 
      "end": "2018-02-09T10:36:49.887674"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c00f0000", 
    "arg_index": 3
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.887733", 
      "end": "2018-02-09T10:36:49.887738"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c00f0000", 
    "arg_index": 4
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.887799", 
      "end": "2018-02-09T10:36:49.887804"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 5
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.887859", 
      "end": "2018-02-09T10:36:49.887865"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 6
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f08", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.887922", 
      "end": "2018-02-09T10:36:49.887930"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 7
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x55a34e5b28", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.887990", 
      "end": "2018-02-09T10:36:49.887995"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00d47aa355000000", 
    "arg_index": 8
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888053", 
      "end": "2018-02-09T10:36:49.888058"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 9
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888115", 
      "end": "2018-02-09T10:36:49.888120"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 10
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888180", 
      "end": "2018-02-09T10:36:49.888189"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 11
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888245", 
      "end": "2018-02-09T10:36:49.888250"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 12
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888308", 
      "end": "2018-02-09T10:36:49.888313"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 13
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888372", 
      "end": "2018-02-09T10:36:49.888378"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 14
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f08", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888434", 
      "end": "2018-02-09T10:36:49.888439"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 15
  }, 
  {
    "arg_size": 8, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x55a38cfb28", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888501", 
      "end": "2018-02-09T10:36:49.888506"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00cc7aa355000000", 
    "arg_index": 16
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888565", 
      "end": "2018-02-09T10:36:49.888570"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "04000000", 
    "arg_index": 17
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888626", 
      "end": "2018-02-09T10:36:49.888631"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "40000000", 
    "arg_index": 18
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888690", 
      "end": "2018-02-09T10:36:49.888695"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c00f0000", 
    "arg_index": 19
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888754", 
      "end": "2018-02-09T10:36:49.888759"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "c00f0000", 
    "arg_index": 20
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888815", 
      "end": "2018-02-09T10:36:49.888820"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 21
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f0c", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888882", 
      "end": "2018-02-09T10:36:49.888888"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 22
  }, 
  {
    "arg_size": 4, 
    "kernel": "0x55a3607800", 
    "arg_value_ptr": "0x7fe7417f08", 
    "timestamp": {
      "start": "2018-02-09T10:36:49.888944", 
      "end": "2018-02-09T10:36:49.888950"
    }, 
    "errcode": 0, 
    "call": "clSetKernelArg", 
    "arg_value": "00000000", 
    "arg_index": 23
  }, 
  {
    "kernel": "0x55a3607800", 
    "profiling": {
      "start": 315018885955128, 
      "end": 315018885962908, 
      "queued": 315018885700857, 
      "submit": 315018885748253
    }, 
    "name": "softmax_layer_norm", 
    "lws": [
      0, 
      0, 
      0
    ], 
    "gwo": [
      0, 
      0, 
      0
    ], 
    "errcode": 0, 
    "queue": "0x55a2b3dc00", 
    "call": "clEnqueueNDRangeKernel", 
    "gws": [
      63, 
      1, 
      1
    ], 
    "timestamp": {
      "start": "2018-02-09T10:36:49.889015", 
      "end": "2018-02-09T10:36:49.889497"
    }, 
    "event_wait_list": [], 
    "event": "0"
  }
]